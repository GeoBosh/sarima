[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Georgi N. Boshnakov. Author, maintainer. Jamie Halliday. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Boshnakov GN, Halliday J (2021). sarima: Simulation Prediction Seasonal ARIMA Models. https://github.com/GeoBosh/sarima https://geobosh.github.io/sarima/.","code":"@Manual{,   title = {sarima: Simulation and Prediction with Seasonal ARIMA Models},   author = {Georgi N. Boshnakov and Jamie Halliday},   year = {2021},   note = {https://github.com/GeoBosh/sarima https://geobosh.github.io/sarima/}, }"},{"path":"/index.html","id":"installing-sarima","dir":"","previous_headings":"","what":"Simulation and Prediction with Seasonal ARIMA Models","title":"Simulation and Prediction with Seasonal ARIMA Models","text":"Install latest stable version sarima CRAN: can install development version sarima Github:","code":"install.packages(\"sarima\") remotes::install_github(\"GeoBosh/sarima\")"},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Simulation and Prediction with Seasonal ARIMA Models","text":"Functions, classes methods time series modelling ARIMA related models. aim package provide consistent interface user. example, single function autocorrelations() computes various kinds theoretical sample autocorrelations. work progress, see documentation vignettes current functionality. Function sarima() fits extended multiplicative seasonal ARIMA models trends, exogenous variables arbitrary roots unit circle, can fixed estimated. Reference manuals vignettes available usual running R sessions. example, Alternatively, links online versions documentation: sarima online reference manual sarima pdf reference manual CRAN vignette Garch white noise tests CRAN vignette Autocorrelations white noise tests CRAN","code":"vignette(package = \"sarima\") # which vignettes are available?  vignette(\"white_noise_tests\", package = \"sarima\") vignette(\"garch_tests_example\", package = \"sarima\")"},{"path":"/reference/ArmaModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Classes ArmaModel, ArModel MaModel package sarima.","code":""},{"path":"/reference/ArmaModel-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Classes \"ArModel\" \"MaModel\" subclasses   \"ArmaModel\" corresponding order always zero. recommended way create objects classes   functions ArmaModel, ArModel   MaModel. Objects can also created calls   form new(\"ArmaModel\", ..., ar, ma, mean, check).  See also   coerce-methods ways create objects   classes.","code":""},{"path":"/reference/ArmaModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"center: Object class \"numeric\" ~~ intercept: Object class \"numeric\" ~~ sigma2: Object class \"numeric\" ~~ ar: Object class \"BJFilter\" ~~ ma: Object class \"SPFilter\" ~~","code":""},{"path":"/reference/ArmaModel-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Class \"ArmaSpec\", directly. Class \"VirtualArmaModel\", directly. Class \"ArmaFilter\", class \"ArmaSpec\", distance 2. Class \"VirtualFilterModel\", class \"VirtualArmaModel\", distance 2. Class \"VirtualStationaryModel\", class \"VirtualArmaModel\", distance 2. Class \"VirtualArmaFilter\", class \"ArmaSpec\", distance 3. Class \"VirtualAutocovarianceModel\", class \"VirtualArmaModel\", distance 3. Class \"VirtualMeanModel\", class \"VirtualArmaModel\", distance 3. Class \"VirtualMonicFilter\", class \"ArmaSpec\", distance 4.","code":""},{"path":"/reference/ArmaModel-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"modelOrder signature(object = \"ArmaModel\", convention = \"ArFilter\"): ... modelOrder signature(object = \"ArmaModel\", convention = \"MaFilter\"): ... modelOrder signature(object = \"ArmaModel\", convention = \"missing\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaModel\"): ... sigmaSq signature(object = \"ArmaModel\"): ...","code":""},{"path":"/reference/ArmaModel-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/ArmaModel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"","code":"arma1p1 <- new(\"ArmaModel\", ar = 0.5, ma = 0.9, sigma2 = 1) autocovariances(arma1p1, maxlag = 10) #> An object of class \"Autocovariances\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #> 3.613333333 2.706666667 1.353333333 0.676666667 0.338333333 0.169166667  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #> 0.084583333 0.042291667 0.021145833 0.010572917 0.005286458  autocorrelations(arma1p1, maxlag = 10) #> An object of class \"Autocorrelations\" #>           0           1           2           3           4           5  #> 1.000000000 0.749077491 0.374538745 0.187269373 0.093634686 0.046817343  #>           6           7           8           9          10  #> 0.023408672 0.011704336 0.005852168 0.002926084 0.001463042  partialAutocorrelations(arma1p1, maxlag = 10) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.74907749 -0.42512100  0.29448975 -0.22337052  0.17832394  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #> -0.14703750  0.12391932 -0.10606466  0.09181545 -0.08015626  partialAutocovariances(arma1p1, maxlag = 10) #> An object of class \"PartialAutocovariances\" #>           0           1           2           3           4           5  #>  3.61333333  1.18790975 -0.55232849  0.34942744 -0.25181673  0.19464072  #>           6           7           8           9          10  #> -0.15702172  0.13030164 -0.11027274  0.09465347 -0.08210298   new(\"ArmaModel\", ar = 0.5, ma = 0.9, intercept = 4) #> An object of class \"ArmaModel\" #> intercept:  4  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9 new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23) #> An object of class \"ArmaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  new(\"ArModel\", ar = 0.5,  center = 1.23) #> An object of class \"ArModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) new(\"MaModel\", ma = 0.9,  center = 1.23) #> An object of class \"MaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  # argument 'mean' is an alias for 'center': new(\"ArmaModel\", ar = 0.5, ma = 0.9, mean = 1.23) #> An object of class \"ArmaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  ##  both center and intercept may be given ## (the mean is not equal to the intercept in this case) new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23, intercept = 2) #> An object of class \"ArmaModel\" #> mean:  2.563333  #> intercept:  2 (full intercept:  3.845 )  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  ## Don't use 'mean' together with 'center' and/or 'intercept'. ##    new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23, mean  = 4) ##    new(\"ArmaModel\", ar = 0.5, ma = 0.9, intercept = 2, mean  = 4) ## Both give error message: ##   Use argument 'mean' only when 'center' and 'intercept' are missing or zero"},{"path":"/reference/ArmaModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ARMA objects — ArmaModel","title":"Create ARMA objects — ArmaModel","text":"Create ARMA objects.","code":""},{"path":"/reference/ArmaModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ARMA objects — ArmaModel","text":"","code":"ArmaModel(...) ArModel(...) MaModel(...)"},{"path":"/reference/ArmaModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ARMA objects — ArmaModel","text":"... arguments passed new(). Typical     arguments ar, ma mean.","code":""},{"path":"/reference/ArmaModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ARMA objects — ArmaModel","text":"object representing ARMA, AR MA model","code":""},{"path":"/reference/ArmaModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create ARMA objects — ArmaModel","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/ArmaModel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ARMA objects — ArmaModel","text":"","code":"## MA ( ma2a1 <- MaModel(ma = c(0.3, 0.7), sigma2 = 1) ) #> An object of class \"MaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(ma2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>         0         1         2         3         4         5         6  #> 1.0000000 0.3227848 0.4430380 0.0000000 0.0000000 0.0000000 0.0000000  partialAutocorrelations(ma2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.32278481  0.37825873 -0.27488077 -0.14556210  0.21468510  #>       Lag_6  #>  0.03073491  autocovariances(ma2a1, maxlag = 6) #> An object of class \"Autocovariances\" #> Lag_0 Lag_1 Lag_2 Lag_3 Lag_4 Lag_5 Lag_6  #>  1.58  0.51  0.70  0.00  0.00  0.00  0.00  partialVariances(ma2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 1.580000 1.415380 1.212868 1.121224 1.097467 1.046885 1.045896   ## sigma2 is set to NA if not specified ## but things that don't depend on it are computed: ( ma2a2 <- MaModel(ma = c(0.3, 0.7)) ) #> An object of class \"MaModel\" #> mean:  0  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(ma2a2, maxlag = 6) #> An object of class \"Autocorrelations\" #>         0         1         2         3         4         5         6  #> 1.0000000 0.3227848 0.4430380 0.0000000 0.0000000 0.0000000 0.0000000  partialAutocorrelations(ma2a2, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.32278481  0.37825873 -0.27488077 -0.14556210  0.21468510  #>       Lag_6  #>  0.03073491   ## AR ( ar2a1 <- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) ) #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) autocorrelations(ar2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #>  1.0000000 -0.1764706 -0.6470588  0.3176471  0.3576471 -0.3296471 -0.1514588  partialAutocorrelations(ar2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00 -1.764706e-01 -7.000000e-01 -1.123440e-16  0.000000e+00  #>         Lag_5         Lag_6  #>  0.000000e+00 -5.617200e-17  autocovariances(ar2a1, maxlag = 6) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  2.0238095 -0.3571429 -1.3095238  0.6428571  0.7238095 -0.6671429 -0.3065238  partialVariances(ar2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 2.023810 1.960784 1.000000 1.000000 1.000000 1.000000 1.000000   ## ARMA ( arma2a1 <- ArmaModel(ar = 0.5, ma = c(0.3, 0.7), sigma2 = 1) ) #> An object of class \"ArmaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(arma2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.76434426 0.59733607 0.29866803 0.14933402 0.07466701 0.03733350  partialAutocorrelations(arma2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.76434426  0.03154068 -0.40352478  0.10241517  0.22187563  #>       Lag_6  #> -0.13073299    ## modelCoef() returns a list with components 'ar' and 'ma' modelCoef(arma2a1) #> $ar #> [1] 0.5 #>  #> $ma #> [1] 0.3 0.7 #>  modelCoef(ma2a1) #> $ar #> numeric(0) #>  #> $ma #> [1] 0.3 0.7 #>  modelCoef(ar2a1) #> $ar #> [1] -0.3 -0.7 #>  #> $ma #> numeric(0) #>   ## modelOrder() returns a list with components 'ar' and 'ma' modelOrder(arma2a1) #> $ar #> [1] 1 #>  #> $ma #> [1] 2 #>  modelOrder(ma2a1) #> $ar #> [1] 0 #>  #> $ma #> [1] 2 #>  modelOrder(ar2a1) #> $ar #> [1] 2 #>  #> $ma #> [1] 0 #>   as(ma2a1, \"ArmaModel\")  # success, as expected #> An object of class \"ArmaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 as(ar2a1, \"ArModel\")  # success, as expected #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) as(ArmaModel(ar = c(-0.3, -0.7)), \"ArModel\") #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) ## But these fail: ## as(ma2a1, \"ArModel\") # fails ## as(arma2a1, \"ArModel\") # fails ## as(arma2a1, \"MaModel\") # fails"},{"path":"/reference/InterceptSpec-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class InterceptSpec — InterceptSpec-class","title":"Class InterceptSpec — InterceptSpec-class","text":"helper class number models inherit intercept,   centering innovations variance.","code":""},{"path":"/reference/InterceptSpec-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class InterceptSpec — InterceptSpec-class","text":"Objects can created calls form new(\"InterceptSpec\", ...).","code":""},{"path":"/reference/InterceptSpec-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class InterceptSpec — InterceptSpec-class","text":"center: Object class \"numeric\",       centering parameter, defaults zero. intercept: Object class \"numeric\",       intercept parameter, defaults zero. sigma2: Object class \"numeric\",       innovations variance, defaults NA.","code":""},{"path":"/reference/InterceptSpec-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class InterceptSpec — InterceptSpec-class","text":"sigmaSq signature(object = \"InterceptSpec\"): ...","code":""},{"path":"/reference/InterceptSpec-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class InterceptSpec — InterceptSpec-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/InterceptSpec-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class InterceptSpec — InterceptSpec-class","text":"","code":"showClass(\"InterceptSpec\") #> Class \"InterceptSpec\" [package \"sarima\"] #>  #> Slots: #>                                      #> Name:     center intercept    sigma2 #> Class:   numeric   numeric   numeric #>  #> Known Subclasses:  #> Class \"ArmaSpec\", directly #> Class \"SarimaSpec\", directly #> Class \"ArmaModel\", by class \"ArmaSpec\", distance 2 #> Class \"ArModel\", by class \"ArmaSpec\", distance 3 #> Class \"MaModel\", by class \"ArmaSpec\", distance 3 #> Class \"SarimaModel\", by class \"SarimaSpec\", distance 2"},{"path":"/reference/SarimaModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class SarimaModel in package sarima — SarimaModel-class","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Class SarimaModel package sarima.","code":""},{"path":"/reference/SarimaModel-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Objects can created calls form new(\"SarimaModel\", ..., ar, ma, sar, sma). Class SarimaModel represents standard SARIMA models. provision centering /intercept (normal use one needed). default values zeroes. Note however default variance innovations (slot \"sigma2\") NA. rationale choice calculations innovations' variance needed , importantly, far easy forget include model (least author), may lead silently wrong results \"natural\" default value one used.","code":""},{"path":"/reference/SarimaModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"center: Object class \"numeric\",       number, zero ARIMA equation X(t) - center.  intercept: Object class \"numeric\",       number, intercept ARIMA equation.  sigma2: Object class \"numeric\",       positive number, innovations variance.  nseasons: Object class \"numeric\",       positive integer, number seasons. non-seasonal models       NA.  iorder: Object class \"numeric\",       non-negative integer, integration order.  siorder: Object class \"numeric\",       non-negative integer, seasonal integration order.  ar: Object class \"BJFilter\",       non-seasonal AR part model.  ma: Object class \"SPFilter\",       non-seasonal MA part model.  sar: Object class \"BJFilter\",       seasonal AR part model. sma: Object class \"SPFilter\",       seasonal MA part model.","code":""},{"path":"/reference/SarimaModel-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Class \"VirtualFilterModel\", directly. Class \"SarimaSpec\", directly. Class \"SarimaFilter\", class \"SarimaSpec\", distance 2. Class \"VirtualSarimaFilter\", class \"SarimaSpec\", distance 3. Class \"VirtualCascadeFilter\", class \"SarimaSpec\", distance 4. Class \"VirtualMonicFilter\", class \"SarimaSpec\", distance 5.","code":""},{"path":"/reference/SarimaModel-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"SARIMA models contain special cases number models.   one-argument method modelCoef essentially   definition model coefficients SARIMA models. two-argument   methods request model coefficients according convention   class second argument. second argument may also   character string naming target class. Essentially, methods modelCoef generalisation   =()= methods can interpreted (extent,   result necessarilly target class, least   target class may virtual).  modelCoef signature(object = \"SarimaModel\", convention = \"missing\"):       Converts object \"SarimaFilter\".  modelCoef signature(object = \"SarimaModel\", convention = \"SarimaFilter\"):       Converts object \"SarimaFilter\", equivalent       one-argument call modelCoef(object).  modelCoef signature(object = \"SarimaModel\", convention\t= \"ArFilter\"):       Convert object \"ArFilter\". error raised       object non-trivial moving average part.  modelCoef signature(object = \"SarimaModel\", convention\t= \"MaFilter\"):       Convert object \"MaFilter\". error raised       object non-trivial autoregressive part.  modelCoef signature(object = \"SarimaModel\", convention\t= \"ArmaFilter\"):       Convert object \"ArmaFilter\". operation always successeds.  modelCoef signature(object = \"SarimaModel\", convention\t= \"character\"):       second argument gives name target class.       conceptually equivalent modelCoef(object, new(convention)).  modelOrder gives order model according   conventions target class. error raised object   compatible target class.  modelOrder signature(object = \"SarimaModel\", convention = \"ArFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"MaFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"MaModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"missing\"): ... polynomials associated object can obtained   following methods. Note target \"ArmaFilter\" gives fully   expanded products AR MA polynomials, needed, e.g.,   filtering.  modelPoly signature(object = \"SarimaModel\", convention = \"ArmaFilter\"): `      Gives fully expanded polynomials list  modelPoly signature(object = \"SarimaModel\", convention = \"missing\"):       Gives polynomials associated model list.  modelPolyCoef signature(object = \"SarimaModel\", convention = \"ArmaFilter\"):       Give coefficients fully expanded polynomials list. modelPolyCoef signature(object = \"SarimaModel\", convention = \"missing\"):       Gives coefficients polynomials associated model list.","code":""},{"path":"/reference/SarimaModel-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/SarimaModel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"","code":"showClass(\"SarimaModel\") #> Class \"SarimaModel\" [package \"sarima\"] #>  #> Slots: #>                                                                              #> Name:   nseasons    iorder   siorder        ar        ma       sar       sma #> Class:   numeric   numeric   numeric  BJFilter  SPFilter  BJFilter  SPFilter #>                                      #> Name:     center intercept    sigma2 #> Class:   numeric   numeric   numeric #>  #> Extends:  #> Class \"VirtualSarimaModel\", directly #> Class \"SarimaSpec\", directly #> Class \"VirtualIntegratedModel\", by class \"VirtualSarimaModel\", distance 2 #> Class \"SarimaFilter\", by class \"SarimaSpec\", distance 2 #> Class \"InterceptSpec\", by class \"SarimaSpec\", distance 2 #> Class \"VirtualFilterModel\", by class \"VirtualSarimaModel\", distance 3 #> Class \"VirtualSarimaFilter\", by class \"SarimaSpec\", distance 3 #> Class \"VirtualCascadeFilter\", by class \"SarimaSpec\", distance 4 #> Class \"VirtualMonicFilter\", by class \"SarimaSpec\", distance 5  sm0 <- new(\"SarimaModel\", nseasons = 12)  sm1 <- new(\"SarimaModel\", nseasons = 12, intercept = 3) ## alternatively, pass a model and modify with named arguments sm1b <- new(\"SarimaModel\", sm0, intercept = 3) identical(sm1, sm1b) # TRUE #> [1] TRUE  ## Note: in the above models var. of innovations is NA  sm2  <- new(\"SarimaModel\", ar = 0.9, nseasons = 12, intercept = 3, sigma2 = 1) sm2b <- new(\"SarimaModel\", sm1, ar = 0.9, sigma2 = 1) sm2c <- new(\"SarimaModel\", sm0, ar = 0.9, intercept = 3, sigma2 = 1) identical(sm2, sm2b) # TRUE #> [1] TRUE identical(sm2, sm2c) # TRUE #> [1] TRUE  sm3 <- new(\"SarimaModel\", ar = 0.9, sar= 0.8, nseasons = 12, intercept = 3,            sigma2 = 1) sm3b <- new(\"SarimaModel\", sm2, sar = 0.8) identical(sm3, sm3b) # TRUE #> [1] TRUE  new(\"SarimaModel\", ar = 0.9) #> An object of class \"SarimaModel\" #> Model: Phi(B)X(t) = e(t) #>  #> mean:  0  #> sigmaSq:  NA  #> Non-seasonal model  #> Order of differencing:  0  #>  #> ar coefficients:   0.9 #> ma coefficients:    <None>"},{"path":"/reference/VirtualMonicFilter-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Undocumented classes in package sarima — VirtualMonicFilter-class","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"page classes without proper documentation.","code":""},{"path":"/reference/VirtualMonicFilter-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"virtual Class: objects may   created . page exists remind classes   documentation yet. exists avoid cluttering report 'R   CMD check' early stages development.","code":""},{"path":"/reference/VirtualMonicFilter-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"methods defined class \"VirtualMonicFilter\" signature.","code":""},{"path":"/reference/VirtualMonicFilter-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/acfGarchTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for GARCH white noise — acfGarchTest","title":"Test for GARCH white noise — acfGarchTest","text":"Carry test GARCH white noise","code":""},{"path":"/reference/acfGarchTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for GARCH white noise — acfGarchTest","text":"","code":"acfGarchTest(acr, x, nlags, interval = 0.95)  acfWnTest(acr, x, nlags, interval = 0.95, ...)"},{"path":"/reference/acfGarchTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for GARCH white noise — acfGarchTest","text":"acr autocorrelations. x time series. nlags many lags use. interval NULL, compute also confidence intervals     specified coverage probability. ... additional arguments computation variance matrix     null hypothesis, passed nvarOfAcfKP.","code":""},{"path":"/reference/acfGarchTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test for GARCH white noise — acfGarchTest","text":"Unlike autocorrelation IID test, time series needed   estimate covariance matrix autocorrelations null   hypothesis. acfGarchTest performs test uncorrelatedness time   series. null hypothesis time series GARCH,   see Francq Zakoian (2010) . acfWnTest performs test uncorrelatedness time   series weaker null hypothesis.   null hypothesis time series GARCH-type   stochasitc volatily model,   see   Kokoszka Politis (2011) . See references details precise specification   hypotheses. format return value acfIidTest.","code":""},{"path":"/reference/acfGarchTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for GARCH white noise — acfGarchTest","text":"list components \"test\" \"ci\"","code":""},{"path":"/reference/acfGarchTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test for GARCH white noise — acfGarchTest","text":"Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Kokoszka PS, Politis DN (2011). “Nonlinearity ARCH stochastic volatility models Bartlett's formula.” Probability Mathematical Statistics, 31(1), 47--59.","code":""},{"path":"/reference/acfGarchTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Test for GARCH white noise — acfGarchTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/acfGarchTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for GARCH white noise — acfGarchTest","text":"","code":"## see also the examples for \\code{\\link{whiteNoiseTest}} n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.pacf <- partialAutocorrelations(x)  acfGarchTest(x.acf, x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  1.093856 0.9546461 #> [2,] 10  3.963076 0.9489973 #> [3,] 20 10.968402 0.9470379 #>  #> $ci #>               int            #>  [1,] -0.04457987 0.04457987 #>  [2,] -0.04164430 0.04164430 #>  [3,] -0.03994455 0.03994455 #>  [4,] -0.03960120 0.03960120 #>  [5,] -0.03790493 0.03790493 #>  [6,] -0.03493302 0.03493302 #>  [7,] -0.03276773 0.03276773 #>  [8,] -0.03229043 0.03229043 #>  [9,] -0.03180697 0.03180697 #> [10,] -0.03118183 0.03118183 #> [11,] -0.03014861 0.03014861 #> [12,] -0.02857190 0.02857190 #> [13,] -0.02935817 0.02935817 #> [14,] -0.02795635 0.02795635 #> [15,] -0.02781152 0.02781152 #> [16,] -0.02801357 0.02801357 #> [17,] -0.02825691 0.02825691 #> [18,] -0.02755407 0.02755407 #> [19,] -0.02838672 0.02838672 #> [20,] -0.02737198 0.02737198 #>  acfGarchTest(x.pacf, x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  1.111252 0.9531029 #> [2,] 10  4.035463 0.9457330 #> [3,] 20 11.131840 0.9427316 #>  #> $ci #>               int            #>  [1,] -0.04457987 0.04457987 #>  [2,] -0.04164430 0.04164430 #>  [3,] -0.03994455 0.03994455 #>  [4,] -0.03960120 0.03960120 #>  [5,] -0.03790493 0.03790493 #>  [6,] -0.03493302 0.03493302 #>  [7,] -0.03276773 0.03276773 #>  [8,] -0.03229043 0.03229043 #>  [9,] -0.03180697 0.03180697 #> [10,] -0.03118183 0.03118183 #> [11,] -0.03014861 0.03014861 #> [12,] -0.02857190 0.02857190 #> [13,] -0.02935817 0.02935817 #> [14,] -0.02795635 0.02795635 #> [15,] -0.02781152 0.02781152 #> [16,] -0.02801357 0.02801357 #> [17,] -0.02825691 0.02825691 #> [18,] -0.02755407 0.02755407 #> [19,] -0.02838672 0.02838672 #> [20,] -0.02737198 0.02737198 #>   # do not compute CI's: acfGarchTest(x.pacf, x = x, nlags = c(5,10,20), interval = NULL) #> $test #>       h         Q      pval #> [1,]  5  1.111252 0.9531029 #> [2,] 10  4.035463 0.9457330 #> [3,] 20 11.131840 0.9427316 #>   ## plot methods call acfGarchTest() suitably if 'x' is given: plot(x.acf, data = x)  plot(x.pacf, data = x)   ## use 90% limits: plot(x.acf, data = x, interval = 0.90)   acfWnTest(x.acf, x = x, nlags = c(5,10,20)) #> $test #>       h          Q      pval #> [1,]  5  0.9692247 0.9650096 #> [2,] 10  3.7441889 0.9581501 #> [3,] 20 10.5538648 0.9569823 #>  #> $ci #>               int            #>  [1,] -0.04457987 0.04457987 #>  [2,] -0.04164430 0.04164430 #>  [3,] -0.03994455 0.03994455 #>  [4,] -0.03960120 0.03960120 #>  [5,] -0.03790493 0.03790493 #>  [6,] -0.03493302 0.03493302 #>  [7,] -0.03276773 0.03276773 #>  [8,] -0.03229043 0.03229043 #>  [9,] -0.03180697 0.03180697 #> [10,] -0.03118183 0.03118183 #> [11,] -0.03014861 0.03014861 #> [12,] -0.02857190 0.02857190 #> [13,] -0.02935817 0.02935817 #> [14,] -0.02795635 0.02795635 #> [15,] -0.02781152 0.02781152 #> [16,] -0.02801357 0.02801357 #> [17,] -0.02825691 0.02825691 #> [18,] -0.02755407 0.02755407 #> [19,] -0.02838672 0.02838672 #> [20,] -0.02737198 0.02737198 #>  nvarOfAcfKP(x, maxlag = 20) #>  [1] 2.5867323 2.2572771 2.0767724 2.0412231 1.8701017 1.5883492 1.3975473 #>  [8] 1.3571300 1.3167956 1.2655432 1.1830644 1.0625566 1.1218420 1.0172663 #> [15] 1.0067535 1.0214348 1.0392574 0.9882013 1.0488283 0.9751835 whiteNoiseTest(x.acf, h0 = \"arch-type\", x = x, nlags = c(5,10,20)) #> $test #>       h          Q      pval #> [1,]  5  0.9692247 0.9650096 #> [2,] 10  3.7441889 0.9581501 #> [3,] 20 10.5538648 0.9569823 #>  #> $ci #>               int            #>  [1,] -0.04457987 0.04457987 #>  [2,] -0.04164430 0.04164430 #>  [3,] -0.03994455 0.03994455 #>  [4,] -0.03960120 0.03960120 #>  [5,] -0.03790493 0.03790493 #>  [6,] -0.03493302 0.03493302 #>  [7,] -0.03276773 0.03276773 #>  [8,] -0.03229043 0.03229043 #>  [9,] -0.03180697 0.03180697 #> [10,] -0.03118183 0.03118183 #> [11,] -0.03014861 0.03014861 #> [12,] -0.02857190 0.02857190 #> [13,] -0.02935817 0.02935817 #> [14,] -0.02795635 0.02795635 #> [15,] -0.02781152 0.02781152 #> [16,] -0.02801357 0.02801357 #> [17,] -0.02825691 0.02825691 #> [18,] -0.02755407 0.02755407 #> [19,] -0.02838672 0.02838672 #> [20,] -0.02737198 0.02737198 #>"},{"path":"/reference/acfIidTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Carry out IID tests using sample autocorrelations — acfIidTest","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Carry tests IID sample autocorrelations.","code":""},{"path":"/reference/acfIidTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"","code":"acfIidTest(acf, n, npar = 0, nlags = npar + 1,            method = c(\"LiMcLeod\", \"LjungBox\", \"BoxPierce\"),            interval = 0.95, expandCI = TRUE, ...)"},{"path":"/reference/acfIidTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"acf autocorrelations. n length corresponding time series. npar number df subtract. nlags number autocorrelations use portmonteau     statistic, can vector request several statistics. method character string, one \"LiMcLeod\", \"LjungBox\" \"BoxPierce\". interval number NULL. expandCI logical flag, TRUE return CI lag     max(nlags). Used CI's requested. ... additional arguments passed methods. particular,     methods argument x time series.","code":""},{"path":"/reference/acfIidTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Performs one several tests IID based sample   autocorrelations. correction degrees freedom   residuals fitted models can specified argument   npar. nlags specifies number autocorrelations   use test, can vector request several tests. results test gathered matrix one row   element nlags. test statistic column \"ChiSq\",   degrees freedom \"DF\" p-value \"pvalue\". method   attribute \"method\". interval NULL confidence intervals   autocorrelations computed, null hypothesis   independence. coverage probability (probabilities)   speciified interval. argument expandCI TRUE, one row   lag, max(nlags). best use feature   single coverage probability. expandCI FALSE confidence intervals put   matrix one row coverage probability.","code":""},{"path":"/reference/acfIidTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"list components \"test\" (requested) \"ci\", described   Details","code":""},{"path":"/reference/acfIidTest.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"signature(acf = \"\") method acf contains autocorrelations. signature(acf = \"missing\") autocorrelations computed argument x (time series). signature(acf = \"SampleAutocorrelations\") convenience method argument n taken   acf thus need specified user.","code":""},{"path":"/reference/acfIidTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press.","code":""},{"path":"/reference/acfIidTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/acfIidTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"","code":"ts1 <- rnorm(100)  a1 <- drop(acf(ts1)$acf)  acfIidTest(a1, n = 100, nlags = c(5, 10, 20)) #> $test #>         ChiSq DF       pvalue #> [1,] 101.8398  5 2.163667e-20 #> [2,] 106.8602 10 2.289043e-18 #> [3,] 113.9828 20 3.668605e-15 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  acfIidTest(a1, n = 100, nlags = c(5, 10, 20), method = \"LjungBox\") #> $test #>         ChiSq DF       pvalue #> [1,] 104.8208  5 5.085360e-21 #> [2,] 109.9865 10 5.369374e-19 #> [3,] 116.7287 20 1.146707e-15 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  acfIidTest(a1, n = 100, nlags = c(5, 10, 20), interval = NULL) #> $test #>         ChiSq DF       pvalue #> [1,] 101.8398  5 2.163667e-20 #> [2,] 106.8602 10 2.289043e-18 #> [3,] 113.9828 20 3.668605e-15 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  acfIidTest(a1, n = 100, method = \"LjungBox\", interval = c(0.95, 0.90), expandCI = FALSE) #> $test #>         ChiSq DF       pvalue #> [1,] 103.0303  1 3.300609e-24 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>             int           #> [1,] -0.1959964 0.1959964 #> [2,] -0.1644854 0.1644854 #> attr(,\"level\") #> [1] 0.95 0.90 #>    ## acfIidTest() is called behind the scenes by methods for autocorrelation objects ts1_acrf <- autocorrelations(ts1) class(ts1_acrf)  # \"SampleAutocorrelations\" #> [1] \"SampleAutocorrelations\" #> attr(,\"package\") #> [1] \"sarima\" whiteNoiseTest(ts1_acrf, h0 = \"iid\", nlags = c(5,10,20), method = \"LiMcLeod\") #> $test #>         ChiSq DF    pvalue #> [1,]  2.53328  5 0.7714749 #> [2,]  7.76782 10 0.6515042 #> [3,] 13.98337 20 0.8313382 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  plot(ts1_acrf)   ## use 10% level of significance in the plot: plot(ts1_acrf, interval = 0.9)"},{"path":"/reference/acfMaTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocorrelation test for MA(q) — acfMaTest","title":"Autocorrelation test for MA(q) — acfMaTest","text":"Carry autocorrelation test MA(q).","code":""},{"path":"/reference/acfMaTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocorrelation test for MA(q) — acfMaTest","text":"","code":"acfMaTest(acf, ma, n, nlags, interval = 0.95)"},{"path":"/reference/acfMaTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocorrelation test for MA(q) — acfMaTest","text":"acf autocorrelations. ma positive integer, moving average order. n length corresponding time series. nlags number autocorrelations use portmonteau     statistic, can vector request several statistics. interval number NULL.","code":""},{"path":"/reference/acfMaTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autocorrelation test for MA(q) — acfMaTest","text":"acfMaTest performs test time series MA(ma),    classical assumptions Bartlett's formulas. intervals requested, confidence intervals lags 1   ma.  lags greater moving average order, ma,   autocorrelations outside suggest reject null hypothesis   process MA(ma).","code":""},{"path":"/reference/acfMaTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocorrelation test for MA(q) — acfMaTest","text":"list components \"test\" (requested) \"ci\"","code":""},{"path":"/reference/acfMaTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Autocorrelation test for MA(q) — acfMaTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/arma_Q0Gardner.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"Wrappers internals 'stats' functions used arima()   compute initial state covariance matrix ARMA models.","code":""},{"path":"/reference/arma_Q0Gardner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"","code":"<!-- % arma_Q0Gardner(phi, theta, tol = .Machine$double.eps) -->  <!-- % arma_Q0bis(phi, theta, tol = .Machine$double.eps) -->  arma_Q0naive(phi, theta, tol = .Machine$double.eps)  arma_Q0gnbR(phi, theta, tol = .Machine$double.eps)"},{"path":"/reference/arma_Q0Gardner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"phi autoregressive coefficients. theta moving average coefficients. tol tollerance.","code":""},{"path":"/reference/arma_Q0Gardner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"arima() uses one two methods compute initial state   covariance matrix stationary ARMA model. methods   implemented internal non-exported C functions.   arma_Q0Gardner() arma_Q0bis simple R wrappers   functions. defined tests (TODO: put   examples?) bit defined namespace package   since use unexported functions. arma_Q0Gardner() implements original method Gardner et   al (1980). arma_Q0bis() recent method deals   better roots close unit circle. functions can useful comparative testing.    put package 'sarima' since use `:::` operator   hence inadmissible CRAN.","code":""},{"path":"/reference/arma_Q0Gardner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"matrix","code":""},{"path":"/reference/arma_Q0Gardner.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"Gardner G, Harvey AC, Phillips GDA (1980). “Algorithm AS154. algorithm exact maximum likelihood estimation autoregressive-moving average models means Kalman filtering.” Applied Statistics, 311--322.","code":""},{"path":"/reference/arma_Q0Gardner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"","code":"## arma_Q0Gardner(phi, theta, tol = .Machine$double.eps) ## arma_Q0bis(phi, theta, tol = .Machine$double.eps)"},{"path":"/reference/arma_Q0gnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the initial state covariance of ARMA model — arma_Q0gnb","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Compute initial state covariance ARMA model","code":""},{"path":"/reference/arma_Q0gnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"","code":"arma_Q0gnb(phi, theta, tol = 2.220446e-16)"},{"path":"/reference/arma_Q0gnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"phi autoregression parameters. theta moving average parameters. tol tollerance. (TODO: explain)","code":""},{"path":"/reference/arma_Q0gnb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Experimental computation initial state covariance matrix   ARMA models. numerical results comparable   SSinit = \"Rossignol2011\" method arima   related functions.   method seems twice faster \"Rossignol2011\" models   tried done systematic tests. See section ‘examples’ , tests based   tests stats, tests   test/testthat/test-arma-q0.R.","code":""},{"path":"/reference/arma_Q0gnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"matrix","code":""},{"path":"/reference/arma_Q0gnb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Gardner G, Harvey AC, Phillips GDA (1980). “Algorithm AS154. algorithm exact maximum likelihood estimation autoregressive-moving average models means Kalman filtering.” Applied Statistics, 311--322. R bug report PR#14682 (2011-2013)   <URL: https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=14682>.","code":""},{"path":"/reference/arma_Q0gnb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/arma_Q0gnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"","code":"Q0a <- arma_Q0gnb(c(0.2, 0.5), c(0.3))  Q0b <- makeARIMA(c(0.2, 0.5), c(0.3), Delta = numeric(0))$Pn all.equal(Q0a, Q0b) ## TRUE #> [1] TRUE  ## see test/testthat/test-arma-q0.R for more; ## these functions cannot be defined in the package due to their use of ## \\code{:::} on exported base R functions. ## ## \"Gardner1980\" arma_Q0Gardner <- function(phi, theta, tol = .Machine$double.eps){     ## tol is not used here     .Call(stats:::C_getQ0, phi, theta) } ## \"Rossignol2011\" arma_Q0bis <- function(phi, theta, tol = .Machine$double.eps){     .Call(stats:::C_getQ0bis, phi, theta, tol) }  arma_Q0Gardner(c(0.2, 0.5), c(0.3)) #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 arma_Q0bis(c(0.2, 0.5), c(0.3))  #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 Q0a #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 Q0b #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778"},{"path":"/reference/armaccf_xe.html","id":null,"dir":"Reference","previous_headings":"","what":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Compute autocovariances ARMA models crosscovariances   ARMA process innovations.","code":""},{"path":"/reference/armaccf_xe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"","code":"armaccf_xe(model, lag.max = 1) armaacf(model, lag.max, compare)"},{"path":"/reference/armaccf_xe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"model model, list components ar, ma     sigma2 (time , sigmasq also accepted,     model$sigma2 NULL). lag.max maximal lag result. compare TRUE compute autocovariances also using     tacvfARMA() return results comparison.","code":""},{"path":"/reference/armaccf_xe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Given causal ARMA model, armaccf_xe computes theoretical   crosscovariances \\(R_{xe}(0)\\), \\(R_{xe}(1)\\),   \\(R_{xe}(lag.max)\\), \\(R_{xe}(k)=E(X_{t}e_{t-k})\\),   ARMA process innovations. Negative lags considered   since \\(R_{xe}(k)=0\\) \\(k<0\\). moving average polynomial   may roots unit circle. simple illustration equations give time   series courses. armaacf computes ARMA autocovariances. default method   computes computes zero lag autocovariance using   armaccf_xe() multiplies autocorrelations obtained   ARMAacf (computes autocorrelations,   autocovariances). compare = TRUE also uses   tacvfARMA package ltsa returns results   matrix comparison. matrix columns \"native\",   \"tacvfARMA\" \"difference\", last column   contains (zapped) differences autocorrelations   obtained two methods. ARMA parameters argument model follow   Brockwell-Davis convention signs. Since tacvfARMA()   uses Box-Jenkins convention signs, moving average   parameters negated calls tacvfARMA().","code":""},{"path":"/reference/armaccf_xe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"armaccf_xe, crosscovariances lags 0, ..., maxlag.   armaacf, autocovariances, see Details.","code":""},{"path":"/reference/armaccf_xe.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"McLeod AI, Yu H, Krougly Z (2007). “Algorithms Linear Time Series Analysis: R Package.” Journal Statistical Software, 23(5). doi: 10.18637/jss.v023.i05 .","code":""},{"path":"/reference/armaccf_xe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/armaccf_xe.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"armaacf useful exploratory computations   autocovariances convenient eliminates   need know function names particular cases.","code":""},{"path":"/reference/armaccf_xe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"","code":"## Example 1 from ?ltsa::tacvfARMA z <- sqrt(sunspot.year) n <- length(z) p <- 9 q <- 0 ML <- 5 out <- arima(z, order = c(p, 0, q))  phi <- theta <- numeric(0) if (p > 0) phi <- coef(out)[1:p] if (q > 0) theta <- coef(out)[(p+1):(p+q)] zm <- coef(out)[p+q+1] sigma2 <- out$sigma2  armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20) #>          0          1          2          3          4          5          6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>          7          8          9         10         11         12         13  #> -1.5271174  1.2132068  4.1082578  6.0479060  6.3673284  4.9897294  2.5321902  #>         14         15         16         17         18         19         20  #> -0.1699738 -2.2803602 -3.1718781 -2.6404447 -0.9043874  1.4099559  3.5163219  ## this illustrates that the methods ## based on ARMAacf and tacvARMA are equivalent: armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20, compare = TRUE) #>        native  tacvfARMA difference #> 0   9.0416079  9.0416079          0 #> 1   7.5475908  7.5475908          0 #> 2   4.3845239  4.3845239          0 #> 3   0.8271273  0.8271273          0 #> 4  -1.9801678 -1.9801678          0 #> 5  -3.4909677 -3.4909677          0 #> 6  -3.3114507 -3.3114507          0 #> 7  -1.5271174 -1.5271174          0 #> 8   1.2132068  1.2132068          0 #> 9   4.1082578  4.1082578          0 #> 10  6.0479060  6.0479060          0 #> 11  6.3673284  6.3673284          0 #> 12  4.9897294  4.9897294          0 #> 13  2.5321902  2.5321902          0 #> 14 -0.1699738 -0.1699738          0 #> 15 -2.2803602 -2.2803602          0 #> 16 -3.1718781 -3.1718781          0 #> 17 -2.6404447 -2.6404447          0 #> 18 -0.9043874 -0.9043874          0 #> 19  1.4099559  1.4099559          0 #> 20  3.5163219  3.5163219          0  ## In the original example in ?ltsa::tacvfARMA ## the comparison is with var(z), not with the theoretical variance: rA <- ltsa::tacvfARMA(phi, - theta, maxLag=n+ML-1, sigma2=sigma2) rB <- var(z) * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1) ## so rA and rB are different. ## but the difference is due to the variance: rB2 <- rA[1] * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1) cbind(rA[1:5], rB[1:5], rB2[1:5]) #>         [,1]       [,2]       [,3] #> 0  9.0416079  8.4034699  9.0416079 #> 1  7.5475908  7.0148975  7.5475908 #> 2  4.3845239  4.0750733  4.3845239 #> 3  0.8271273  0.7687504  0.8271273 #> 4 -1.9801678 -1.8404116 -1.9801678  ## There is no need to use specific functions, ## autocovariances() is most convenient for routine use: armalist <- list(ar = phi, ma = theta, sigma2 = sigma2) autocovariances(armalist, maxlag = 10) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>      Lag_7      Lag_8      Lag_9     Lag_10  #> -1.5271174  1.2132068  4.1082578  6.0479060   ## even better, set up an ARMA model: mo <- new(\"ArmaModel\", ar = phi, ma = theta, sigma2 = sigma2) autocovariances(mo, maxlag = 10) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>      Lag_7      Lag_8      Lag_9     Lag_10  #> -1.5271174  1.2132068  4.1082578  6.0479060"},{"path":"/reference/autocorrelations-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function autocorrelations() — autocorrelations-methods","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"Methods function autocorrelations().","code":""},{"path":"/reference/autocorrelations-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/autocorrelations-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"signature(x = \"\", maxlag = \"\", lag_0 = \"\")  signature(x = \"\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"Autocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"Autocorrelations\", maxlag = \"missing\", lag_0 = \"missing\")  signature(x = \"Autocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"SamplePartialAutocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"SamplePartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"VirtualArmaModel\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"VirtualSarimaModel\", maxlag = \"\", lag_0 = \"missing\")","code":""},{"path":"/reference/autocorrelations-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"","code":"## see the examples for ?autocorrelations"},{"path":"/reference/autocorrelations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute autocorrelations and related quantities — autocorrelations","title":"Compute autocorrelations and related quantities — autocorrelations","text":"Generic functions computation autocorrelations,   autocovariances related quantities. idea free user   need look specific functions compute desired   property object.","code":""},{"path":"/reference/autocorrelations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute autocorrelations and related quantities — autocorrelations","text":"","code":"autocovariances(x, maxlag, ...)  autocorrelations(x, maxlag, lag_0, ...)  partialAutocorrelations(x, maxlag, lag_0 = TRUE, ...)  partialAutocovariances(x, maxlag, ...)  partialVariances(x, ...)"},{"path":"/reference/autocorrelations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute autocorrelations and related quantities — autocorrelations","text":"x object requested property makes sense. maxlag maximal lag include result. lag_0 TRUE include lag zero. ... arguments methods.","code":""},{"path":"/reference/autocorrelations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute autocorrelations and related quantities — autocorrelations","text":"autocorrelations generic function computation   autocorrelations.  deduces appropriate type autocorrelation   class object.  example, models computes   theoretical autocorrelations, time series computes sample   autocorrelations. functions described similar second order   properties x. functions return objects suitable classes, inheriting   \"Lagged\". latter means indexing starts zero,   value lag zero accessed r[0]). Subscripting   always returns underlying data unclassed (.e. ordinary vectors   arrays). particular, \"[]\" extracts underlying data. Functions computing autocorrelations partial autocorrelations   argument lag_0 --- set FALSE, value   lag zero dropped result returned object   ordinary vector array, appropriate. See individual methods format result   details.","code":""},{"path":"/reference/autocorrelations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute autocorrelations and related quantities — autocorrelations","text":"object class suitable requested property x","code":""},{"path":"/reference/autocorrelations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute autocorrelations and related quantities — autocorrelations","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/autocorrelations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute autocorrelations and related quantities — autocorrelations","text":"","code":"v1 <- rnorm(100) autocorrelations(v1) #> An object of class \"SampleAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.071663769  0.048659209 -0.058743280 -0.005963299 -0.116995968  #>        Lag_6        Lag_7        Lag_8        Lag_9       Lag_10       Lag_11  #>  0.084424565  0.023398035  0.012029517 -0.148496245 -0.019922004  0.112806586  #>       Lag_12       Lag_13       Lag_14       Lag_15       Lag_16       Lag_17  #>  0.009333223  0.155981077  0.011980841 -0.172140255 -0.101078610  0.121509913  #>       Lag_18       Lag_19       Lag_20  #>  0.035487249  0.016045368  0.018035738  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x v1.acf <- autocorrelations(v1, maxlag = 10)  v1.acf[1:10] # drop lag zero value (and the class) #>  [1]  0.071663769  0.048659209 -0.058743280 -0.005963299 -0.116995968 #>  [6]  0.084424565  0.023398035  0.012029517 -0.148496245 -0.019922004 autocorrelations(v1, maxlag = 10, lag_0 = FALSE) # same #>  [1]  0.071663769  0.048659209 -0.058743280 -0.005963299 -0.116995968 #>  [6]  0.084424565  0.023398035  0.012029517 -0.148496245 -0.019922004  partialAutocorrelations(v1) #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000  0.0716637688  0.0437481907 -0.0656753272  0.0005966234  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.1118487791  0.0994443764  0.0203871673 -0.0134815041 -0.1450361124  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -0.0086132374  0.1591737755 -0.0282810821  0.1452485090 -0.0421725756  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -0.1796076935 -0.0160441708  0.1476790609  0.0274541090 -0.0596472995  #>        Lag_20  #>  0.0157266973  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(v1, maxlag = 10) #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000  0.0716637688  0.0437481907 -0.0656753272  0.0005966234  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.1118487791  0.0994443764  0.0203871673 -0.0134815041 -0.1450361124  #>        Lag_10  #> -0.0086132374  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from raw data autocovariances(v1) #> An object of class \"SampleAutocovariances\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  0.997508668  0.071485231  0.048537983 -0.058596931 -0.005948442 -0.116704492  #>        Lag_6        Lag_7        Lag_8        Lag_9       Lag_10       Lag_11  #>  0.084214235  0.023339743  0.011999548 -0.148126291 -0.019872371  0.112525548  #>       Lag_12       Lag_13       Lag_14       Lag_15       Lag_16       Lag_17  #>  0.009309970  0.155592476  0.011950993 -0.171711396 -0.100826790  0.121207192  #>       Lag_18       Lag_19       Lag_20  #>  0.035398839  0.016005394  0.017990805  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x autocovariances(v1, maxlag = 10) #> An object of class \"SampleAutocovariances\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  0.997508668  0.071485231  0.048537983 -0.058596931 -0.005948442 -0.116704492  #>        Lag_6        Lag_7        Lag_8        Lag_9       Lag_10  #>  0.084214235  0.023339743  0.011999548 -0.148126291 -0.019872371  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(v1, maxlag = 6) #> An object of class \"SamplePartialAutocovariances\" #>             0             1             2             3             4  #>  0.9975086685  0.0711181042  0.0433319895 -0.0647699418  0.0005883982  #>             5             6  #> -0.1089268626  0.0958887773  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(v1) #> An object of class \"SamplePartialAutocovariances\" #>             0             1             2             3             4  #>  0.9975086685  0.0711181042  0.0433319895 -0.0647699418  0.0005883982  #>             5             6             7             8             9  #> -0.1089268626  0.0958887773  0.0196500605 -0.0129917129 -0.1368268000  #>            10            11            12            13            14  #> -0.0081251094  0.1463487821 -0.0259816138  0.1306235204 -0.0378587905  #>            15            16            17            18            19  #> -0.1560345312 -0.0139348164  0.1254661334  0.0233070594 -0.0504571861  #>            20  #>  0.0133003277  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(v1, maxlag = 6) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 0.9975087 0.9923858 0.9904864 0.9862142 0.9862139 0.9738762 0.9642453  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x pv1 <- partialVariances(v1)  ## compute 2nd order properties from raw data autocovariances(AirPassengers, maxlag = 6) #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 14291.973 13549.467 12513.692 11529.066 10756.502 10201.181  9743.318  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x autocorrelations(AirPassengers, maxlag = 6) #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialAutocovariances\" #>           0           1           2           3           4           5  #> 14291.97333  1371.29064  -314.37784    52.19801   127.19886    99.29006  #>           6  #>    10.42335  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 14291.973  1446.437  1370.305  1368.310  1356.275  1348.927  1348.846  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  acv <- autocovariances(AirPassengers, maxlag = 6) autocovariances(acv) # no-op #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 14291.973 13549.467 12513.692 11529.066 10756.502 10201.181  9743.318  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x autocovariances(acv, maxlag = 4) # trim the available lags #> An object of class \"SampleAutocovariances\" #>    Lag_0    Lag_1    Lag_2    Lag_3    Lag_4  #> 14291.97 13549.47 12513.69 11529.07 10756.50  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from sample autocovariances acr <- autocorrelations(acv) acr #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(acv) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(acv) #> An object of class \"SamplePartialAutocovariances\" #>           0           1           2           3           4           5  #> 14291.97333  1371.29064  -314.37784    52.19801   127.19886    99.29006  #>           6  #>    10.42335  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(acv) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 14291.973  1446.437  1370.305  1368.310  1356.275  1348.927  1348.846  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from sample autocorrelations acr #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(acr) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## These cannot be computed, since the variance is needed but unknown: ##     autocovariances(acr) ##     partialAutocovariances(acr) ##     partialVariances(acr)  ## to treat autocorrelations as autocovariances,  ## convert them to autocovariances explicitly: as(acr, \"Autocovariances\") #> An object of class \"Autocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  as(acr, \"SampleAutocovariances\") #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  partialVariances(as(acr, \"Autocovariances\")) #> An object of class \"PartialVariances\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.10120624 0.09587931 0.09573978 0.09489768 0.09438353 0.09437790  partialVariances(as(acr, \"SampleAutocovariances\")) #> An object of class \"SamplePartialVariances\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.10120624 0.09587931 0.09573978 0.09489768 0.09438353 0.09437790  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x"},{"path":"/reference/autocovariances-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function autocovariances() — autocovariances-methods","title":"Methods for function autocovariances() — autocovariances-methods","text":"Methods function autocovariances().","code":""},{"path":"/reference/autocovariances-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function autocovariances() — autocovariances-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/autocovariances-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function autocovariances() — autocovariances-methods","text":"signature(x = \"\", maxlag = \"\")  signature(x = \"Autocovariances\", maxlag = \"\")  signature(x = \"Autocovariances\", maxlag = \"missing\")  signature(x = \"VirtualArmaModel\", maxlag = \"\")  signature(x = \"VirtualAutocovariances\", maxlag = \"\")","code":""},{"path":[]},{"path":"/reference/autocovariances-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function autocovariances() — autocovariances-methods","text":"","code":"## see the examples for ?autocorrelations"},{"path":"/reference/coerce-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"setAs methods in package sarima — coerce-methods","title":"setAs methods in package sarima — coerce-methods","text":"Methods () package sarima.","code":""},{"path":"/reference/coerce-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"setAs methods in package sarima — coerce-methods","text":"section shows methods converting objects one class   another, defined via setAs(). Use (obj, \"classname\")   convert object obj class \"classname\". signature(= \"\", = \"Autocorrelations\")  signature(= \"\", = \"ComboAutocorrelations\")  signature(= \"\", = \"ComboAutocovariances\")  signature(= \"\", = \"PartialAutocorrelations\")  signature(= \"\", = \"PartialAutocovariances\")  signature(= \"\", = \"PartialVariances\")  signature(= \"ArmaSpec\", = \"list\")  signature(= \"Autocorrelations\", = \"ComboAutocorrelations\")  signature(= \"Autocorrelations\", = \"ComboAutocovariances\")  signature(= \"Autocovariances\", = \"ComboAutocorrelations\")  signature(= \"Autocovariances\", = \"ComboAutocovariances\")  signature(= \"BJFilter\", = \"SPFilter\")  signature(= \"numeric\", = \"BJFilter\") Convert numeric vector BJFilter object.   way state coefficients follow Box-Jenkins   convention signs, see examples. signature(= \"numeric\", = \"SPFilter\") Convert numeric vector SPFilter object.  way   state coefficients follow signal processing (SP)   convention signs, see examples. signature(= \"PartialVariances\", = \"Autocorrelations\")  signature(= \"PartialVariances\", = \"Autocovariances\")  signature(= \"PartialVariances\", = \"ComboAutocorrelations\")  signature(= \"PartialVariances\", = \"ComboAutocovariances\")  signature(= \"SarimaFilter\", = \"ArmaFilter\")  signature(= \"SarimaModel\", = \"list\")  signature(= \"SPFilter\", = \"BJFilter\")  signature(= \"vector\", = \"Autocorrelations\")  signature(= \"vector\", = \"Autocovariances\")  signature(= \"vector\", = \"PartialAutocorrelations\")  signature(= \"vector\", = \"PartialAutocovariances\")  signature(= \"VirtualArmaFilter\", = \"list\")  signature(= \"VirtualSarimaModel\", = \"ArmaModel\")","code":""},{"path":"/reference/coerce-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"setAs methods in package sarima — coerce-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/coerce-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"setAs methods in package sarima — coerce-methods","text":"","code":"## the default for ARMA model is BJ for ar and SP for ma: mo <- new(\"ArmaModel\", ar = 0.9, ma = 0.4, sigma2 = 1) modelPoly(mo) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>   ## here we declare explicitly that 0.4 uses the SP convention ##    (not necessary, the result is the same, but the intention is clear). mo1 <- new(\"ArmaModel\", ar = 0.9, ma = as(0.4, \"SPFilter\"), sigma2 = 1) modelPoly(mo1) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo1) ## TRUE #> [1] TRUE  ## if the sign of theta follows the BJ convention, this can be stated unambiguously. ##   This creates the same model: mo2 <- new(\"ArmaModel\", ar = 0.9, ma = as(-0.4, \"BJFilter\"), sigma2 = 1) modelPoly(mo2) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo2) ## TRUE #> [1] TRUE  ## And this gives the intended model whatever the default conventions: ar3 <- as(0.9, \"BJFilter\") ma3 <- as(-0.4, \"BJFilter\") mo3 <- new(\"ArmaModel\", ar = ar3, ma = ma3, sigma2 = 1) modelPoly(mo3) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo3) ## TRUE #> [1] TRUE  ## The coefficients can be extracted in any particular form, ## e.g. to pass them to functions with specific requirements: modelCoef(mo3) # coefficients of the model with the default (BD) sign convention #> $ar #> [1] 0.9 #>  #> $ma #> [1] 0.4 #>  modelCoef(mo3, convention = \"BD\") # same result #> $ar #> [1] 0.9 #>  #> $ma #> [1] 0.4 #>  modelCoef(mo3, convention = \"SP\") # signal processing convention #> $ar #> [1] -0.9 #>  #> $ma #> [1] 0.4 #>    ## for ltsa::tacvfARMA() the convention is BJ, so: co <- modelCoef(mo3, convention = \"BJ\") # Box-Jenkins convention  ltsa::tacvfARMA(co$ar, co$ma, maxLag = 6, sigma2 = 1) #> [1] 9.894737 9.305263 8.374737 7.537263 6.783537 6.105183 5.494665 autocovariances(mo3, maxlag = 6) ## same #> An object of class \"Autocovariances\" #>    Lag_0    Lag_1    Lag_2    Lag_3    Lag_4    Lag_5    Lag_6  #> 9.894737 9.305263 8.374737 7.537263 6.783537 6.105183 5.494665"},{"path":"/reference/filterCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterCoef() — filterCoef-methods","title":"Methods for filterCoef() — filterCoef-methods","text":"Methods filterCoef package sarima.","code":""},{"path":"/reference/filterCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterCoef() — filterCoef-methods","text":"filterCoef() returns coefficients object.   format result depends type filter, see   descriptions individual methods . argument convention omitted, sign convention   coefficients one used object. convention can   set \"BJ\" \"SP\" request, respectively, Box-Jenkins   signal processing convention. Also, \"-\" equivalent \"BJ\" \"+\"   \"SP\". ARMA filters, \"BJ\" \"SP\" request corresponding convention   parts (AR MA). widely used convention, e.g., base R   (Brockwell Davis 1991) , \"BJ\" AR part   \"SP\" MA part.  can requested convention =   \"BD\".  convenience, \"--\" equivalent \"BJ\", \"++\" \"SP\",   \"-+\" \"BD\". completeness, \"+-\" can used request \"SP\"   AR part \"BJ\" MA part. Invalid values convention throw error. particular, low   level filters, \"BJFilter\" know AR MA,   throw error convention \"BD\" \"+-\" (\"++\"   \"--\" ok, since unambiguous). Similarly avoid   subtle errors, ARMA filters accept \"+\" \"-\".  signature(object = \"VirtualMonicFilterSpec\", convention = \"missing\") returns  object@coef. signature(object = \"VirtualBJFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"VirtualSPFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"BJFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"SPFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"VirtualArmaFilter\", convention = \"missing\")  signature(object = \"VirtualArmaFilter\", convention = \"character\") Conceptually, calls filterCoef(), one argument,       AR MA parts model. convention present,       converts result specified convention.  Returns list       following components: ar AR coefficients. ma MA coefficients.  signature(object = \"SarimaFilter\", convention = \"missing\")  signature(object = \"SarimaFilter\", convention = \"character\") convention present, converts coefficients       specified convention. AR-like coefficients get convention       AR part, Ma-like coefficients get convention MA       part. Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) \t  differences. siorder seasonal integration order, number seasonal \t  differences. ar ar coefficients. ma ma coefficients. sar seasonal ar coefficients. sma seasonal ma coefficients.","code":""},{"path":"/reference/filterCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterCoef() — filterCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/filterCoef-methods.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Methods for filterCoef() — filterCoef-methods","text":"Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag..","code":""},{"path":[]},{"path":"/reference/filterCoef-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterCoef() — filterCoef-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"/reference/filterCoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients and other basic properties of filters — filterCoef","title":"Coefficients and other basic properties of filters — filterCoef","text":"Coefficients basic properties filters.","code":""},{"path":"/reference/filterCoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients and other basic properties of filters — filterCoef","text":"","code":"filterCoef(object, convention, ...)  filterOrder(object, ...)  filterPoly(object, ...)  filterPolyCoef(object, lag_0 = TRUE, ...)"},{"path":"/reference/filterCoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients and other basic properties of filters — filterCoef","text":"object object. convention convention sign. lag_0 FALSE, drop coefficient order zero. ... arguments methods.","code":""},{"path":"/reference/filterCoef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coefficients and other basic properties of filters — filterCoef","text":"Generic functions extract basic properties filters:   filterCoef returns coefficients,   filterOrder returns order,   filterPoly, returns characteristic polynomial,   filterPolyCoef gives coefficients characteristic   polynomial. details argument convention see    filterCoef-methods. exactly returned depends specific filter classes, see   description corresponding methods. core filters,   values can expected. \"ArmaFilter\", value   list components \"ar\" \"ma\" giving requested property   corresponding part filter. Similarly, \"SarimaFilter\"   values lists, maybe additional quantities.","code":""},{"path":"/reference/filterCoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients and other basic properties of filters — filterCoef","text":"requested property described Details.","code":""},{"path":"/reference/filterCoef.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coefficients and other basic properties of filters — filterCoef","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/filterCoef.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coefficients and other basic properties of filters — filterCoef","text":"filterXXX() functions somewhat low level   technical. rarely needed routine work.   corresponding modelXXX flexible.","code":""},{"path":[]},{"path":"/reference/filterCoef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients and other basic properties of filters — filterCoef","text":"","code":"filterPoly(as(c(0.3, 0.5), \"BJFilter\"))   # 1 - 0.3*x - 0.5*x^2 #> 1 - 0.3*x - 0.5*x^2  filterPoly(as(c(0.3, 0.5), \"SPFilter\"))   # 1 + 0.3*x + 0.5*x^2 #> 1 + 0.3*x + 0.5*x^2   ## now two representations of the same filter: fi1 <- as(c(0.3, 0.5), \"BJFilter\") fi2 <- as(c(-0.3, -0.5), \"SPFilter\") identical(fi2, fi1) # FALSE, but #> [1] FALSE ## fi1 and fi2 represent the same filter, eg. same ch. polynomials: filterPoly(fi1) #> 1 - 0.3*x - 0.5*x^2  filterPoly(fi2) #> 1 - 0.3*x - 0.5*x^2  identical(filterPolyCoef(fi2), filterPolyCoef(fi1)) #> [1] TRUE  # same as above, using new() fi1a <- new(\"BJFilter\", coef = c(0.3, 0.5)) identical(fi1a, fi1) # TRUE #> [1] TRUE  fi2a <- new(\"SPFilter\", coef = c(-0.3, -0.5)) identical(fi2a, fi2) # TRUE #> [1] TRUE  ## conversion by as() changes the internal representation ## but represents the same filter: identical(as(fi1, \"SPFilter\"), fi2) # TRUE #> [1] TRUE  c(filterOrder(fi1), filterOrder(fi2)) #> [1] 2 2  ## these give the internally stored coefficients: filterCoef(fi1) #> [1] 0.3 0.5 filterCoef(fi2) #> [1] -0.3 -0.5  ## with argument 'convention' the result doesn't depend ## on the internal representation: co1 <- filterCoef(fi1, convention = \"SP\") co2 <- filterCoef(fi2, convention = \"SP\") identical(co1, co2) # TRUE #> [1] TRUE"},{"path":"/reference/filterOrder-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function filterOrder in package sarima — filterOrder-methods","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"Methods function filterOrder package sarima.","code":""},{"path":"/reference/filterOrder-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"following methods ensure  filters package sarima   method filterOrder. signature(object = \"VirtualMonicFilterSpec\") Returns object@order. signature(object = \"SarimaFilter\") Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) differences. siorder seasonal integration order, number seasonal \tdifferences. ar autoregression order ma moving average order sar seasonal autoregression order sma seasonal moving average order  signature(object = \"VirtualArmaFilter\") Returns list following components: ar autoregression order. ma moving average order.","code":""},{"path":"/reference/filterOrder-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/filterOrder-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"/reference/filterPoly-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterPoly in package sarima — filterPoly-methods","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"Methods filterPoly package sarima.","code":""},{"path":"/reference/filterPoly-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"methods filterPoly take care implicitly sign   convention used store coefficients object.  signature(object = \"BJFilter\") polynomial whose coefficients negated filter       coefficients. signature(object = \"SPFilter\") polynomial whose coefficients stored object. signature(object = \"SarimaFilter\") Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) \t  differences. siorder seasonal integration order, number seasonal \t  differences. arpoly autoregression polynomial mapoly moving average polynomial sarpoly seasonal autoregression polynomial smapoly seasonal moving average polynomial fullarpoly polynomial obtained multiplying \t  AR-like terms, including differences. fullmapoly polynomial obtained multiplying \t  MA terms core_sarpoly core seasonal autoregression polynomial. \t  sarpoly(\\(z\\)) = core_sarpoly(\\(z^{nseasons}\\)) core_smapoly core seasonal moving average polynomial. \t  smapoly(\\(z\\)) = core_smapoly(\\(z^{nseasons}\\))  signature(object = \"VirtualArmaFilter\") Returns list following components: ar autoregression polynomial. ma moving average polynomial.  signature(object = \"VirtualMonicFilterSpec\") Calls filterPolyCoef(object) converts result       polynomial. Thus, sufficient method       filterPolyCoef().","code":""},{"path":"/reference/filterPoly-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/filterPoly-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"/reference/filterPolyCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterPolyCoef — filterPolyCoef-methods","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"Methods filterPolyCoef package sarima.","code":""},{"path":"/reference/filterPolyCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"filterPolyCoef methods return results   structure corresponding methods filterPoly   polynomials replaced coefficients. lag_0   FALSE order 0 coefficients dropped. signature(object = \"VirtualBJFilter\") Calls filterCoef(object), negates result prepends 1     lag_0 TRUE. signature(object = \"VirtualSPFilter\") Calls filterCoef(object) prepends 1 result     lag_0 TRUE. signature(object = \"VirtualArmaFilter\") Returns list following components: ar coefficients autoregression polynomial. ma coefficients moving average polynomial.  signature(object = \"BJFilter\") coefficients polynomial whose coefficients negated     filter coefficients. equivalent method     \"VirtualBJFilter\" somewhat efficient. signature(object = \"SPFilter\") coefficients polynomial whose coefficients stored     object. equivalent method \"VirtualSPFilter\"     somewhat efficient. signature(object = \"SarimaFilter\") Returns list components \"SarimaFilter\" method     filterPoly, polynomials replaced     coefficients.","code":""},{"path":"/reference/filterPolyCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/filterPolyCoef-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"/reference/fun.forecast.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting functions for seasonal ARIMA models — fun.forecast","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"Forecasting functions seasonal ARIMA models.","code":""},{"path":"/reference/fun.forecast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"","code":"fun.forecast(past, n = max(2 * length(past), 12), eps = numeric(n), pasteps, ...)"},{"path":"/reference/fun.forecast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"past past values time series, default zeroes. n number forecasts compute. eps values white noise sequence (simulation      future). Currently used! pasteps past values white noise sequence models     MA terms, 0 default. ... specification model, passed new()     create \"SarimaModel\" object, see Details.","code":""},{"path":"/reference/fun.forecast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"fun.forecast computes predictions SARIMA model.    model specified using \"...\" arguments passed   new(\"SarimaModel\", ...), see description class   \"SarimaModel\" details. Argument past, provided, contain least many values   needed prediction equation. harmless provide   values necessary, even whole time series. fun.forecast can used illustrate, example,   inherent difference prediction integrated seasonally   integrated models corresponding models roots close unit   circle.","code":""},{"path":"/reference/fun.forecast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"forecasts object class \"ts\"","code":""},{"path":"/reference/fun.forecast.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/fun.forecast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"","code":"f1 <- fun.forecast(past = 1, n = 100, ar = c(0.85), center = 5) plot(f1)   f2 <- fun.forecast(past = 8, n = 100, ar = c(0.85), center = 5) plot(f2)   f3 <- fun.forecast(past = 10, n = 100, ar = c(-0.85), center = 5) plot(f3)   frw1 <- fun.forecast(past = 1, n = 100, iorder = 1) plot(frw1)   frw2 <- fun.forecast(past = 3, n = 100, iorder = 1) plot(frw2)   frwa1 <- fun.forecast(past = c(1, 2), n = 100, ar = c(0.85), iorder = 1) plot(frwa1)   fi2a <- fun.forecast(past = c(3, 1), n = 100, iorder = 2) plot(fi2a)   fi2b <- fun.forecast(past = c(1, 3), n = 100, iorder = 2) plot(fi2b)   fari1p2 <- fun.forecast(past = c(0, 1, 3), ar = c(0.9), n = 20, iorder = 2) plot(fari1p2)   fsi1 <- fun.forecast(past = rnorm(4), n = 100, siorder = 1, nseasons = 4) plot(fsi1)   fexa <- fun.forecast(past = rnorm(5), n = 100, ar = c(0.85), siorder = 1,                      nseasons = 4) plot(fexa)   fi2a <- fun.forecast(past = rnorm(24, sd = 5), n = 120, siorder = 2,                      nseasons = 12) plot(fi2a)   fi1si1a <- fun.forecast(past = rnorm(24, sd = 5), n = 120, iorder = 1,                         siorder = 1, nseasons = 12) plot(fi1si1a)   fi1si1a <- fun.forecast(past = AirPassengers[120:144], n = 120, iorder = 1,                         siorder = 1, nseasons = 12) plot(fi1si1a)   m1 <- list(iorder = 1, siorder = 1, ma = 0.8, nseasons = 12, sigma2 = 1) m1 #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ma #> [1] 0.8 #>  #> $nseasons #> [1] 12 #>  #> $sigma2 #> [1] 1 #>  x <- sim_sarima(model = m1, n = 500) acf(diff(diff(x), lag = 12), lag.max = 96)  pacf(diff(diff(x), lag = 12), lag.max = 96)   m2 <- list(iorder = 1, siorder = 1, ma = 0.8, sma = 0.5, nseasons = 12,            sigma2 = 1) m2 #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ma #> [1] 0.8 #>  #> $sma #> [1] 0.5 #>  #> $nseasons #> [1] 12 #>  #> $sigma2 #> [1] 1 #>  x2 <- sim_sarima(model = m2, n = 500) acf(diff(diff(x2), lag = 12), lag.max = 96)  pacf(diff(diff(x2), lag = 12), lag.max = 96)  fit2 <- arima(x2, order = c(0, 1, 1),               seasonal = list(order = c(0, 1, 0), nseasons = 12)) fit2 #>  #> Call: #> arima(x = x2, order = c(0, 1, 1), seasonal = list(order = c(0, 1, 0), nseasons = 12)) #>  #> Coefficients: #>           ma1 #>       -0.1497 #> s.e.   0.0541 #>  #> sigma^2 estimated as 41.35:  log likelihood = -1633.46,  aic = 3270.92 tsdiag(fit2)  tsdiag(fit2, gof.lag = 96)   x2past <- rnorm(13, sd = 10) x2 <- sim_sarima(model = m2, n = 500, x = list(init = x2past)) plot(x2)   fun.forecast(ar = 0.5, n = 100) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(ar = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 5.000000e-01 2.500000e-01 1.250000e-01 6.250000e-02 3.125000e-02 #>   [6] 1.562500e-02 7.812500e-03 3.906250e-03 1.953125e-03 9.765625e-04 #>  [11] 4.882812e-04 2.441406e-04 1.220703e-04 6.103516e-05 3.051758e-05 #>  [16] 1.525879e-05 7.629395e-06 3.814697e-06 1.907349e-06 9.536743e-07 #>  [21] 4.768372e-07 2.384186e-07 1.192093e-07 5.960464e-08 2.980232e-08 #>  [26] 1.490116e-08 7.450581e-09 3.725290e-09 1.862645e-09 9.313226e-10 #>  [31] 4.656613e-10 2.328306e-10 1.164153e-10 5.820766e-11 2.910383e-11 #>  [36] 1.455192e-11 7.275958e-12 3.637979e-12 1.818989e-12 9.094947e-13 #>  [41] 4.547474e-13 2.273737e-13 1.136868e-13 5.684342e-14 2.842171e-14 #>  [46] 1.421085e-14 7.105427e-15 3.552714e-15 1.776357e-15 8.881784e-16 #>  [51] 4.440892e-16 2.220446e-16 1.110223e-16 5.551115e-17 2.775558e-17 #>  [56] 1.387779e-17 6.938894e-18 3.469447e-18 1.734723e-18 8.673617e-19 #>  [61] 4.336809e-19 2.168404e-19 1.084202e-19 5.421011e-20 2.710505e-20 #>  [66] 1.355253e-20 6.776264e-21 3.388132e-21 1.694066e-21 8.470329e-22 #>  [71] 4.235165e-22 2.117582e-22 1.058791e-22 5.293956e-23 2.646978e-23 #>  [76] 1.323489e-23 6.617445e-24 3.308722e-24 1.654361e-24 8.271806e-25 #>  [81] 4.135903e-25 2.067952e-25 1.033976e-25 5.169879e-26 2.584939e-26 #>  [86] 1.292470e-26 6.462349e-27 3.231174e-27 1.615587e-27 8.077936e-28 #>  [91] 4.038968e-28 2.019484e-28 1.009742e-28 5.048710e-29 2.524355e-29 #>  [96] 1.262177e-29 6.310887e-30 3.155444e-30 1.577722e-30 7.888609e-31 fun.forecast(ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(iorder = 1, ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(iorder = 1, ma = 0.5, ar = 0.8, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 8.000000e-01 6.400000e-01 5.120000e-01 4.096000e-01 3.276800e-01 #>   [6] 2.621440e-01 2.097152e-01 1.677722e-01 1.342177e-01 1.073742e-01 #>  [11] 8.589935e-02 6.871948e-02 5.497558e-02 4.398047e-02 3.518437e-02 #>  [16] 2.814750e-02 2.251800e-02 1.801440e-02 1.441152e-02 1.152922e-02 #>  [21] 9.223372e-03 7.378698e-03 5.902958e-03 4.722366e-03 3.777893e-03 #>  [26] 3.022315e-03 2.417852e-03 1.934281e-03 1.547425e-03 1.237940e-03 #>  [31] 9.903520e-04 7.922816e-04 6.338253e-04 5.070602e-04 4.056482e-04 #>  [36] 3.245186e-04 2.596148e-04 2.076919e-04 1.661535e-04 1.329228e-04 #>  [41] 1.063382e-04 8.507059e-05 6.805647e-05 5.444518e-05 4.355614e-05 #>  [46] 3.484491e-05 2.787593e-05 2.230075e-05 1.784060e-05 1.427248e-05 #>  [51] 1.141798e-05 9.134385e-06 7.307508e-06 5.846007e-06 4.676805e-06 #>  [56] 3.741444e-06 2.993155e-06 2.394524e-06 1.915619e-06 1.532496e-06 #>  [61] 1.225996e-06 9.807971e-07 7.846377e-07 6.277102e-07 5.021681e-07 #>  [66] 4.017345e-07 3.213876e-07 2.571101e-07 2.056881e-07 1.645505e-07 #>  [71] 1.316404e-07 1.053123e-07 8.424983e-08 6.739987e-08 5.391989e-08 #>  [76] 4.313591e-08 3.450873e-08 2.760699e-08 2.208559e-08 1.766847e-08 #>  [81] 1.413478e-08 1.130782e-08 9.046257e-09 7.237006e-09 5.789604e-09 #>  [86] 4.631684e-09 3.705347e-09 2.964277e-09 2.371422e-09 1.897138e-09 #>  [91] 1.517710e-09 1.214168e-09 9.713344e-10 7.770676e-10 6.216540e-10 #>  [96] 4.973232e-10 3.978586e-10 3.182869e-10 2.546295e-10 2.037036e-10  fun.forecast(m1, n = 100) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #> $sigma2 #> [1] 0 #>  #> [[2]] #> [1] 0 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 0 #>  #> [[5]] #> [1] 0 #>  #> [[6]] #> [1] 0 #>  #> [[7]] #> [1] 0 #>  #> [[8]] #> [1] 0 #>  #> [[9]] #> [1] 0 #>  #> [[10]] #> [1] 0 #>  #> [[11]] #> [1] 0 #>  #> [[12]] #> [1] 0 #>  #> [[13]] #> [1] 0 #>  #> [[14]] #> [1] 0 #>  #> [[15]] #> [1] 0 #>  #> [[16]] #> [1] 0 #>  #> [[17]] #> [1] 0 #>  #> [[18]] #> [1] 0 #>  #> [[19]] #> [1] 0 #>  #> [[20]] #> [1] 0 #>  #> [[21]] #> [1] 0 #>  #> [[22]] #> [1] 0 #>  #> [[23]] #> [1] 0 #>  #> [[24]] #> [1] 0 #>  #> [[25]] #> [1] 0 #>  #> [[26]] #> [1] 0 #>  #> [[27]] #> [1] 0 #>  #> [[28]] #> [1] 0 #>  #> [[29]] #> [1] 0 #>  #> [[30]] #> [1] 0 #>  #> [[31]] #> [1] 0 #>  #> [[32]] #> [1] 0 #>  #> [[33]] #> [1] 0 #>  #> [[34]] #> [1] 0 #>  #> [[35]] #> [1] 0 #>  #> [[36]] #> [1] 0 #>  #> [[37]] #> [1] 0 #>  #> [[38]] #> [1] 0 #>  #> [[39]] #> [1] 0 #>  #> [[40]] #> [1] 0 #>  #> [[41]] #> [1] 0 #>  #> [[42]] #> [1] 0 #>  #> [[43]] #> [1] 0 #>  #> [[44]] #> [1] 0 #>  #> [[45]] #> [1] 0 #>  #> [[46]] #> [1] 0 #>  #> [[47]] #> [1] 0 #>  #> [[48]] #> [1] 0 #>  #> [[49]] #> [1] 0 #>  #> [[50]] #> [1] 0 #>  #> [[51]] #> [1] 0 #>  #> [[52]] #> [1] 0 #>  #> [[53]] #> [1] 0 #>  #> [[54]] #> [1] 0 #>  #> [[55]] #> [1] 0 #>  #> [[56]] #> [1] 0 #>  #> [[57]] #> [1] 0 #>  #> [[58]] #> [1] 0 #>  #> [[59]] #> [1] 0 #>  #> [[60]] #> [1] 0 #>  #> [[61]] #> [1] 0 #>  #> [[62]] #> [1] 0 #>  #> [[63]] #> [1] 0 #>  #> [[64]] #> [1] 0 #>  #> [[65]] #> [1] 0 #>  #> [[66]] #> [1] 0 #>  #> [[67]] #> [1] 0 #>  #> [[68]] #> [1] 0 #>  #> [[69]] #> [1] 0 #>  #> [[70]] #> [1] 0 #>  #> [[71]] #> [1] 0 #>  #> [[72]] #> [1] 0 #>  #> [[73]] #> [1] 0 #>  #> [[74]] #> [1] 0 #>  #> [[75]] #> [1] 0 #>  #> [[76]] #> [1] 0 #>  #> [[77]] #> [1] 0 #>  #> [[78]] #> [1] 0 #>  #> [[79]] #> [1] 0 #>  #> [[80]] #> [1] 0 #>  #> [[81]] #> [1] 0 #>  #> [[82]] #> [1] 0 #>  #> [[83]] #> [1] 0 #>  #> [[84]] #> [1] 0 #>  #> [[85]] #> [1] 0 #>  #> [[86]] #> [1] 0 #>  #> [[87]] #> [1] 0 #>  #> [[88]] #> [1] 0 #>  #> [[89]] #> [1] 0 #>  #> [[90]] #> [1] 0 #>  #> [[91]] #> [1] 0 #>  #> [[92]] #> [1] 0 #>  #> [[93]] #> [1] 0 #>  #> [[94]] #> [1] 0 #>  #> [[95]] #> [1] 0 #>  #> [[96]] #> [1] 0 #>  #> [[97]] #> [1] 0 #>  #> [[98]] #> [1] 0 #>  #> [[99]] #> [1] 0 #>  #> [[100]] #> [1] 0 #>  #> [[101]] #> [1] 0 #>  fun.forecast(m2, n = 100) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #> $sigma2 #> [1] 0 #>  #> [[2]] #> [1] 0 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 0 #>  #> [[5]] #> [1] 0 #>  #> [[6]] #> [1] 0 #>  #> [[7]] #> [1] 0 #>  #> [[8]] #> [1] 0 #>  #> [[9]] #> [1] 0 #>  #> [[10]] #> [1] 0 #>  #> [[11]] #> [1] 0 #>  #> [[12]] #> [1] 0 #>  #> [[13]] #> [1] 0 #>  #> [[14]] #> [1] 0 #>  #> [[15]] #> [1] 0 #>  #> [[16]] #> [1] 0 #>  #> [[17]] #> [1] 0 #>  #> [[18]] #> [1] 0 #>  #> [[19]] #> [1] 0 #>  #> [[20]] #> [1] 0 #>  #> [[21]] #> [1] 0 #>  #> [[22]] #> [1] 0 #>  #> [[23]] #> [1] 0 #>  #> [[24]] #> [1] 0 #>  #> [[25]] #> [1] 0 #>  #> [[26]] #> [1] 0 #>  #> [[27]] #> [1] 0 #>  #> [[28]] #> [1] 0 #>  #> [[29]] #> [1] 0 #>  #> [[30]] #> [1] 0 #>  #> [[31]] #> [1] 0 #>  #> [[32]] #> [1] 0 #>  #> [[33]] #> [1] 0 #>  #> [[34]] #> [1] 0 #>  #> [[35]] #> [1] 0 #>  #> [[36]] #> [1] 0 #>  #> [[37]] #> [1] 0 #>  #> [[38]] #> [1] 0 #>  #> [[39]] #> [1] 0 #>  #> [[40]] #> [1] 0 #>  #> [[41]] #> [1] 0 #>  #> [[42]] #> [1] 0 #>  #> [[43]] #> [1] 0 #>  #> [[44]] #> [1] 0 #>  #> [[45]] #> [1] 0 #>  #> [[46]] #> [1] 0 #>  #> [[47]] #> [1] 0 #>  #> [[48]] #> [1] 0 #>  #> [[49]] #> [1] 0 #>  #> [[50]] #> [1] 0 #>  #> [[51]] #> [1] 0 #>  #> [[52]] #> [1] 0 #>  #> [[53]] #> [1] 0 #>  #> [[54]] #> [1] 0 #>  #> [[55]] #> [1] 0 #>  #> [[56]] #> [1] 0 #>  #> [[57]] #> [1] 0 #>  #> [[58]] #> [1] 0 #>  #> [[59]] #> [1] 0 #>  #> [[60]] #> [1] 0 #>  #> [[61]] #> [1] 0 #>  #> [[62]] #> [1] 0 #>  #> [[63]] #> [1] 0 #>  #> [[64]] #> [1] 0 #>  #> [[65]] #> [1] 0 #>  #> [[66]] #> [1] 0 #>  #> [[67]] #> [1] 0 #>  #> [[68]] #> [1] 0 #>  #> [[69]] #> [1] 0 #>  #> [[70]] #> [1] 0 #>  #> [[71]] #> [1] 0 #>  #> [[72]] #> [1] 0 #>  #> [[73]] #> [1] 0 #>  #> [[74]] #> [1] 0 #>  #> [[75]] #> [1] 0 #>  #> [[76]] #> [1] 0 #>  #> [[77]] #> [1] 0 #>  #> [[78]] #> [1] 0 #>  #> [[79]] #> [1] 0 #>  #> [[80]] #> [1] 0 #>  #> [[81]] #> [1] 0 #>  #> [[82]] #> [1] 0 #>  #> [[83]] #> [1] 0 #>  #> [[84]] #> [1] 0 #>  #> [[85]] #> [1] 0 #>  #> [[86]] #> [1] 0 #>  #> [[87]] #> [1] 0 #>  #> [[88]] #> [1] 0 #>  #> [[89]] #> [1] 0 #>  #> [[90]] #> [1] 0 #>  #> [[91]] #> [1] 0 #>  #> [[92]] #> [1] 0 #>  #> [[93]] #> [1] 0 #>  #> [[94]] #> [1] 0 #>  #> [[95]] #> [1] 0 #>  #> [[96]] #> [1] 0 #>  #> [[97]] #> [1] 0 #>  #> [[98]] #> [1] 0 #>  #> [[99]] #> [1] 0 #>  #> [[100]] #> [1] 0 #>  #> [[101]] #> [1] 0 #>  fun.forecast(iorder = 1, ar = 0.8, ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 8.000000e-01 6.400000e-01 5.120000e-01 4.096000e-01 3.276800e-01 #>   [6] 2.621440e-01 2.097152e-01 1.677722e-01 1.342177e-01 1.073742e-01 #>  [11] 8.589935e-02 6.871948e-02 5.497558e-02 4.398047e-02 3.518437e-02 #>  [16] 2.814750e-02 2.251800e-02 1.801440e-02 1.441152e-02 1.152922e-02 #>  [21] 9.223372e-03 7.378698e-03 5.902958e-03 4.722366e-03 3.777893e-03 #>  [26] 3.022315e-03 2.417852e-03 1.934281e-03 1.547425e-03 1.237940e-03 #>  [31] 9.903520e-04 7.922816e-04 6.338253e-04 5.070602e-04 4.056482e-04 #>  [36] 3.245186e-04 2.596148e-04 2.076919e-04 1.661535e-04 1.329228e-04 #>  [41] 1.063382e-04 8.507059e-05 6.805647e-05 5.444518e-05 4.355614e-05 #>  [46] 3.484491e-05 2.787593e-05 2.230075e-05 1.784060e-05 1.427248e-05 #>  [51] 1.141798e-05 9.134385e-06 7.307508e-06 5.846007e-06 4.676805e-06 #>  [56] 3.741444e-06 2.993155e-06 2.394524e-06 1.915619e-06 1.532496e-06 #>  [61] 1.225996e-06 9.807971e-07 7.846377e-07 6.277102e-07 5.021681e-07 #>  [66] 4.017345e-07 3.213876e-07 2.571101e-07 2.056881e-07 1.645505e-07 #>  [71] 1.316404e-07 1.053123e-07 8.424983e-08 6.739987e-08 5.391989e-08 #>  [76] 4.313591e-08 3.450873e-08 2.760699e-08 2.208559e-08 1.766847e-08 #>  [81] 1.413478e-08 1.130782e-08 9.046257e-09 7.237006e-09 5.789604e-09 #>  [86] 4.631684e-09 3.705347e-09 2.964277e-09 2.371422e-09 1.897138e-09 #>  [91] 1.517710e-09 1.214168e-09 9.713344e-10 7.770676e-10 6.216540e-10 #>  [96] 4.973232e-10 3.978586e-10 3.182869e-10 2.546295e-10 2.037036e-10"},{"path":"/reference/isStationaryModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a model is stationary — isStationaryModel","title":"Check if a model is stationary — isStationaryModel","text":"Check model stationary.","code":""},{"path":"/reference/isStationaryModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a model is stationary — isStationaryModel","text":"","code":"isStationaryModel(object)"},{"path":"/reference/isStationaryModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a model is stationary — isStationaryModel","text":"object object","code":""},{"path":"/reference/isStationaryModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if a model is stationary — isStationaryModel","text":"generic function.   returns TRUE object represents stationary model   FALSE otherwise.","code":""},{"path":"/reference/isStationaryModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a model is stationary — isStationaryModel","text":"TRUE FALSE","code":""},{"path":"/reference/isStationaryModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if a model is stationary — isStationaryModel","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/isStationaryModel.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Check if a model is stationary — isStationaryModel","text":"signature(object = \"SarimaSpec\")  signature(object = \"VirtualIntegratedModel\")  signature(object = \"VirtualStationaryModel\")","code":""},{"path":[]},{"path":"/reference/modelCenter.html","id":null,"dir":"Reference","previous_headings":"","what":"model center — modelCenter","title":"model center — modelCenter","text":"model center","code":""},{"path":"/reference/modelCenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model center — modelCenter","text":"","code":"modelCenter(object)"},{"path":"/reference/modelCenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model center — modelCenter","text":"object object","code":""},{"path":"/reference/modelCenter.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"model center — modelCenter","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"/reference/modelCenter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"model center — modelCenter","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/modelCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for generic function modelCoef — modelCoef-methods","title":"Methods for generic function modelCoef — modelCoef-methods","text":"Methods generic function modelCoef.","code":""},{"path":"/reference/modelCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for generic function modelCoef — modelCoef-methods","text":"signature(object = \"Autocorrelations\", convention = \"ComboAutocorrelations\", component = \"missing\")  signature(object = \"Autocorrelations\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"ComboAutocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"ComboAutocovariances\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"ComboAutocorrelations\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"ComboAutocorrelations\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"Autocovariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"PartialAutocovariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"PartialVariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"VirtualAutocovariances\", component = \"missing\")  signature(object = \"PartialAutocorrelations\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArmaFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"MaFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"SarimaFilter\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"character\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"missing\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"VirtualAutocovariances\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArModel\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"MaModel\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"BD\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"BJ\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"missing\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"SP\", component = \"missing\")  signature(object = \"ArmaModel\", convention = \"ArmaFilter\",            component = \"missing\")  signature(object = \"VirtualAutocovariances\",            convention = \"Autocovariances\", component = \"missing\")","code":""},{"path":"/reference/modelCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for generic function modelCoef — modelCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/modelCoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the coefficients of models — modelCoef","title":"Get the coefficients of models — modelCoef","text":"Get coefficients object, optionally specifying   expected format.","code":""},{"path":"/reference/modelCoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the coefficients of models — modelCoef","text":"","code":"modelCoef(object, convention, component, ...)"},{"path":"/reference/modelCoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the coefficients of models — modelCoef","text":"object object. convention convention use return value, character string     object supported class, see Details. component missing, specifies component extract, see Details. ... used, arguments methods.","code":""},{"path":"/reference/modelCoef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the coefficients of models — modelCoef","text":"modelCoef generic function extraction coefficients   model objects. `coeffcients' means depends class   object can changed optional argument   convention. effect, modelCoef provides   flexible descriptive way extracting coefficients models   various forms. one-argument form, modelCoef(object), gives   coefficients object. effect defines, purposes   modelCoef, meaning `coefficients' class   class(modelCoef). Argument convention can used specify kind value   return. convention character string, class   used. Conceptually, value format meaning   value returned call modelCoef(obj)   obj class class(convention). convention character string, typically name   class. case modelCoef(object, \"someclass\")   equivalent modelCoef(object, new(\"someclass\")).  Note   conceptual - argument convention can name   virtual class, example.  Also, classes object   character values names classes may supported. example, obj class \"ArmaModel\",   modelCoef(obj) returns list components \"ar\" \"ma\",   follow \"BD\" convention. , get list   coefficients object class capable   representing ARMA models, set convention = \"ArmaModel\"   call modelCoef{}. modelCoef() signal error object   compatible target (e.g. contains unit roots).   (see filterCoef need expand multiplicative   filters).   TODO: rethink , reflect current behaviour! class returns exactly needed   additional computation may necessary.   \"ArmaModel\" example might need coefficients \"BJ\"   convention, need change signs MA   coefficients achieve . Since common operation,   convenience feature available. Setting convention = \"BJ\"   requests ARMA coefficients \"BJ\" convention. completeness,   settings \"SP\" (signal processing) \"BD\" (Brockwell-Davis)   also available. methods modelCoef() package \"sarima\" return list   components depending argument \"convention\", outlined   .","code":""},{"path":"/reference/modelCoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the coefficients of models — modelCoef","text":"list, components depending target class, described   Details","code":""},{"path":"/reference/modelCoef.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the coefficients of models — modelCoef","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/modelCoef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the coefficients of models — modelCoef","text":"","code":"## define a seasonal ARIMA model, it has a number of components m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12) m1 #> An object of class \"SarimaModel\" #> Model: (1-B)(1-B^s)X(t) = Theta(B)Theta_s(B)e(t) #>  #> Intercept:  0  #> SigmaSq:  NA  #> Period:  12  #> Order of differencing:  1  #> Order of seasonal differencing:  1  #>  #> ar coefficients:    <None> #> ma coefficients:   -0.3 #> seasonal ar coefficients:   <None> #> seasonal ma coefficients:  -0.1 ## Get the coefficients corresponding to a 'flat' ARMA model, ## obtained by multiplying out AR-like and MA-like terms.  ## A simple way is to use modelCoef() with a suitable convention: modelCoef(m1, \"ArmaModel\") #> $ar #>  [1]  1  0  0  0  0  0  0  0  0  0  0  1 -1 #>  #> $ma #>  [1] -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 -0.10 #> [13]  0.03 #>  modelCoef(m1, \"ArmaFilter\") ## same #> $ar #>  [1]  1  0  0  0  0  0  0  0  0  0  0  1 -1 #>  #> $ma #>  [1] -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 -0.10 #> [13]  0.03 #>   ## Here is another model m1a <- new(\"SarimaModel\", iorder = 1, siorder = 1,  ar = 0.6, nseasons = 12) modelCoef(m1a, \"ArmaModel\") #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  modelCoef(m1a, \"ArmaFilter\") ## same #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>   ## if only AR-like terms are allowed in a computation, ## use convention = \"ArModel\" to state it explicitly. ## ## this works, since m1a contains only AR-like terms: modelCoef(m1a, \"ArModel\") #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  modelCoef(m1a, \"ArFilter\") ## same #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  ## ... but these would throw errors if evaluated, ## since model m1a contains both AR-like and MA-like terms, if (FALSE) { modelCoef(m1, \"ArModel\") modelCoef(m1, \"ArFilter\") modelCoef(m1, \"MaModel\") modelCoef(m1, \"MaFilter\") }"},{"path":"/reference/modelIntercept.html","id":null,"dir":"Reference","previous_headings":"","what":"Give the intercept parameter of a model — modelIntercept","title":"Give the intercept parameter of a model — modelIntercept","text":"Give intercept parameter model.","code":""},{"path":"/reference/modelIntercept.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give the intercept parameter of a model — modelIntercept","text":"","code":"modelIntercept(object)"},{"path":"/reference/modelIntercept.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give the intercept parameter of a model — modelIntercept","text":"object object class intercept defined.","code":""},{"path":"/reference/modelIntercept.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Give the intercept parameter of a model — modelIntercept","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"/reference/modelIntercept.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Give the intercept parameter of a model — modelIntercept","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/modelOrder-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the order of a model — modelOrder-methods","title":"Get the order of a model — modelOrder-methods","text":"Get order model.","code":""},{"path":"/reference/modelOrder-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get the order of a model — modelOrder-methods","text":"signature(object = \"ArmaModel\", convention = \"ArFilter\")  signature(object = \"ArmaModel\", convention = \"MaFilter\")  signature(object = \"SarimaModel\", convention = \"ArFilter\")  signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"SarimaModel\", convention = \"ArmaModel\")  signature(object = \"SarimaModel\", convention = \"ArModel\")  signature(object = \"SarimaModel\", convention = \"MaFilter\")  signature(object = \"SarimaModel\", convention = \"MaModel\")  signature(object = \"VirtualFilterModel\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"/reference/modelOrder-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the order of a model — modelOrder-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/modelOrder.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the model order and other properties of models — modelOrder","title":"Get the model order and other properties of models — modelOrder","text":"Get model order properties models.","code":""},{"path":"/reference/modelOrder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the model order and other properties of models — modelOrder","text":"","code":"modelOrder(object, convention, ...)  modelPoly(object, convention, ...)  modelPolyCoef(object, convention, lag_0 = TRUE, ...)"},{"path":"/reference/modelOrder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the model order and other properties of models — modelOrder","text":"object model object. convention convention. lag_0 TRUE include lag_0 coef, otherwise drop . ... arguments methods.","code":""},{"path":"/reference/modelOrder.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the model order and other properties of models — modelOrder","text":"functions return requested quantity, optionally requesting   returned value follow specific convention, see also   modelCoef. called one argument, functions return corresponding   property native format object's class. Argument convention requests result   format. mental model returned value   object first converted class specified convention   property extracted computed. Normally, object   actually converted class. one obvious reason efficiency   may also possible, example argument   convention name virtual class. example, order seasonal SARIMA model specified   several numbers. call modelOrder(object) returns   list components ar, ma, sar, sma, iorder, siorder nseasons.   computations needed overall AR MA   orders obtained multiplying AR-like MA-like terms   model.   result ARMA filter requested    modelOrder(object, \"ArmaFilter\"). operation valid ARIMA model, always   succeed.  hand, computation work   moving average terms model one use   modelOrder(object, \"ArFilter\"). , object contains   MA terms error raised. concept powerful helps writing expressive code.   example simple check returned value even   , check may require additional care.","code":""},{"path":"/reference/modelOrder.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the model order and other properties of models — modelOrder","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/modelOrder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the model order and other properties of models — modelOrder","text":"","code":"m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12) modelOrder(m1) #> $nseasons #> [1] 12 #>  #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ar #> [1] 0 #>  #> $ma #> [1] 1 #>  #> $sar #> [1] 0 #>  #> $sma #> [1] 1 #>  modelOrder(m1, \"ArmaFilter\") #> $ar #> [1] 13 #>  #> $ma #> [1] 13 #>  modelOrder(m1, new(\"ArmaFilter\")) #> $ar #> [1] 13 #>  #> $ma #> [1] 13 #>   modelPoly(m1, \"ArmaModel\") #> $ar #> 1 - x - x^12 + x^13  #>  #> $ma #> 1 - 0.3*x - 0.1*x^12 + 0.03*x^13  #>  modelPolyCoef(m1, \"ArmaModel\") #> $ar #>  [1]  1 -1  0  0  0  0  0  0  0  0  0  0 -1  1 #>  #> $ma #>  [1]  1.00 -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 #> [13] -0.10  0.03 #>"},{"path":"/reference/modelPoly-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Get polynomials associated with SARIMA models — modelPoly-methods","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"Get polynomials associated SARIMA models.","code":""},{"path":"/reference/modelPoly-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"VirtualMonicFilter\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"/reference/modelPoly-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/modelPolyCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for modelPolyCoef — modelPolyCoef-methods","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"Methods modelPolyCoef, e generic function getting   coefficients polynomials associated SARIMA models.","code":""},{"path":"/reference/modelPolyCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"VirtualMonicFilter\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"/reference/modelPolyCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/nSeasons.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of seasons — nSeasons","title":"Number of seasons — nSeasons","text":"Number seasons.","code":""},{"path":"/reference/nSeasons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of seasons — nSeasons","text":"","code":"nSeasons(object)"},{"path":"/reference/nSeasons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of seasons — nSeasons","text":"object object notion number seasons makes sense.","code":""},{"path":"/reference/nSeasons.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of seasons — nSeasons","text":"generic function.","code":""},{"path":"/reference/nSeasons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of seasons — nSeasons","text":"integer number","code":""},{"path":"/reference/nSeasons.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of seasons — nSeasons","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/nSeasons.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Number of seasons — nSeasons","text":"signature(object = \"SarimaFilter\")  signature(object = \"VirtualArmaFilter\")","code":""},{"path":"/reference/nUnitRoots.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of unit roots in a model — nUnitRoots","title":"Number of unit roots in a model — nUnitRoots","text":"Gives number roots modulus one model.","code":""},{"path":"/reference/nUnitRoots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of unit roots in a model — nUnitRoots","text":"","code":"nUnitRoots(object)"},{"path":"/reference/nUnitRoots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of unit roots in a model — nUnitRoots","text":"object object.","code":""},{"path":"/reference/nUnitRoots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of unit roots in a model — nUnitRoots","text":"nUnitRoots() gives number roots modulus one   model. number zero stationary models, see also   isStationaryModel().","code":""},{"path":"/reference/nUnitRoots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of unit roots in a model — nUnitRoots","text":"non-negative integer number","code":""},{"path":"/reference/nUnitRoots.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of unit roots in a model — nUnitRoots","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/nUnitRoots.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Number of unit roots in a model — nUnitRoots","text":"signature(object = \"SarimaSpec\")  signature(object = \"VirtualStationaryModel\")","code":""},{"path":"/reference/nvarOfAcfKP.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Compute variances autocorrelations ARCH-type hypothesis.","code":""},{"path":"/reference/nvarOfAcfKP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"","code":"nvarOfAcfKP(x, maxlag, center = FALSE, acfscale = c(\"one\", \"mom\"))"},{"path":"/reference/nvarOfAcfKP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"x time series. maxlag positive integer, maximal lag. center logical flag, FALSE, default, center time series     squaring, see Details. acfscale character string, specifying factor use     autocovariances. \"one\" stands \\(1/n\\), \"mom\"     \\(1/(n-k)\\), \\(n\\) length x \\(k\\)     lag.","code":""},{"path":"/reference/nvarOfAcfKP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"nvarOfAcfKP computes estimates \\(n\\) times variances   sample autocorrelations white noise time series. implements   result (Kokoszka Politis 2011)    holds weak assumptions. particular, can used test   true autocorrelations time series equal zero GARCH   modelling.","code":""},{"path":"/reference/nvarOfAcfKP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"numeric vector","code":""},{"path":"/reference/nvarOfAcfKP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Kokoszka PS, Politis DN (2011). “Nonlinearity ARCH stochastic volatility models Bartlett's formula.” Probability Mathematical Statistics, 31(1), 47--59.","code":""},{"path":"/reference/nvarOfAcfKP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/nvarOfAcfKP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"","code":"## see examples for whiteNoisTest()"},{"path":"/reference/nvcovOfAcf.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariances of sample autocorrelations — nvcovOfAcf","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Compute covariances autocorrelations.","code":""},{"path":"/reference/nvcovOfAcf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"","code":"nvcovOfAcf(model, maxlag)  nvcovOfAcfBD(acf, ma, maxlag)  acfOfSquaredArmaModel(model, maxlag)"},{"path":"/reference/nvcovOfAcf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"model model, see Details. maxlag positive integer number, maximal lag. acf autocorrelations. ma positive integer number, order MA(q) model. default     maximal lag available acf.","code":""},{"path":"/reference/nvcovOfAcf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"nvcovOfAcf computes unscaled asymptotic autocovariances   sample autocorrelations ARMA models, classical   assumptions Bartlett's formulas valid.  works directly   parameters model uses Boshnakov (1996).  Argument   model can specification ARMA models   autocorrelations() work, e.g. list components \"ar\",   \"ma\", \"sigma2\". nvcovOfAcfBD computes quantities uses formula   given Brockwell \\& Davis (1991) (eq. (7.2.6.), p. 222),   based autocorrelations model. Argument   acf contains autocorrelations. nvcovOfAcfBD, argument ma asks treat provided   acf MA(ma). values lags   ma used rest set zero, since   autocorrelations MA(ma) models zero lags greater   ma.   force use autocorrelations provided acf, set   ma maximal lag available acf omit   ma, since default. acfOfSquaredArmaModel(model, maxlag) convenience function   computes autocovariances \"squared\" model, see   Boshnakov (1996).","code":""},{"path":"/reference/nvcovOfAcf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"(maxlag,maxlag)-matrix","code":""},{"path":"/reference/nvcovOfAcf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Boshnakov GN (1996). “Bartlett's formulae---closed forms recurrent equations.” Ann. Inst. Statist. Math., 48(1), 49--59. ISSN 0020-3157, doi: 10.1007/BF00049288 . Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag..","code":""},{"path":"/reference/nvcovOfAcf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/nvcovOfAcf.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"name nvcovOfAcf stands “n times   variance-covariance matrix”, needs divided n   get asymptotic variances covariances.","code":""},{"path":[]},{"path":"/reference/nvcovOfAcf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"","code":"## MA(2) ma2 <- list(ma = c(0.8, 0.1), sigma2 = 1) nv <- nvcovOfAcf(ma2, maxlag = 4) d <- diag(nvcovOfAcf(ma2, maxlag = 7)) cbind(ma2 = 1.96 * sqrt(d) / sqrt(200), iid = 1.96/sqrt(200)) #>             ma2       iid #> [1,] 0.09452061 0.1385929 #> [2,] 0.16935276 0.1385929 #> [3,] 0.17400093 0.1385929 #> [4,] 0.17400093 0.1385929 #> [5,] 0.17400093 0.1385929 #> [6,] 0.17400093 0.1385929 #> [7,] 0.17400093 0.1385929  acr <- autocorrelations(list(ma = c(0.8, 0.1)), maxlag = 7) nvBD <- nvcovOfAcfBD(acr, 2, maxlag = 4) all.equal(nv, nvBD) # TRUE #> [1] TRUE"},{"path":"/reference/partialAutocorrelations-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"Methods function partialAutocorrelations.","code":""},{"path":"/reference/partialAutocorrelations-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"signature(x = \"\", maxlag = \"\", lag_0 = \"\")  signature(x = \"mts\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"ts\", maxlag = \"\", lag_0 = \"missing\")","code":""},{"path":"/reference/partialAutocorrelations-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/periodogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"Obtain important period lags time series according      periodogram.","code":""},{"path":"/reference/periodogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"","code":"periodogram(x, ..., no.results = 20)"},{"path":"/reference/periodogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"x vector containing time series values ... Arguments passed spectrum .results number results printed end. Defaults  20 important frequencies.","code":""},{"path":"/reference/periodogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"data.frame containing following columns: rank numeric vector containing ranked importance          frequency. spectrum estimates spectral density frequencies          corresponding freq. frequency vector spectral density estimated. period vector corresponding periods.","code":""},{"path":"/reference/periodogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"Using spectral function, obtain spectral density estimates      number frequencies rather plotting, obtain rank      period values. Return given number results based level     interest user.","code":""},{"path":"/reference/plot-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot methods in package sarima — plot-methods","title":"Plot methods in package sarima — plot-methods","text":"Plot methods package sarima.","code":""},{"path":"/reference/plot-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Plot methods in package sarima — plot-methods","text":"signature(x = \"SampleAutocorrelations\", y = \"matrix\")  signature(x = \"SampleAutocorrelations\", y = \"missing\")  signature(x = \"SamplePartialAutocorrelations\", y = \"missing\")","code":""},{"path":"/reference/plot-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot methods in package sarima — plot-methods","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/plot-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot methods in package sarima — plot-methods","text":"","code":"n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.acf #> An object of class \"SampleAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000  0.0342669778 -0.0136863067 -0.0236465147 -0.0411935649  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.0148589585  0.0119116585  0.0445833979 -0.0008057006 -0.0132004037  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -0.0134705677 -0.0215152546  0.0162575383  0.0209274390 -0.0091167459  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -0.0172116919 -0.0013907759 -0.0028714454 -0.0019267426 -0.0057307701  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #>  0.0172722918  0.0109612629 -0.0192566468 -0.0135505569 -0.0126619156  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #>  0.0006111355  0.0107299404 -0.0239456914  0.0152332158 -0.0235994321  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  0.0117045708 -0.0014491127 -0.0475291900  0.0133054018  0.0080785767  #>        Lag_35        Lag_36  #> -0.0049277560  0.0174738475  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x x.pacf <- partialAutocorrelations(x) x.pacf #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000  0.0342669778 -0.0148780026 -0.0226923877 -0.0398705574  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.0127942603  0.0112187259  0.0417618962 -0.0055948379 -0.0124889833  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -0.0102304913 -0.0175806038  0.0176292509  0.0169213714 -0.0138498968  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -0.0167438764  0.0022584893 -0.0005296228 -0.0016900666 -0.0095413749  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #>  0.0153619978  0.0109577489 -0.0183488725 -0.0114520581 -0.0109609473  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #>  0.0004997784  0.0085594700 -0.0274096931  0.0156842181 -0.0237340184  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  0.0148481882 -0.0023606999 -0.0489122356  0.0129564908  0.0078771611  #>        Lag_35        Lag_36  #> -0.0061972624  0.0171995859  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x  plot(x.acf)  plot(x.acf, data = x)   plot(x.pacf)  plot(x.pacf, data = x)   plot(x.acf, data = x, main = \"Autocorrelation test\")  plot(x.pacf, data = x, main = \"Partial autocorrelation test\")   plot(x.acf, ylim = c(NA,1))  plot(x.acf, ylim.fac = 1.5)  plot(x.acf, data = x, ylim.fac = 1.5)  plot(x.acf, data = x, ylim = c(NA, 1))"},{"path":"/reference/prepareSimSarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare SARIMA simulations — prepareSimSarima","title":"Prepare SARIMA simulations — prepareSimSarima","text":"Prepare SARIMA simulations.","code":""},{"path":"/reference/prepareSimSarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare SARIMA simulations — prepareSimSarima","text":"","code":"prepareSimSarima(model, x = NULL, eps = NULL, n, n.start = NA,                  xintercept = NULL, rand.gen = rnorm)  # S3 method for simSarimaFun print(x, ...)"},{"path":"/reference/prepareSimSarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare SARIMA simulations — prepareSimSarima","text":"model object suitable class list, see Details. x initial/values time series, list, numeric     vector time series, see Details.  eps initial/values innovations, list numeric     vector, see Details.  n number observations generate, missing attempt made     infer x eps.  n.start number burn-observations. xintercept non-constant intercept may represent trend covariate     effects.  rand.gen random number generator, defaults N(0,1). ... ignored.","code":""},{"path":"/reference/prepareSimSarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare SARIMA simulations — prepareSimSarima","text":"prepareSimSarima preparatory work simulation   Sarima model, given specifications returns function,   can called many times needed. variance innovations specified model   simulated innovations multiplied corresponding standard   deviation. , expected random number generator   simulates standardised distribution. Argument model can class representing models   SARIMA family, \"SarimaModel\", list components   suitable passed =new()= models. canonical form argument x u list components   \"\", \"init\" \"main\". components missing   NULL, filled suitably.  components ignored.   x list, put component \"main\". Conceptually,   three components concatenated given order,   simulated values put \"main\" (\"\" \"init\"   changed), \"\" part dropped rest returned.   effect, \"\" \"init\" can viewed initial values \"init\"   considered part generated series. format eps x. lengths   missing components x inferred corresponding   components eps, vice versa. print.simSarimaFun print method objects generated   prepareSimSarima.","code":""},{"path":"/reference/prepareSimSarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare SARIMA simulations — prepareSimSarima","text":"prepareSimSarima, function simulate time series, see   Details.  typically called multiple times without arguments.   arguments defaults set prepareSimSarima. n length simulated time series, rand.gen random number generator, ... arguments random number generator, passed     arima.sim.","code":""},{"path":"/reference/prepareSimSarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prepare SARIMA simulations — prepareSimSarima","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"/reference/prepareSimSarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare SARIMA simulations — prepareSimSarima","text":"","code":"mo1 <- list(ar = 0.9, iorder = 1, siorder = 1, nseasons = 4, sigma2 = 2) fs1 <- prepareSimSarima(mo1, x = list(before = rep(0,6)),  n = 100) tmp1 <- fs1() tmp1 #>   [1]    0.7302127   -1.3343869   -3.7918371   -4.8117222   -6.8498077 #>   [6]  -10.8983547  -17.1143197  -24.0533929  -31.6406556  -41.7780076 #>  [11]  -50.9903013  -59.4517031  -68.6092717  -80.4090552  -90.7991670 #>  [16]  -96.8608573 -103.0652494 -113.0873320 -120.5459464 -123.3331659 #>  [21] -128.5633016 -138.4292443 -145.6113285 -148.7396887 -152.2818285 #>  [26] -158.4809419 -162.0014488 -161.1331417 -161.3327201 -161.8282214 #>  [31] -163.3623391 -159.9951228 -155.7200742 -149.7731726 -145.9609656 #>  [36] -138.2625802 -130.5104451 -120.1167089 -112.1310967  -99.2709037 #>  [41]  -87.3680834  -71.6222946  -59.6686372  -43.6389092  -28.6913686 #>  [46]   -8.2390654    5.5939546   21.6736266   36.0539426   57.5184942 #>  [51]   74.4652351   93.0569600  110.2612144  134.5873725  155.9932333 #>  [56]  177.9918477  197.5626074  224.9044005  248.2383804  270.5301637 #>  [61]  291.6248021  321.0433052  345.5517533  366.5578971  389.7047109 #>  [66]  420.0992540  447.7398523  471.0520005  498.1368089  531.5182242 #>  [71]  563.6533936  589.8505498  619.0540868  654.7411977  691.6272802 #>  [76]  723.7412894  760.4696567  803.2384694  846.4771440  883.5732187 #>  [81]  925.9222616  975.1681445 1024.3523349 1066.5514241 1113.0735001 #>  [86] 1168.2706110 1222.2509916 1269.3750617 1321.6952361 1382.4477230 #>  [91] 1440.3074850 1490.0761368 1543.1539545 1606.7717038 1666.6027871 #>  [96] 1716.0572884 1768.2248613 1832.1982320 1892.2115369 1942.7949175 plot(ts(tmp1))   fs2 <- prepareSimSarima(mo1, x = list(before = rep(1,6)),  n = 100) tmp2 <- fs2() plot(ts(tmp2))   mo3 <- mo1 mo3[[\"ar\"]] <- 0.5 fs3 <- prepareSimSarima(mo3, x = list(before = rep(0,6)),  n = 100) tmp3 <- fs3() plot(ts(tmp3))"},{"path":"/reference/rgarch1p1.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate GARCH(1,1) models — rgarch1p1","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"Simulate GARCH(1,1) models. function internal purposes   generate data examples testing.","code":""},{"path":"/reference/rgarch1p1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"","code":"rgarch1p1(n, alpha, beta, omega, n.skip = 100)"},{"path":"/reference/rgarch1p1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"n length generated time series. alpha alpha parameters volatility equation. beta beta parameters volatility equation. omega constant term volatility equation. n.skip number additional observation generate     beginning time series.","code":""},{"path":"/reference/rgarch1p1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/rgarch1p1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"","code":"x <- rgarch1p1(100, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) ## autocorrelations(x) ## partialAutocorrelations(x)"},{"path":"/reference/sarima-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Functions, classes methods time series modelling ARIMA     related models. aim package provide consistent     interface user. example, single function autocorrelations()     computes various kinds theoretical sample autocorrelations.     work progress, see documentation vignettes current     functionality.  Function sarima() fits extended multiplicative seasonal     ARIMA models trends, exogenous variables arbitrary roots     unit circle, can fixed estimated.","code":""},{"path":"/reference/sarima-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"large number packages time series modelling. provide huge number functions, often similar overlapping functionality different argument conventions. One aims package sarima provide consistent interface frequently used functionality. package sarima consistent naming scheme used much possible. Names functions start lowercase letter consist whole words, acronyms commonly used abbreviations. multiword names, second subsequent words start capital letters (camelCase).  first letter acronyms capitalised, e.g. Arma stands ARMA.  Formal (S4) classes follow rules first letter first word capitalised, well. example, functions compute autocorrelations, autocovariances, partial autocorrelations called autocorrelations, autocovariances, partialAutocorrelations, respectively. Moreover, recognise argument(s) exactly needed. given times series, compute sample autocorrelations, etc; given model specifications, compute corresponding theoretical properties. work progress, see also vignette(s).","code":""},{"path":"/reference/sarima-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Georgi N. Boshnakov [aut, cre],   Jamie Halliday [aut] Maintainer: Georgi N. Boshnakov <georgi.boshnakov@manchester.ac.uk>","code":""},{"path":"/reference/sarima-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Boshnakov GN (1996). “Bartlett's formulae---closed forms recurrent equations.” Ann. Inst. Statist. Math., 48(1), 49--59. ISSN 0020-3157, doi: 10.1007/BF00049288 . Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag.. Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press. McLeod AI, Yu H, Krougly Z (2007). “Algorithms Linear Time Series Analysis: R Package.” Journal Statistical Software, 23(5). doi: 10.18637/jss.v023.i05 .","code":""},{"path":[]},{"path":"/reference/sarima-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"","code":"## simulate a white noise ts (model from Francq & Zakoian) n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)  ## acf and pacf ( x.acf <- autocorrelations(x) ) #> An object of class \"SampleAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000 -0.0049483666  0.0339264367 -0.0197010936  0.0308589555  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.0005642901 -0.0321066338  0.0123608060 -0.0185304342  0.0017917181  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -0.0021271128  0.0117684206  0.0061023981  0.0038364348 -0.0316817502  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #>  0.0090884270  0.0116242923  0.0046812790  0.0048936496 -0.0507535272  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #>  0.0009549094  0.0069311262  0.0198841949  0.0005844722  0.0080178162  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #> -0.0229673213  0.0118750123 -0.0040440749 -0.0071535578 -0.0114501811  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  0.0007170668 -0.0143813622  0.0188349949 -0.0091690564  0.0368455863  #>        Lag_35        Lag_36  #> -0.0020932279  0.0100090045  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x ( x.pacf <- partialAutocorrelations(x) ) #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000 -0.0049483666  0.0339027805 -0.0193939071  0.0295805390  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #>  0.0009942459 -0.0345846477  0.0133352056 -0.0171927691 -0.0005173901  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #>  0.0016560121  0.0102338379  0.0062644518  0.0039469169 -0.0330951697  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #>  0.0087414512  0.0133152839  0.0033719700  0.0066762065 -0.0508935466  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #> -0.0023516052  0.0119948560  0.0170339541  0.0035040412  0.0077237189  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #> -0.0259731985  0.0119855322 -0.0035037712 -0.0098581800 -0.0088302897  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  0.0029624072 -0.0148754413  0.0210135406 -0.0130340065  0.0355138737  #>        Lag_35        Lag_36  #>  0.0014542578  0.0077739684  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x  ## portmanteau test for iid, by default gives also ci's for the acf under H0 x.iid <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LiMcLeod\") x.iid #> $test #>         ChiSq DF      pvalue #> [1,] 12.58408  5 0.027604300 #> [2,] 20.26577 10 0.026836854 #> [3,] 40.46979 20 0.004354714 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.iid2 <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LjungBox\") x.iid2 #> $test #>         ChiSq DF      pvalue #> [1,] 12.59342  5 0.027501836 #> [2,] 20.28027 10 0.026710503 #> [3,] 40.53102 20 0.004277187 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   ## portmanteau test for garch H0 x.garch <- whiteNoiseTest(x.acf, h0 = \"garch\", nlags = c(5,10,20), x = x) x.garch #> $test #>       h         Q      pval #> [1,]  5  3.727714 0.5892452 #> [2,] 10  6.904500 0.7344290 #> [3,] 20 21.391062 0.3744449 #>  #> $ci #>               int            #>  [1,] -0.05864848 0.05864848 #>  [2,] -0.04966288 0.04966288 #>  [3,] -0.04496038 0.04496038 #>  [4,] -0.04262183 0.04262183 #>  [5,] -0.04192811 0.04192811 #>  [6,] -0.03923999 0.03923999 #>  [7,] -0.04020476 0.04020476 #>  [8,] -0.03613118 0.03613118 #>  [9,] -0.03704195 0.03704195 #> [10,] -0.03640581 0.03640581 #> [11,] -0.03565286 0.03565286 #> [12,] -0.03296581 0.03296581 #> [13,] -0.03350837 0.03350837 #> [14,] -0.03523791 0.03523791 #> [15,] -0.03517231 0.03517231 #> [16,] -0.03727927 0.03727927 #> [17,] -0.03666740 0.03666740 #> [18,] -0.03542578 0.03542578 #> [19,] -0.03493298 0.03493298 #> [20,] -0.03379997 0.03379997 #>   ## plot methods give the CI's under H0 plot(x.acf)   ## if the data are given, the CI's under garch H0 are also given. plot(x.acf, data = x)   ## Tests based on partial autocorrelations are also available: plot(x.pacf)  plot(x.pacf, data = x)   ## Models ## AR ( ar2a1 <- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) ) #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) autocorrelations(ar2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #>  1.0000000 -0.1764706 -0.6470588  0.3176471  0.3576471 -0.3296471 -0.1514588  partialAutocorrelations(ar2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00 -1.764706e-01 -7.000000e-01 -1.123440e-16  0.000000e+00  #>         Lag_5         Lag_6  #>  0.000000e+00 -5.617200e-17  autocovariances(ar2a1, maxlag = 6) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  2.0238095 -0.3571429 -1.3095238  0.6428571  0.7238095 -0.6671429 -0.3065238  partialVariances(ar2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 2.023810 1.960784 1.000000 1.000000 1.000000 1.000000 1.000000   ## see examples for ArmaModel()"},{"path":"/reference/sarima.f.html","id":null,"dir":"Reference","previous_headings":"","what":"Function used internally to compute forecasts — sarima.f","title":"Function used internally to compute forecasts — sarima.f","text":"Function used internally compute forecasts.","code":""},{"path":"/reference/sarima.f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function used internally to compute forecasts — sarima.f","text":"","code":"sarima.f(past = numeric(length(ar)), n = max(2 * length(past), 12),          ar = numeric(0), ma = numeric(0), intercept = 0,          pasteps = numeric(length(ma)), trend = numeric(n))"},{"path":"/reference/sarima.f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function used internally to compute forecasts — sarima.f","text":"past past values time series. n number forecasts generate. ar ar coefficients. ma ma coefficients. intercept intercept. pasteps past values innovations. trend trend.","code":""},{"path":"/reference/sarima.f.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function used internally to compute forecasts — sarima.f","text":"Computes predictions using specified parameters past values.   ar ma coefficients fully expanded   polynomials SARIMA mmodel.","code":""},{"path":"/reference/sarima.f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function used internally to compute forecasts — sarima.f","text":"numeric vector","code":""},{"path":"/reference/sarima.f.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function used internally to compute forecasts — sarima.f","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit extended SARIMA models — sarima","title":"Fit extended SARIMA models — sarima","text":"Fit extended SARIMA models, can include lagged exogeneous   variables, general unit root non-stationary factors, multiple   periodicities, multiplicative terms SARIMA   specification. models specified flexible formula syntax   contain special cases many models specialised names,   ARMAX reg-ARIMA.","code":""},{"path":"/reference/sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit extended SARIMA models — sarima","text":"","code":"sarima(model, data = NULL, ss.method = \"sarima\", use.symmetry = FALSE,         SSinit = \"Rossignol2011\")"},{"path":"/reference/sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit extended SARIMA models — sarima","text":"model model formula specifying model. data list data frame, usually can omitted. ss.method state space engine use, defaults     \"sarima\". (Note: argument     probably renamed.) use.symmetry logical argument indicating whether      symmetry used estimate unit polynomial. SSinit method use computation stationary part     initial covariance matrix, one \"Rossignol2011\", \"gnb\",     \"Gardner1980\".","code":""},{"path":"/reference/sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit extended SARIMA models — sarima","text":"sarima fits extended SARIMA models, can include   exogeneous variables, general unit root non-stationary factors   multiplicative terms SARIMA specification. Let \\(\\{Y_t\\}\\) time series \\(f(t)\\) \\(g(t)\\)   functions time /(possibly lagged) exogeneous variables. extended pure SARIMA model \\(Y_t\\) can written   help backward shift operator   $$U(B)\\Phi(B)Y_t = \\Theta(B)\\varepsilon_t,$$   \\(\\{\\varepsilon_t\\}\\) white noise,    \\(U(z)\\), \\(\\Phi(z)\\), \\(\\Theta(z)\\) polynomials,   roots \\(U(z)\\) unit circle,   roots \\(\\Phi(z)\\) \\(\\Theta(z)\\) outside unit   circle. unit roots missing, ie \\(U(z)\\equiv 1\\),   model stationary mean zero. reg-SARIMA X-SARIMA model can defined regression   SARIMA residuals:    $$Y_t = f(t) + Y^c_t$$   $$U(B)\\Phi(B)Y^c_t = \\Theta(B)\\varepsilon_t,$$   \\(Y^c_t = Y_t - f(t)\\) centred \\(Y_t\\).   can written equivalently single equation:   $$U(B)\\Phi(B)(Y_t - f(t)) = \\Theta(B)\\varepsilon_t.$$   regression function \\(f(t)\\) can depend   time /(possibly lagged) exogeneous variables.  call   centering function. \\(Y^c_t\\) stationary mean zero,   f(t) mean \\(Y_t\\). f(t) constant, say   mu, \\(Y_t\\) stationary mean mu. Note   two-equation form shows case mu   intercept first equation, perfectly reasonable   refer also intercept avoid confusion reserve   term intercept  g(t) . SARIMA part stationary, \\(EY_t = f(t)\\),   \\(f(t)\\) can interpreted trend. case   specification often referred mean corrected form   model. alternative way specify regression part add   regression function, say \\(\\{g(t)\\}\\), right-hand side SARIMA   equation:   $$U(B)\\Phi(B)Y_t = g(t) + \\Theta(B)\\varepsilon_t.$$   stationary case classical ARMAX specification.    can written two-stage form various ways, eg   $$U(B)\\Phi(B)Y_t = (1 - \\Theta(B))\\varepsilon_t + u_t,$$   $$u_t = g(t) + \\varepsilon_t .$$   , sense, g(t) trend associated residuals   SARIMA modelling. refer form intercept form   model (opposed mean-corrected form discussed previously). general, exogeneous variables mean-corrected   model equivalent intercept model, gives   justification terminology, well. exogeneous   variables equivalence may achievable expense   introducing lags model, whish desirable general. examples equivalence. Let Y stationary SARIMA   process (\\(U(z)=1\\)) mean \\(\\mu\\).   mean-corrected form SARIMA model    $$\\Phi(B)(Y_t - \\mu) = \\Theta(B)\\varepsilon_t,$$   intercept form   $$\\Phi(B)Y_t = c + \\Theta(B)\\varepsilon_t,$$   \\(c = \\Phi(B)\\mu\\). , case mean-corrected model   X-SARIMA model \\(f(t) = \\mu\\) equivalent   intercept model \\(g(t) = \\Phi(B)\\mu\\). another example, \\(f(t) = bt\\), mean-corrected model   \\((1-B)(Y_t - bt) = \\varepsilon_t\\). Expanding left-hand side   obtain intercept form  \\((1-B)Y_t = b + \\varepsilon_t\\),   demonstrates \\(Y_t\\) random walk drift \\(g(t) = b\\). Model specification Argument model specifies model syntax similar   model fitting functions R.  formula can given   components discussed y ~ f | SARIMA | g,   f, SARIMA g model formulas giving   specifications centering function f, SARIMA   specification, intercept function g.  normal use   one f g different zero. f   always given (use 0 specify identical   zero), g can omitted altogether.  Sometimes refer   terms specified f g xreg   regx, respectively. Model formulas trends exogeneous regressions formulas centering intercept (ie f   g) use syntax linear models additional   functions trigonometric trends, polynomial trends lagged   variables. available specialised terms:  .p(d) Orthogonal polynomials 1:length(y) degree d       (starting degree 1, constant). t Stands 1:length(y). Note powers need       protected (), e.g. y ~ 1 + .t + (.t^2). .cs(s, k) cos/sin pair k-th harmonic 2pi/s. Use vector k       specify several harmonics.  .B(x, lags) Include lagged terms x, \\(B^{lags}(x[t]) = x[t - lags]\\).       lags can vector.       x matrix, specified lags taken       column.  Model formulas SARIMA models flexible syntax provided specification SARIMA part   model.  formed using number primitives   stationary unit root components,    non-seasonal seasonal variants. Arbitrary number multiplicative   factors multiple seasonalities can specified. SARIMA part model can contain following   terms. can repeated needed. first argument   seasonal operators number seasons.  ar(p) autoregression term order p ma(q) moving average term order q sar(s,p) seasonal autoregression term (s seasons, order p) sma(s,q) seasonal moving average term (s seasons, order q) (d) \\((1-B)^d\\) s(seas) summation operator,       \\((1 + B + \\cdots + B^{seas -1})\\) u(x) quadratic unit root term, corresponding complex pair       unit circle. \\(x\\) real, specifies argument one       roots fraction \\(2\\pi\\). \\(z\\)       complex, root . real roots modulus one (1 \\(-1\\)) specified       using (1) s(2), correspond \\(1-B\\)       \\(1+B\\), respectively. su(s, h) quadratic unit root terms corresponding seasonal       differencing factors. h specifies desired harmonic       one 1,2, ..., [s/2]. Several harmonics can       specified setting h vector. ss(s, p) seasonal summation operator,       \\((1 + B^s + \\cdots + B^{(s-1)p})\\)  Terms parameters can contain additional arguments specifying   initial values, fixed parameters, transforms. ar,   ma, sar, sma, values coefficients can   specified unnamed argument parameters given   descriptions . estimation values taken   initial values optimisation.  default, coefficients   taken non-fixed. Argument fixed can used fix .    logical vector length one length   coefficients. fixed length one TRUE,   coefficients fixed. FALSE, non-fixed. Otherwise,   TRUE/FALSE values fixed determine fixedness   corresponding coefficients. fixed can also vector positive integer numbers   specifying indices fixed coefficients, rest non-fixed. Sometimes may easier declare (e.g. ) coefficients   fixed `unfix' selectively. Argument nonfixed can   used mark coefficients non-fixed   declared fixed. syntax fixed. TODO: streamline \"atanh.tr\" TODO: describe SSinit","code":""},{"path":"/reference/sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit extended SARIMA models — sarima","text":"object S3 class Sarima   (Note: format object still development   may change; use accessor functions, coef(), provided.)","code":""},{"path":"/reference/sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit extended SARIMA models — sarima","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/sarima.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fit extended SARIMA models — sarima","text":"Currently implementation intercept form (ie third     part model formula) incomplete.","code":""},{"path":[]},{"path":"/reference/sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit extended SARIMA models — sarima","text":"","code":"## AirPassengers example ## fit the classic airline model using arima() ap.arima <- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1))  ## same model using two equivalent ways to specify it ap.baseA <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1),                     ss.method = \"base\") ap.baseB <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(12),                     ss.method = \"base\")  ap.baseA #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(1) + si(12, 1), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)(1 - B^12) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61 summary(ap.baseA) #>  #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12,  #>     1, c(-0.1)) + i(1) + si(12, 1), ss.method = \"base\") #>  #> Model:  Y_t - xreg_t is SarimaX #>   xreg:    log(AirPassengers) ~ 0  #>   sarima:  ~ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) + i(1) + si(12, 1)  #>   regx:    0  #>  #> Unit root terms: #>      (1 - B)(1 - B^12) #>  #> Coefficients: #>      Estimate Std. Error Z value  Pr(>|z|)     #> ma1  -0.40153    0.10716 -3.7472 0.0001788 *** #> sma1 -0.56154    0.10680 -5.2581 1.456e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> estimated sigma^2 = 0.00135,  log-likelihood = 169.3,  aic = -332.61 ap.baseB #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(12), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B + ... + B^11) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61 summary(ap.baseB) #>  #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12,  #>     1, c(-0.1)) + i(2) + s(12), ss.method = \"base\") #>  #> Model:  Y_t - xreg_t is SarimaX #>   xreg:    log(AirPassengers) ~ 0  #>   sarima:  ~ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) + i(2) + s(12)  #>   regx:    0  #>  #> Unit root terms: #>      (1 - B)^2(1 + B + ... + B^11) #>  #> Coefficients: #>      Estimate Std. Error Z value  Pr(>|z|)     #> ma1  -0.40153    0.10716 -3.7472 0.0001788 *** #> sma1 -0.56154    0.10680 -5.2581 1.456e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> estimated sigma^2 = 0.00135,  log-likelihood = 169.3,  aic = -332.61  ## as above, but drop 1-B from the model: ap2.arima <- arima(log(AirPassengers), order = c(0,0,1), seasonal = c(0,1,1)) ap2.baseA <- sarima(log(AirPassengers) ~                      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) +     si(12,1),                      ss.method = \"base\") ap2.baseB <- sarima(log(AirPassengers) ~                      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + s(12),                      ss.method = \"base\")  ## for illustration, here the non-stationary part is  ##     (1-B)^2(1+B+...+B^5) = (1-B)(1-B^6) ##     (  compare to (1-B)(1-B^{12}) = (1-B)(1-B^6)(1+B^6) )  ap3.base <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(6),                     ss.method = \"base\")  ## further unit roots, equivalent specifications for the airline model tmp.su <- sarima(log(AirPassengers) ~                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + su(12,1:5),                   ss.method = \"base\") tmp.su$interna$delta_poly #> List of polynomials: #> [[1]] #> 1 - x  #>  #> [[2]] #> 1 + x  #>  #> [[3]] #> 1 - 1.732051*x + x^2  #>  #> [[4]] #> 1 - x + x^2  #>  #> [[5]] #> 1 + x^2  #>  #> [[6]] #> 1 + x + x^2  #>  #> [[7]] #> 1 + 1.732051*x + x^2  #>  prod(tmp.su$interna$delta_poly) #> 1 + 8.881784e-16*x^3 - 1.332268e-15*x^4 + 1.776357e-15*x^5 - 1.776357e-15*x^7 +   #> 1.332268e-15*x^8 - 8.881784e-16*x^9 - x^12  zapsmall(coef(prod(tmp.su$interna$delta_poly))) #>  [1]  1  0  0  0  0  0  0  0  0  0  0  0 -1 tmp.su #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(2) + su(12, 1:5), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B)(1 - 1.73205080756888*B + B^2)(1 - B + B^2)(1 + B^2)(1 + B + B^2)(1 + 1.73205080756888*B + B^2) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61  tmp.u <- sarima(log(AirPassengers) ~                  0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + u((1:5)/12),                  ss.method = \"base\") tmp.u #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(2) + u((1:5)/12), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B)(1 - 1.73205080756888*B + B^2)(1 - B + B^2)(1 + B^2)(1 + B + B^2)(1 + 1.73205080756888*B + B^2) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61"},{"path":"/reference/sigmaSq.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the innovation variance of models — sigmaSq","title":"Get the innovation variance of models — sigmaSq","text":"Get innovation variance models.","code":""},{"path":"/reference/sigmaSq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the innovation variance of models — sigmaSq","text":"","code":"sigmaSq(object)"},{"path":"/reference/sigmaSq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the innovation variance of models — sigmaSq","text":"object object suitable class.","code":""},{"path":"/reference/sigmaSq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the innovation variance of models — sigmaSq","text":"sigmaSq() gives innovation variance objects classes   makes sense, ARMA models. value depends class object, e.g. ARMA models   scalar univariate case matrix multivariate one.","code":""},{"path":"/reference/sigmaSq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the innovation variance of models — sigmaSq","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/sigmaSq.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get the innovation variance of models — sigmaSq","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"/reference/sim_sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate trajectories of seasonal arima models — sim_sarima","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"Simulate trajectories seasonal arima models.","code":""},{"path":"/reference/sim_sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"","code":"sim_sarima(model, n = NA, rand.gen = rnorm, n.start = NA, x, eps,            xcenter = NULL, xintercept = NULL, ...)"},{"path":"/reference/sim_sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"model specification model, list, see `Details'. rand.gen random number generator innovations. n length time series. n.start number burn-observations. x initial/values time series, list, numeric     vector time series, see Details. eps initial/values innovations, list numeric     vector, see Details. xintercept non-constant intercept may represent trend covariate     effects. xcenter currently ignored. ... additional arguments arima.sim     rand.gen, see `Details'.","code":""},{"path":"/reference/sim_sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"model specified argument \"model\" list   elements suitable passed new(\"SarimaModel\", ...), see   description class \"SarimaModel\".   possible components:  nseasons number seasons year (whatever larger       time unit) iorder order differencing, specifies factor       \\((1-B)^{d1}\\) model. siorder order seasonal differencing, specifies factor       \\((1-B^{period})^{ds}\\)  model. ar ar parameters (non-seasonal) ma ma parameters (non-seasonal) sar seasonal ar parameters sma seasonal ma parameters Additional arguments rand.gen  may specified   via \"...\" argument.   particular, length generated series specified   argument n. Arguments rand.gen can also passed   via \"...\" argument. sim_sarima calls internally arima.sim simulate   ARMA part model. undifferences result obtain   end result. function returns simulated time series requested   model. Information model printed screen   info = \"print\". suppress , set info   value. multple simulations (almost ) setup,   better execute prepareSimSarima call   function returned many times needed.","code":""},{"path":"/reference/sim_sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"object class \"ts\"","code":""},{"path":"/reference/sim_sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/sim_sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"","code":"require(\"PolynomF\") # guaranteed to be available since package \"sarima\" imports it. #> Loading required package: PolynomF  x <- sim_sarima(n=144, model = list(ma=0.8))               # MA(1) x <- sim_sarima(n=144, model = list(ar=0.8))               # AR(1)  x <- sim_sarima(n=144, model = list(ar=c(rep(0,11),0.8)))  # SAR(1), 12  seasons x <- sim_sarima(n=144, model = list(ma=c(rep(0,11),0.8)))  # SMA(1)                                    # more enlightened SAR(1) and SMA(1) x <- sim_sarima(n=144,model=list(sar=0.8, nseasons=12, sigma2 = 1))  # SAR(1), 12 seasons x <- sim_sarima(n=144,model=list(sma=0.8, nseasons=12, sigma2 = 1))  # SMA(1)  x <- sim_sarima(n=144, model = list(iorder=1, sigma2 = 1)) # (1-B)X_t = e_t (random walk) acf(x)  acf(diff(x))   x <- sim_sarima(n=144, model = list(iorder=2, sigma2 = 1))  # (1-B)^2 X_t = e_t x <- sim_sarima(n=144, model = list(siorder=1,                                     nseasons=12, sigma2 = 1)) # (1-B)^{12} X_t = e_t  x <- sim_sarima(n=144, model = list(iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1)) x <- sim_sarima(n=144, model = list(ma=0.4, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1)) x <- sim_sarima(n=144, model = list(ma=0.4, sma=0.7, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1))  x <- sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4,                                     sar=0.3, sma=0.7, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1))  x <- sim_sarima(n=144, model = list(iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1),                 x = list(init=AirPassengers[1:13]))  p <- polynom(c(1,-1.2,0.8)) solve(p) #> [1] 0.75-0.8291562i 0.75+0.8291562i abs(solve(p)) #> [1] 1.118034 1.118034  sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4, sar=0.3, sma=0.7,                                iorder=1, siorder=1, nseasons=12)) #>   [1]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>   [6]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [11]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [16]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [21]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [26]    0.0000000    0.0000000    0.2638615    0.6144678    0.8545069 #>  [31]    1.8747284    4.3449310    8.4264188   13.6988204   18.5156814 #>  [36]   22.1839153   23.3052180   21.0229645   16.8489604   12.8826131 #>  [41]   12.3512021   14.3970092   16.2509523   18.4775548   24.2919061 #>  [46]   36.0840033   49.4308624   61.1225251   65.6601169   60.3017539 #>  [51]   47.2120256   33.4202192   29.2397611   33.9087148   38.8233726 #>  [56]   41.7236513   47.0782998   59.6948808   75.9637454   92.1809367 #>  [61]   98.1663872   88.7293254   66.4642298   43.0804834   33.8711939 #>  [66]   40.7869726   51.0535159   55.8777341   59.5965974   69.8844742 #>  [71]   88.1363690  109.6004026  118.3043495  105.8699816   74.8433255 #>  [76]   41.0124948   23.8598234   30.7567299   47.7312571   58.0374293 #>  [81]   63.5138304   72.1201805   89.1662446  109.6718725  116.6471535 #>  [86]  101.2479177   64.6857086   24.4833224    2.5099760    9.6584509 #>  [91]   31.3941957   45.7925393   52.8274854   60.2243144   72.9207621 #>  [96]   86.3256574   87.9844710   71.5391560   36.2487898   -4.8720429 #> [101]  -30.9603299  -29.4810586  -12.6779068   -0.9219911    6.8594111 #> [106]   17.9291211   34.0956138   47.5111576   46.7601232   29.3859427 #> [111]   -5.5277764  -47.4260537  -75.4782698  -79.7700347  -69.3063877 #> [116]  -61.2833726  -53.3078661  -38.0861167  -14.8817278    5.4433213 #> [121]    7.8739858   -9.2974361  -46.0565940  -89.5227874 -118.1341366 #> [126] -123.4603748 -112.5329068 -103.8012121  -95.5738909  -79.2733035 #> [131]  -53.0581826  -26.6453450  -18.8732794  -34.1376804  -72.5633037 #> [136] -118.6557492 -149.6756284 -155.1582133 -142.8462534 -133.7356851 #> [141] -125.9160826 -109.0997799  -81.2039885  -51.7926951  x <- sim_sarima(n=144, model=list(ma=0.4, iorder=1, siorder=1, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sma=0.4, iorder=1, siorder=1, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sma=0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sar=0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sar=-0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)   x <- sim_sarima(n=144, model=list(ar=c(1.2, -0.8), ma=0.4, sar=0.3, sma=0.7,                                   iorder=1, siorder=1, nseasons=12)) ## use xintercept to include arbitrary trend/covariates sim_sarima(n = 144, model = list(sma = 0.4, ma = 0.4, sar = 0.8, ar = 0.5,      nseasons = 12, sigma2 = 1), xintercept = 1:144) #>   [1]   1.1452976   4.1397533   1.5776055   0.7747324  -0.3218329   1.2549349 #>   [7]   0.9996653  -3.9404548  -1.5211005   1.4464242  -0.2321667  -0.8994202 #>  [13]  -2.0308710  15.1548296  22.1391217  27.3943865  32.1922152  35.5866355 #>  [19]  39.1602695  35.8232997  39.0105514  43.0656081  42.7361271  43.8176021 #>  [25]  45.1525844  61.3765898  67.6342392  73.1544442  81.7466769  86.5029394 #>  [31]  92.3251665  90.8888607  94.5956381  97.8569221  99.2730984 101.6950173 #>  [37] 106.0579111 122.2517447 129.4730030 134.1381434 143.0227887 150.0632752 #>  [43] 158.2768087 159.5245947 163.8908620 167.6963683 170.0212294 174.4399591 #>  [49] 179.4771422 193.2495691 201.2546726 207.2401272 216.0552044 224.4002183 #>  [55] 233.1862369 236.4896989 242.4135095 248.9925652 251.3443450 256.7748112 #>  [61] 261.6044805 276.0664910 283.0533055 290.0874940 299.8310630 309.9906893 #>  [67] 320.0085039 325.1159925 332.4793121 338.8274074 340.9614280 346.2224712 #>  [73] 353.9354389 369.5720191 375.9314390 382.0739379 391.9265877 399.8940926 #>  [79] 411.2922615 419.2136485 428.3932778 435.6548261 437.1402261 443.3313819 #>  [85] 452.8518678 465.9900600 472.3984422 478.8393116 488.5060059 495.6765476 #>  [91] 507.7316321 517.2973507 527.2444108 535.5741981 536.8277856 544.1061416 #>  [97] 554.4605689 567.4271680 573.2853889 578.9321388 588.5919743 598.3993873 #> [103] 612.1062537 621.4699370 630.4681796 637.5436952 640.1673606 647.1955763 #> [109] 656.8926771 669.9538730 678.3087761 685.3028116 694.4454219 706.8838268 #> [115] 719.8716746 727.1523752 736.2441148 743.1605450 746.4974485 753.3222319 #> [121] 763.9477486 776.4774687 785.8824877 795.7661146 804.9543061 817.3227009 #> [127] 828.7413015 835.4806140 845.0992098 851.6219138 857.4635231 866.6820679 #> [133] 877.2080906 890.0055197 900.0444687 909.1337323 916.7650253 928.2563336 #> [139] 938.9712950 945.7508967 952.5860297 959.7053511 968.5480974 978.1390070"},{"path":"/reference/summary.SarimaModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for summary in package sarima — summary.SarimaModel","title":"Methods for summary in package sarima — summary.SarimaModel","text":"Methods summary package sarima.","code":""},{"path":"/reference/summary.SarimaModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for summary in package sarima — summary.SarimaModel","text":"","code":"# S3 method for SarimaModel summary(object, ...) # S3 method for SarimaFilter summary(object, ...) # S3 method for SarimaSpec summary(object, ...)"},{"path":"/reference/summary.SarimaModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for summary in package sarima — summary.SarimaModel","text":"object object corresponding class. ... arguments methods.","code":""},{"path":"/reference/summary.SarimaModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for summary in package sarima — summary.SarimaModel","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/tsdiag.Sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Produce diagnostics fitted seasonal ARIMA models. method   offers several portmanteau tests (including Ljung-Box, Li-McLeod   Box-Pierce), plots autocorrelations partial autocorrelations   residuals, ability control graphs produced (including   interactively), well layout.","code":""},{"path":"/reference/tsdiag.Sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"","code":"# S3 method for Sarima tsdiag(object, gof.lag = NULL, ask = FALSE, ..., plot = 1:3, layout = NULL)"},{"path":"/reference/tsdiag.Sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"object fitted (seasonal) ARIMA model, currently output sarima     stats::arima. gof.lag maximal lag portmanteau tests. ask TRUE present menu available plots, see Details. ... used. plot TRUE available plots; vector positive integers     specifies subset available plots. layout list arguments graphics::layout plots.     default ARIMA method stats::tsdiag.","code":""},{"path":"/reference/tsdiag.Sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Compute graph diagnostics seasonal ARIMA models. objects   class \"Sarima\" (produced sarima) just call   generic, tsdiag. method can called also directly output   base R's arima() tsdiag.Sarima()   sarima::tsdiag.Sarima(). method offers several portmanteau tests (including Ljung-Box,   Li-McLeod Box-Pierce), plots autocorrelations partial   autocorrelations residuals, ability control graphs   produced (including interactively), well layout. plot can TRUE ask plots vector   positive integers specifying plots consider. Currently   following options available: plot TRUE, probably need also ask = TRUE. method always makes correction degrees freedom   portmanteau tests (roughly, subtracting number estimated ARMA   parameters). Note stats::tsdiag . interactive sessions, number requested graphs (  specified argument plot) larger number graphs   specified layout (default 3), function makes first   graph presents menu requested plots. Argument layout can used change layout plot,   example put two graphs per plot, see examples. Currently   list arguments layout, see ?layout.   call layout youself, change graphics   device prematurely. computed results returned (invisibly).","code":""},{"path":"/reference/tsdiag.Sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"list components: residuals residuals LjungBox Ljung box test LiMcLeod LiMcLeod test BoxPierce BoxPierce test components actually computed included, rest   NULL absent.","code":""},{"path":"/reference/tsdiag.Sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Georgi N. boshnakov","code":""},{"path":[]},{"path":"/reference/tsdiag.Sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"","code":"ap.baseA <- sarima(log(AirPassengers) ~      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1),      ss.method = \"base\") tsdiag(ap.baseA)   ## apply the method on objects from arima() ap.arima <- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1)) tsdiag.Sarima(ap.arima)  ## use Li-McLeod test instead of Ljung-Box tsdiag.Sarima(ap.arima, plot = c(1:2,4))  ## call R's tsdiag method, for comparison: tsdiag(ap.arima, plot = c(1:2,4))   ## plot only acf an p-values tsdiag.Sarima(ap.arima, plot = c(2:3), layout = list(matrix(1:2, nrow = 2)))  ## plot only acf an p-values tsdiag.Sarima(ap.arima, plot = c(2:3), layout = list(matrix(1:2, nrow = 2)))   ## plot resid, acf, and p-values, leaving half the space for residuals # tsdiag.Sarima(ap.arima, plot = c(1:3), layout = list(matrix(1:3, nrow = 3), #                                                      heights = c(1,2,2)))"},{"path":"/reference/whiteNoiseTest.html","id":null,"dir":"Reference","previous_headings":"","what":"White noise tests — whiteNoiseTest","title":"White noise tests — whiteNoiseTest","text":"White noise tests.","code":""},{"path":"/reference/whiteNoiseTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"White noise tests — whiteNoiseTest","text":"","code":"whiteNoiseTest(object, h0, ...)"},{"path":"/reference/whiteNoiseTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"White noise tests — whiteNoiseTest","text":"object object, sample autocorrelations partial autocorrelations. h0 null hypothesis, currently \"iid\" \"garch\". ... additional arguments passed methods.","code":""},{"path":"/reference/whiteNoiseTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"White noise tests — whiteNoiseTest","text":"whiteNoiseTest carries tests white noise.  null   hypothesis identified argument h0, based   whiteNoiseTest chooses suitable function call.    functions implementing tests also available called   directly documentation consulted   arguments available. h0 = \"iid\", test statistics rejection regions can   use test underlying time series iid. Argument   method specifies method portmanteau tests: one   \"LiMcLeod\" (default), \"LjungBox\", \"BoxPierce\". h0 = \"garch\", null hypothesis time series   GARCH, see Francq \\& Zakoian (2010).   tests case based non-parametric estimate   asymptotic covariance matrix. Portmonteau statistics p-values computed lags   specified argument nlags. missing, suitable lags   chosen automatically. argument interval TRUE, confidence intervals   individual autocorrelations partial autocorrelations computed.","code":""},{"path":"/reference/whiteNoiseTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"White noise tests — whiteNoiseTest","text":"list component test , ci=TRUE, component ci.","code":""},{"path":"/reference/whiteNoiseTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"White noise tests — whiteNoiseTest","text":"Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press.","code":""},{"path":"/reference/whiteNoiseTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"White noise tests — whiteNoiseTest","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/whiteNoiseTest.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"White noise tests — whiteNoiseTest","text":"methods added future.","code":""},{"path":[]},{"path":"/reference/whiteNoiseTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"White noise tests — whiteNoiseTest","text":"","code":"n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.pacf <- partialAutocorrelations(x)  x.iid <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LiMcLeod\") x.iid #> $test #>         ChiSq DF       pvalue #> [1,] 26.64226  5 6.695955e-05 #> [2,] 36.62510 10 6.569627e-05 #> [3,] 93.70736 20 1.654674e-11 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.iid2 <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LjungBox\") x.iid2 #> $test #>         ChiSq DF       pvalue #> [1,] 26.67047  5 6.611921e-05 #> [2,] 36.66601 10 6.463693e-05 #> [3,] 93.89855 20 1.530964e-11 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.garch <- whiteNoiseTest(x.acf, h0 = \"garch\", nlags = c(5,10,20), x = x) x.garch #> $test #>       h         Q       pval #> [1,]  5  5.433613 0.36528034 #> [2,] 10  7.398133 0.68739961 #> [3,] 20 30.622710 0.06037244 #>  #> $ci #>               int            #>  [1,] -0.06651728 0.06651728 #>  [2,] -0.05862294 0.05862294 #>  [3,] -0.06293622 0.06293622 #>  [4,] -0.06454720 0.06454720 #>  [5,] -0.05879838 0.05879838 #>  [6,] -0.04945801 0.04945801 #>  [7,] -0.05456194 0.05456194 #>  [8,] -0.05427709 0.05427709 #>  [9,] -0.05380155 0.05380155 #> [10,] -0.04949370 0.04949370 #> [11,] -0.04752488 0.04752488 #> [12,] -0.04934762 0.04934762 #> [13,] -0.04628681 0.04628681 #> [14,] -0.04219439 0.04219439 #> [15,] -0.04332994 0.04332994 #> [16,] -0.04320852 0.04320852 #> [17,] -0.03684342 0.03684342 #> [18,] -0.03822076 0.03822076 #> [19,] -0.03738820 0.03738820 #> [20,] -0.03798907 0.03798907 #>"},{"path":"/reference/xarmaFilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies an extended ARMA filter to a time series — xarmaFilter","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"Filter time series extended arma filter.   whiten FALSE (default) function applies   given ARMA filter eps (eps often   white noise).  whiten TRUE function applies   “inverse filter” \\(x\\), effectively computing   residuals.","code":""},{"path":"/reference/xarmaFilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"","code":"xarmaFilter(model, x = NULL, eps = NULL, from = NULL, whiten = FALSE,             xcenter = NULL, xintercept = NULL)"},{"path":"/reference/xarmaFilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"x time series filtered, vector. eps residuals, vector NULL. model model parameters, list components \"ar\",     \"ma\", \"center\" \"intercept\", see Details. index start filtering. whiten TRUE use x input apply inverse filter     produce eps (\"whiten\" x), FALSE use eps     input generate x (\"colour\" eps). xcenter vector means length time series, see Details. xintercept vector intercepts length series, see Details.","code":""},{"path":"/reference/xarmaFilter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"model specified argument model, list   following components: ar autoregression parameters, ma moving average parameters, center center value, intercept intercept. model$center model$intercept scalars usually   one nonzero. can considered part   model specification. contrast, arguments xcenter   xintercept vectors length x. can   represent contributions covariate variables. Usually one   xcenter xintercept used. description uses \\(\\mu_t\\) \\(c_t\\)   contributions model$center plus xcenter   model$intercept plus xintercept, respectively.   time series \\(\\{x_t\\}\\) \\(\\{\\varepsilon_t\\}\\)   represented x eps R code.   Let       $$y_t = x_t - \\mu_t$$   centered series.  centering term \\(\\mu_t\\)   essentially sum center xcenter   necessarilly mean.  equation relating centered series,   \\(y_t=x_t - \\mu_t\\), eps   following:     $$ y_t     =   c_t       + \\sum_{=1}^{p} \\phi()y            _{t-}       + \\sum_{=1}^{q} \\theta()\\varepsilon_{t-}       + \\varepsilon_t     $$   \\(c_t\\) intercept (basically sum   intercept xintercept). whiten = FALSE, \\(y_t\\) computed   t=,...,n using formula, .e. filter   applied get y eps (initial values).   eps white noise, can said y obtained   ``colouring'' white noise eps. can used,   example, simulate ARIMA time series.  Finally, centering term   added back, \\(x_t=y_t+\\mu_t\\) t=,...,n,   modified x returned.  first - 1 elements   x left unchanged. inverse filter obtained rewriting equation equation   expressing \\(\\varepsilon_t\\) terms remaining quantities:   $$ \\varepsilon_t     = - c_t       - \\sum_{=1}^{q} \\theta()\\varepsilon_{t-}       - \\sum_{=1}^{p} \\phi  ()y          _{t-}       + y_t     $$ whiten = TRUE, xarmaFilter uses formula   t=,...,n compute eps y (  initial values). eps white noise, can said   time series y whitened. cases first values x /  eps used initial values. centering formed model$center argument   xcenter.  model$center supplied recycled   length series, x, subtracted   x. argument xcenter supplied, subtracted   x. model$center xcenter   supplied sum subtracted x. xarmaFilter can used simulate ARMA series   default value whiten = FALSE. case eps   input series y output:   model$center /xcenter added y   form output vector x. Residuals corresponding series x can obtained   setting whiten = TRUE. case x input series.   elements output vector eps calculated   formula \\(\\varepsilon_{t}\\) given .   need case restore x since eps   returned. cases necessary initial values assumed already   vectors provide first - 1 values   returned vectors.  Argument smaller   default value max(p,q)+1. xarmaFilter calls lower level function coreXarmaFilter   computation.","code":""},{"path":"/reference/xarmaFilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"result applying filter inverse, descibed Details:     whiten = FALSE, modified x;     whiten = TRUE, modified eps.","code":""},{"path":"/reference/xarmaFilter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"Georgi N. Boshnakov","code":""},{"path":"/reference/xarmaFilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"","code":"## define a seasonal ARIMA model m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)  model0 <- modelCoef(m1, \"ArmaModel\") model1 <- as(model0, \"list\")  ap.1 <- xarmaFilter(model1, x = AirPassengers, whiten = TRUE) ap.2 <- xarmaFilter(model1, x = AirPassengers, eps = ap.1, whiten = FALSE) ap <- AirPassengers ap[-(1:13)] <- 0 # check that the filter doesn't use x, except for initial values. ap.2a <- xarmaFilter(model1, x = ap, eps = ap.1, whiten = FALSE) ap.2a - ap.2 ## indeed = 0 #>      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #> 1949   0   0   0   0   0   0   0   0   0   0   0   0 #> 1950   0   0   0   0   0   0   0   0   0   0   0   0 #> 1951   0   0   0   0   0   0   0   0   0   0   0   0 #> 1952   0   0   0   0   0   0   0   0   0   0   0   0 #> 1953   0   0   0   0   0   0   0   0   0   0   0   0 #> 1954   0   0   0   0   0   0   0   0   0   0   0   0 #> 1955   0   0   0   0   0   0   0   0   0   0   0   0 #> 1956   0   0   0   0   0   0   0   0   0   0   0   0 #> 1957   0   0   0   0   0   0   0   0   0   0   0   0 #> 1958   0   0   0   0   0   0   0   0   0   0   0   0 #> 1959   0   0   0   0   0   0   0   0   0   0   0   0 #> 1960   0   0   0   0   0   0   0   0   0   0   0   0 ##ap.3 <- xarmaFilter(model1, x = list(init = AirPassengers[1:13]), eps = ap.1, whiten = TRUE)  ## now set some non-zero initial values for eps eps1 <- numeric(length(AirPassengers)) eps1[1:13] <- rnorm(13) ap.A <- xarmaFilter(model1, x = AirPassengers, eps = eps1, whiten = TRUE) ap.Ainv <- xarmaFilter(model1, x = ap, eps = ap.A, whiten = FALSE) AirPassengers - ap.Ainv # = 0 #>      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #> 1949   0   0   0   0   0   0   0   0   0   0   0   0 #> 1950   0   0   0   0   0   0   0   0   0   0   0   0 #> 1951   0   0   0   0   0   0   0   0   0   0   0   0 #> 1952   0   0   0   0   0   0   0   0   0   0   0   0 #> 1953   0   0   0   0   0   0   0   0   0   0   0   0 #> 1954   0   0   0   0   0   0   0   0   0   0   0   0 #> 1955   0   0   0   0   0   0   0   0   0   0   0   0 #> 1956   0   0   0   0   0   0   0   0   0   0   0   0 #> 1957   0   0   0   0   0   0   0   0   0   0   0   0 #> 1958   0   0   0   0   0   0   0   0   0   0   0   0 #> 1959   0   0   0   0   0   0   0   0   0   0   0   0 #> 1960   0   0   0   0   0   0   0   0   0   0   0   0  ## compare with sarima.f (an old function) ## compute predictions starting at from = 14 pred1 <- sarima.f(past = AirPassengers[1:13], n = 131, ar = model1$ar, ma = model1$ma) pred2 <- xarmaFilter(model1, x = ap, whiten = FALSE) pred2 <- pred2[-(1:13)] all(pred1 == pred2) ##TRUE #> [1] TRUE"},{"path":"/news/index.html","id":"sarima-0859000","dir":"Changelog","previous_headings":"","what":"sarima 0.8.5.9000","title":"sarima 0.8.5.9000","text":"changed doi new-style JSS format.","code":""},{"path":"/news/index.html","id":"sarima-085-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.8.5 (CRAN)","title":"sarima 0.8.5 (CRAN)","text":"CRAN release: 2021-08-20 new tsdiag method class Sarima (result sarima()). method can called also directly output base R’s arima() tsdiag.Sarima() sarima::tsdiag.Sarima(). method offers several portmanteau tests (including Ljung-Box, Li-McLeod Box-Pierce), plots autocorrelations partial autocorrelations residuals, ability control graphs produced (including interactively), layout. computed results returned (invisibly). default layout graphs similar stats::tsdiag() (adjusted d.f.). method always makes correction degrees freedom portmanteau tests. github repository housekeeping - switched TravisCI Github actions. now pkgdown website automatically rebuild push (via github action). moved FitAR Depends Imports (changes .onLoad() make possible).","code":""},{"path":"/news/index.html","id":"sarima-084-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.8.4 (CRAN)","title":"sarima 0.8.4 (CRAN)","text":"CRAN release: 2020-09-29 updated reference avoid redirect.","code":""},{"path":"/news/index.html","id":"sarima-082-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.8.2 (CRAN)","title":"sarima 0.8.2 (CRAN)","text":"CRAN release: 2020-03-02 import FKF (support removed FKF temporarily archived CRAN). removed developers’ comments accidentally left vignette. removed erroneous rev() garch tests vignette. added new tests fixed several bugs process. show method class “ArmaModel” now returns NULL. previous return value spooking “pkgdown::build_site()” resulting error:","code":"Error in UseMethod(\"replay_html\", x) :    no applicable method for 'replay_html' applied to an object of class \"c('double', 'numeric')\""},{"path":"/news/index.html","id":"sarima-081-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.8.1 (CRAN)","title":"sarima 0.8.1 (CRAN)","text":"CRAN release: 2019-05-12 relaxed numerical comparisons tests, account additional platforms, Open-BLAS, recently activated checks CRAN.","code":""},{"path":"/news/index.html","id":"sarima-080-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.8.0 (CRAN)","title":"sarima 0.8.0 (CRAN)","text":"CRAN release: 2019-04-13 new test GARCH-type noise based Kokoszka Politis result. complete sets methods several functions. particular, infinite recursion cases. bug fixes improved show() methods autocovariance objects numerous changes sarima() cater changing function names forthcoming release 2.0.0 package PolynomF. Now require lagged (>= 0.2.1) (lagged 0.2.0 sufficient since nSeasons() nSeasons<-() accidentally exported ). Vignette garch_tests_example now imports data using system.file(), examples can run easily user. new function makeArimaGnb() setting state space form ARIMA models. modification stats::makeARIMA() Georgi’s method computation stationary part initial state covariance matrix. methods implemented stats::makeARIMA()commented since exported package stats. sarima() gets argument specify method use stationary part P0 (see ). available options ones makeARIMA() (“Rossignol2011” “Gardner1980”) plus Georgi’s method (“gnb”). default “Rossignol2011”.","code":""},{"path":"/news/index.html","id":"sarima-076-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.7.6 (CRAN)","title":"sarima 0.7.6 (CRAN)","text":"CRAN release: 2018-08-23 updated Makevars Makevars.win deal NOTE recent tightening checks CRAN (see https://stat.ethz.ch/pipermail/r-package-devel/2018q3/003030.html).","code":""},{"path":"/news/index.html","id":"sarima-075","dir":"Changelog","previous_headings":"","what":"sarima 0.7.5","title":"sarima 0.7.5","text":"NEWS becomes NEWS.md uses markdown syntax. style loosely based http://style.tidyverse.org/news.html). manually incorporated noted changes Jamie’s 0.7.4.9001/2018-08-17. Namely: Import package numDeriv (hessian()).","code":""},{"path":"/news/index.html","id":"sarima-074","dir":"Changelog","previous_headings":"","what":"sarima 0.7.4","title":"sarima 0.7.4","text":"dealt ‘valgrind’ warnings (missed one uninitialised warning). fixed bug prepareSimSarima() - initial values supplied stationary case, initialisation correct (thanks Cameron Doyle reporting ).","code":""},{"path":"/news/index.html","id":"sarima-073-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.7.3 (CRAN)","title":"sarima 0.7.3 (CRAN)","text":"CRAN release: 2018-07-12 dealt ‘valgrind’ warnings.","code":""},{"path":"/news/index.html","id":"sarima-072-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.7.2 (CRAN)","title":"sarima 0.7.2 (CRAN)","text":"CRAN release: 2018-07-09 emergency release avoid package archived CRAN due archival dependency. main new feature since previous release, 0.5-2, package versatile function sarima(), provides formula syntax fitting encompassing SARIMA, ARUMA, XSARIMA, Reg-SARIMA, ARMAX models. Parsimonious multiplicative specifications supported stationary non-stationary parts model, well arbitrary unit roots unit circle, can fixed estimated. ‘sarima()’ documented still development. removed ‘portes’ Imports - used time ‘sarima’ (scheduled removal CRAN 2018-07-30). removed package ‘FKF’ Imports, since archived CRAN.","code":""},{"path":"/news/index.html","id":"sarima-07-0---07-1","dir":"Changelog","previous_headings":"","what":"sarima 0.7-0 - 0.7-1","title":"sarima 0.7-0 - 0.7-1","text":"merged branch models master. numerous consolidations. Changes branch ‘models’ DESCRIPTION, moved ‘methods’ DEPENDS Imports. various bug fixes cosolidations. improvements documentation. returned stuff test package ‘testts’ (removed latter). testts helpful complicated workflow. Now tests armaQ0 etc `sarima.","code":""},{"path":"/news/index.html","id":"sarima-06-6","dir":"Changelog","previous_headings":"","what":"sarima 0.6-6","title":"sarima 0.6-6","text":"now can request estimation components roots unit circle. xreg regx specifications, renamed cs(), B(), p() .cs(), .B(), .p(), respectively. , xreg regx specifications `t’ stays now, since needs care, use discouraged. removed sincos() L() sarima specifications, use equivalents .cs() .B(), respectively.","code":""},{"path":"/news/index.html","id":"sarima-06-4---06-5","dir":"Changelog","previous_headings":"","what":"sarima 0.6-4 - 0.6-5","title":"sarima 0.6-4 - 0.6-5","text":"intermediate versions, useful back reference (zip file given better place look code 0.6-6). now bitbucket part sarima_project. original upload sarima_project/Archive/sarima_project_Orig.zip. wrapping 0.6-5 making changes needed estimation unit roots.","code":""},{"path":"/news/index.html","id":"sarima-06-3","dir":"Changelog","previous_headings":"","what":"sarima 0.6-3","title":"sarima 0.6-3","text":"support tanh transformation. factorisation MA Packing version moving stuff needs ‘:::’ calls elsewhere (e.g. myRcpp, haven’t decided structure)","code":""},{"path":"/news/index.html","id":"sarima-06-1---06-2","dir":"Changelog","previous_headings":"","what":"sarima 0.6-1 - 0.6-2","title":"sarima 0.6-1 - 0.6-2","text":"Several bug fixes. trouble Rcpp, trouble Rtools installing latest version R. Packing version working reference.","code":""},{"path":"/news/index.html","id":"sarima-06-0","dir":"Changelog","previous_headings":"","what":"sarima 0.6-0","title":"sarima 0.6-0","text":"included C++ code (using Rcpp/RcppArmadilo) previously tested (private) package myRcpp. removed internal arima() functions introduced 0.5-11. added ss.method = “sarima” sarima() uses new C++ functions compute likelihood. Limited testing confirms method gives results arima() models can fitted arima(). bumping version number working version case improvements mess things .","code":""},{"path":"/news/index.html","id":"sarima-05-11","dir":"Changelog","previous_headings":"","what":"sarima 0.5-11","title":"sarima 0.5-11","text":"temporarily created number functions call functions used internally arima(), see arima.R.","code":""},{"path":"/news/index.html","id":"sarima-05-9","dir":"Changelog","previous_headings":"","what":"sarima 0.5-9","title":"sarima 0.5-9","text":"moved temporarilly FitAR Imports Depends, since FitARMA can’t find functions FitAR FitARMA attached. (move back Imports Ian imports FitAR FitARMA’s namespace) work sarima(), saving meddling environments formulas","code":""},{"path":"/news/index.html","id":"sarima-05-8","dir":"Changelog","previous_headings":"","what":"sarima 0.5-8","title":"sarima 0.5-8","text":"added support KFAS. fixed parameters initial values supported ARMA specifications (regression parameters yet). sarima() still incomplete usable. archiving full scale consolidation clean , case messes things .","code":""},{"path":"/news/index.html","id":"sarima-05-7","dir":"Changelog","previous_headings":"","what":"sarima 0.5-7","title":"sarima 0.5-7","text":"sarima() now fits XARIMAX models, case second X, using FKF::fkf(). archiving starting work completing handling fixed parameters.","code":""},{"path":"/news/index.html","id":"sarima-05-6","dir":"Changelog","previous_headings":"","what":"sarima 0.5-6","title":"sarima 0.5-6","text":"consolidation sarima(), now supports lagged variables calls sarimat(). sarima0() removed. data argument sarima() processed properly (incomplete maybe).","code":""},{"path":"/news/index.html","id":"sarima-05-5","dir":"Changelog","previous_headings":"","what":"sarima 0.5-5","title":"sarima 0.5-5","text":"sarima() now uses facilities package Formula process model formulas.","code":""},{"path":"/news/index.html","id":"sarima-05-4","dir":"Changelog","previous_headings":"","what":"sarima 0.5-4","title":"sarima 0.5-4","text":"sarima() can now fit time regression. currently calls sarimat() treg argument sarima0() otherwise.","code":""},{"path":"/news/index.html","id":"sarima-05-3","dir":"Changelog","previous_headings":"","what":"sarima 0.5-3","title":"sarima 0.5-3","text":"model formulas SARIMA models using package Formula. usable version sarima() function publication yet. packing version work sarima().","code":""},{"path":"/news/index.html","id":"sarima-05-2-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.5-2 (CRAN)","title":"sarima 0.5-2 (CRAN)","text":"CRAN release: 2017-10-16 plot acf tests now uses different ‘lty’ confidence limits iid garch nulls visually distinguishable black white printouts. plot acf tests now accepts argument ‘interval’ produce rejection limits levels default 95%. started add references documentation. armaacf() armaccf_xe() innovation variance argument ‘model’ now called ‘sigma2’ (old ‘sigmasq’ still works deprecated). number corrections additions documentation. additional examples.","code":""},{"path":"/news/index.html","id":"sarima-05-1","dir":"Changelog","previous_headings":"","what":"sarima 0.5-1","title":"sarima 0.5-1","text":"SarimaModel now inherits VirtualSarimaModel (inheriting VirtualFilterModel. , invisible user. didn’t invalidate existing objects either. new class “VirtualIntegratedModel”. new functions nUnitRoots() isStationaryModel. streamlining.","code":""},{"path":"/news/index.html","id":"sarima-05-0","dir":"Changelog","previous_headings":"","what":"sarima 0.5-0","title":"sarima 0.5-0","text":"exported functions related Bartlett’s formula (version 0.4-5, different names). substantial work SARIMA models documentation. increasing version number streamlining class SarimaModel.","code":""},{"path":"/news/index.html","id":"sarima-04-5-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.4-5 (CRAN)","title":"sarima 0.4-5 (CRAN)","text":"CRAN release: 2017-05-23 moved “Lagged” separate package, “lagged”. streamlined acfIidTest() documented properly. new vignette based example Chapter 7 James Proberts’ MMath project.","code":""},{"path":"/news/index.html","id":"sarima-04-3-cran","dir":"Changelog","previous_headings":"","what":"sarima 0.4-3 (CRAN)","title":"sarima 0.4-3 (CRAN)","text":"CRAN release: 2017-02-06 first CRAN version.","code":""},{"path":"/news/index.html","id":"sarima-03-6","dir":"Changelog","previous_headings":"","what":"sarima 0.3-6","title":"sarima 0.3-6","text":"white noise tests based acf pacf corresponding plots. vignette.","code":""},{"path":"/news/index.html","id":"sarima-03-5","dir":"Changelog","previous_headings":"","what":"sarima 0.3-5","title":"sarima 0.3-5","text":"revamped “Lagged”: introduced Lagged2d, etc.; mixed Ops, e.g. “Lagged” + “vector”, now work “vector” length one multiple length e1@data length vector.","code":""},{"path":"/news/index.html","id":"sarima-03-4","dir":"Changelog","previous_headings":"","what":"sarima 0.3-4","title":"sarima 0.3-4","text":"removed old commented code sarima.org reduce clutter. extensive changes consolidation.","code":""},{"path":"/news/index.html","id":"sarima-03-3","dir":"Changelog","previous_headings":"","what":"sarima 0.3-3","title":"sarima 0.3-3","text":"streamlined SARIMA models functions based old code. Keeping old code (commented ) reference.","code":""},{"path":"/news/index.html","id":"sarima-03-2","dir":"Changelog","previous_headings":"","what":"sarima 0.3-2","title":"sarima 0.3-2","text":"defined classes autocorrelations similar. autocorrelations() similar now number methods. passes ‘R CMD check’. classes fake documentation VirtualMonicFilter-class.Rd.","code":""},{"path":"/news/index.html","id":"sarima-03-0","dir":"Changelog","previous_headings":"","what":"sarima 0.3-0","title":"sarima 0.3-0","text":"switched package PolynomF (polynom). new classes models, including ARMA SARIMA. R CMD check passes 9only WARNING undocumented objects S$ methods.","code":""},{"path":"/news/index.html","id":"sarima-02-x","dir":"Changelog","previous_headings":"","what":"sarima 0.2-x","title":"sarima 0.2-x","text":"added new classes, substantial extension. renamed sarima.sim() sim_sarima()","code":""},{"path":"/news/index.html","id":"sarima-01-0","dir":"Changelog","previous_headings":"","what":"sarima 0.1-0","title":"sarima 0.1-0","text":"updated cleaned bit old code.","code":""},{"path":"/news/index.html","id":"sarima-00-5","dir":"Changelog","previous_headings":"","what":"sarima 0.0-5","title":"sarima 0.0-5","text":"removed argument “eps” fun.forecast since ignored.","code":""},{"path":"/news/index.html","id":"sarima-00-3","dir":"Changelog","previous_headings":"","what":"sarima 0.0-3","title":"sarima 0.0-3","text":"sarima.mod now sets class “sarima” result. print method “sarima” class.","code":""},{"path":"/news/index.html","id":"sarima-00-2","dir":"Changelog","previous_headings":"","what":"sarima 0.0-2","title":"sarima 0.0-2","text":"inserted examples lectures handouts past years.","code":""},{"path":"/news/index.html","id":"sarima-00-1","dir":"Changelog","previous_headings":"","what":"sarima 0.0-1","title":"sarima 0.0-1","text":"created documentation using comments source code.","code":""},{"path":"/news/index.html","id":"sarima-00-0","dir":"Changelog","previous_headings":"","what":"sarima 0.0-0","title":"sarima 0.0-0","text":"turned atssarima.r (written 2006-2007 course “Applied time series”) package.","code":""}]
