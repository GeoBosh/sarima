[{"path":"https://geobosh.github.io/sarima/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Georgi N. Boshnakov. Author, maintainer. Jamie Halliday. Author.","code":""},{"path":"https://geobosh.github.io/sarima/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Boshnakov GN, Halliday J (2022). sarima: Simulation Prediction Seasonal ARIMA Models. https://github.com/GeoBosh/sarima (devel) https://geobosh.github.io/sarima/ (doc).","code":"@Manual{,   title = {sarima: Simulation and Prediction with Seasonal ARIMA Models},   author = {Georgi N. Boshnakov and Jamie Halliday},   year = {2022},   note = {https://github.com/GeoBosh/sarima (devel) https://geobosh.github.io/sarima/ (doc)}, }"},{"path":"https://geobosh.github.io/sarima/index.html","id":"installing-sarima","dir":"","previous_headings":"","what":"Simulation and Prediction with Seasonal ARIMA Models","title":"Simulation and Prediction with Seasonal ARIMA Models","text":"Install latest stable version sarima CRAN: can install development version sarima Github:","code":"install.packages(\"sarima\") remotes::install_github(\"GeoBosh/sarima\")"},{"path":"https://geobosh.github.io/sarima/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Simulation and Prediction with Seasonal ARIMA Models","text":"Functions, classes methods time series modelling ARIMA related models. aim package provide consistent interface user. example, single function autocorrelations() computes various kinds theoretical sample autocorrelations. work progress, see documentation vignettes current functionality. Function sarima() fits extended multiplicative seasonal ARIMA models trends, exogenous variables arbitrary roots unit circle, can fixed estimated. Reference manuals vignettes available usual running R sessions. example, shows available vignettes: commands open vignettes (names taken output command ): Alternatively, links online versions documentation: sarima online reference manual sarima pdf reference manual CRAN vignette Garch white noise tests CRAN vignette Autocorrelations white noise tests CRAN documentation incomplete features unfinished. Bug reports suggestions welcome.","code":"vignette(package = \"sarima\") # which vignettes are available? vignette(\"white_noise_tests\", package = \"sarima\") vignette(\"garch_tests_example\", package = \"sarima\")"},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Classes ArmaModel, ArModel MaModel package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Classes \"ArModel\" \"MaModel\" subclasses   \"ArmaModel\" corresponding order always zero. recommended way create objects classes   functions ArmaModel, ArModel   MaModel. Objects can also created calls   form new(\"ArmaModel\", ..., ar, ma, mean, check).  See also   coerce-methods ways create objects   classes.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"center: Object class \"numeric\" ~~ intercept: Object class \"numeric\" ~~ sigma2: Object class \"numeric\" ~~ ar: Object class \"BJFilter\" ~~ ma: Object class \"SPFilter\" ~~","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Class \"ArmaSpec\", directly. Class \"VirtualArmaModel\", directly. Class \"ArmaFilter\", class \"ArmaSpec\", distance 2. Class \"VirtualFilterModel\", class \"VirtualArmaModel\", distance 2. Class \"VirtualStationaryModel\", class \"VirtualArmaModel\", distance 2. Class \"VirtualArmaFilter\", class \"ArmaSpec\", distance 3. Class \"VirtualAutocovarianceModel\", class \"VirtualArmaModel\", distance 3. Class \"VirtualMeanModel\", class \"VirtualArmaModel\", distance 3. Class \"VirtualMonicFilter\", class \"ArmaSpec\", distance 4.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"modelOrder signature(object = \"ArmaModel\", convention = \"ArFilter\"): ... modelOrder signature(object = \"ArmaModel\", convention = \"MaFilter\"): ... modelOrder signature(object = \"ArmaModel\", convention = \"missing\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaModel\"): ... sigmaSq signature(object = \"ArmaModel\"): ...","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classes ArmaModel, ArModel and MaModel in package sarima — ArmaModel-class","text":"","code":"arma1p1 <- new(\"ArmaModel\", ar = 0.5, ma = 0.9, sigma2 = 1) autocovariances(arma1p1, maxlag = 10) #> An object of class \"Autocovariances\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #> 3.613333333 2.706666667 1.353333333 0.676666667 0.338333333 0.169166667  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #> 0.084583333 0.042291667 0.021145833 0.010572917 0.005286458  autocorrelations(arma1p1, maxlag = 10) #> An object of class \"Autocorrelations\" #>           0           1           2           3           4           5  #> 1.000000000 0.749077491 0.374538745 0.187269373 0.093634686 0.046817343  #>           6           7           8           9          10  #> 0.023408672 0.011704336 0.005852168 0.002926084 0.001463042  partialAutocorrelations(arma1p1, maxlag = 10) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.74907749 -0.42512100  0.29448975 -0.22337052  0.17832394  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #> -0.14703750  0.12391932 -0.10606466  0.09181545 -0.08015626  partialAutocovariances(arma1p1, maxlag = 10) #> An object of class \"PartialAutocovariances\" #>           0           1           2           3           4           5  #>  3.61333333  1.18790975 -0.55232849  0.34942744 -0.25181673  0.19464072  #>           6           7           8           9          10  #> -0.15702172  0.13030164 -0.11027274  0.09465347 -0.08210298   new(\"ArmaModel\", ar = 0.5, ma = 0.9, intercept = 4) #> An object of class \"ArmaModel\" #> intercept:  4  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9 new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23) #> An object of class \"ArmaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  new(\"ArModel\", ar = 0.5,  center = 1.23) #> An object of class \"ArModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) new(\"MaModel\", ma = 0.9,  center = 1.23) #> An object of class \"MaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  # argument 'mean' is an alias for 'center': new(\"ArmaModel\", ar = 0.5, ma = 0.9, mean = 1.23) #> An object of class \"ArmaModel\" #> mean:  1.23  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  ##  both center and intercept may be given ## (the mean is not equal to the intercept in this case) new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23, intercept = 2) #> An object of class \"ArmaModel\" #> mean:  2.563333  #> intercept:  2 (full intercept:  3.845 )  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  1  #> Coefficients:  #> [1] 0.9  ## Don't use 'mean' together with 'center' and/or 'intercept'. ##    new(\"ArmaModel\", ar = 0.5, ma = 0.9, center = 1.23, mean  = 4) ##    new(\"ArmaModel\", ar = 0.5, ma = 0.9, intercept = 2, mean  = 4) ## Both give error message: ##   Use argument 'mean' only when 'center' and 'intercept' are missing or zero"},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ARMA objects — ArmaModel","title":"Create ARMA objects — ArmaModel","text":"Create ARMA objects.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ARMA objects — ArmaModel","text":"","code":"ArmaModel(...) ArModel(...) MaModel(...)"},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ARMA objects — ArmaModel","text":"... arguments passed new(). Typical     arguments ar, ma mean.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ARMA objects — ArmaModel","text":"object representing ARMA, AR MA model","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create ARMA objects — ArmaModel","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/ArmaModel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ARMA objects — ArmaModel","text":"","code":"## MA ( ma2a1 <- MaModel(ma = c(0.3, 0.7), sigma2 = 1) ) #> An object of class \"MaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(ma2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>         0         1         2         3         4         5         6  #> 1.0000000 0.3227848 0.4430380 0.0000000 0.0000000 0.0000000 0.0000000  partialAutocorrelations(ma2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.32278481  0.37825873 -0.27488077 -0.14556210  0.21468510  #>       Lag_6  #>  0.03073491  autocovariances(ma2a1, maxlag = 6) #> An object of class \"Autocovariances\" #> Lag_0 Lag_1 Lag_2 Lag_3 Lag_4 Lag_5 Lag_6  #>  1.58  0.51  0.70  0.00  0.00  0.00  0.00  partialVariances(ma2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 1.580000 1.415380 1.212868 1.121224 1.097467 1.046885 1.045896   ## sigma2 is set to NA if not specified ## but things that don't depend on it are computed: ( ma2a2 <- MaModel(ma = c(0.3, 0.7)) ) #> An object of class \"MaModel\" #> mean:  0  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(ma2a2, maxlag = 6) #> An object of class \"Autocorrelations\" #>         0         1         2         3         4         5         6  #> 1.0000000 0.3227848 0.4430380 0.0000000 0.0000000 0.0000000 0.0000000  partialAutocorrelations(ma2a2, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.32278481  0.37825873 -0.27488077 -0.14556210  0.21468510  #>       Lag_6  #>  0.03073491   ## AR ( ar2a1 <- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) ) #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) autocorrelations(ar2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #>  1.0000000 -0.1764706 -0.6470588  0.3176471  0.3576471 -0.3296471 -0.1514588  partialAutocorrelations(ar2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00 -1.764706e-01 -7.000000e-01 -1.123440e-16  0.000000e+00  #>         Lag_5         Lag_6  #>  0.000000e+00 -5.617200e-17  autocovariances(ar2a1, maxlag = 6) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  2.0238095 -0.3571429 -1.3095238  0.6428571  0.7238095 -0.6671429 -0.3065238  partialVariances(ar2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 2.023810 1.960784 1.000000 1.000000 1.000000 1.000000 1.000000   ## ARMA ( arma2a1 <- ArmaModel(ar = 0.5, ma = c(0.3, 0.7), sigma2 = 1) ) #> An object of class \"ArmaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  1  #> Coefficients:  #> [1] 0.5 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 autocorrelations(arma2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.76434426 0.59733607 0.29866803 0.14933402 0.07466701 0.03733350  partialAutocorrelations(arma2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.76434426  0.03154068 -0.40352478  0.10241517  0.22187563  #>       Lag_6  #> -0.13073299    ## modelCoef() returns a list with components 'ar' and 'ma' modelCoef(arma2a1) #> $ar #> [1] 0.5 #>  #> $ma #> [1] 0.3 0.7 #>  modelCoef(ma2a1) #> $ar #> numeric(0) #>  #> $ma #> [1] 0.3 0.7 #>  modelCoef(ar2a1) #> $ar #> [1] -0.3 -0.7 #>  #> $ma #> numeric(0) #>   ## modelOrder() returns a list with components 'ar' and 'ma' modelOrder(arma2a1) #> $ar #> [1] 1 #>  #> $ma #> [1] 2 #>  modelOrder(ma2a1) #> $ar #> [1] 0 #>  #> $ma #> [1] 2 #>  modelOrder(ar2a1) #> $ar #> [1] 2 #>  #> $ma #> [1] 0 #>   as(ma2a1, \"ArmaModel\")  # success, as expected #> An object of class \"ArmaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.3 0.7 as(ar2a1, \"ArModel\")  # success, as expected #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) as(ArmaModel(ar = c(-0.3, -0.7)), \"ArModel\") #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  NA  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) ## But these fail: ## as(ma2a1, \"ArModel\") # fails ## as(arma2a1, \"ArModel\") # fails ## as(arma2a1, \"MaModel\") # fails"},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Objects class \"ArmaSpectrum\" spectra computed   spectrum.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class ","text":"methods show, print plot work   analogously class \"Spectrum\" (  super class \"ArmaSpectrum\"). addition, print   show print also parameters ARMA model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects contain spectra produced sarima::spectrum   (recommended), see spectrum details. Objects can also created calls form   new(\"ArmaSpectrum\", ar = , ma = , sigma2 = , ...),   ar ma numeric vectors sigma2   number. sigma2 may omitted normalized   spectra can computed. possibilities arguments   considered internal subject change.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":"slots inherited class \"Spectrum\". .Data: Object class \"function\". call: Object class \"call\". model: Object class \"\".","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"initialize signature(.Object = \"ArmaSpectrum\"): ...","code":""},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/ArmaSpectrum-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"## spectral density of the stationary part of a fitted 'airline model' fit0 <- arima(AirPassengers, order = c(0,1,1),               seasonal = list(order = c(0,1,1), period = 12)) sd.air <- spectrum(fit0) show(sd.air) #> standardized spectral density of the following ARMA(0,13) model: #>   ar coef:  #>   ma coef: -0.3087 0 0 0 0 0 0 0 0 0 0 -0.1074 0.03317 #>   sigma2:  135.4237 #>  #>  #>  #> Peaks: #>            freq      spec    period #> [1,] 0.04330709 0.5534585 23.090909 #> [2,] 0.12992126 0.7355095  7.696970 #> [3,] 0.21259843 1.0438583  4.703704 #> [4,] 0.29527559 1.3951830  3.386667 #> [5,] 0.37795276 1.6971778  2.645833 #> [6,] 0.46062992 1.8701110  2.170940 #>  #> Troughs: #>  #>            freq      spec    period #> [1,] 0.00000000 0.3436561  0.000000 #> [2,] 0.08267717 0.4023487 12.095238 #> [3,] 0.16535433 0.5631871  6.047619 #> [4,] 0.24803150 0.7843876  4.031746 #> [5,] 0.33070866 1.0084214  3.023810 #> [6,] 0.41732283 1.1732882  2.396226 #> [7,] 0.50000000 1.2314609  2.000000 #>  #> max peak/min trough: #> \t5.441809 #>   plot(sd.air, log = \"y\") # plot log of the spectral density   ## use the \"ArmaSpectrum\" object as a function to evaluate the sp. density: sd.air(seq(0, 0.5, length.out = 13)) #>  [1] 0.3436561 0.5523423 0.4031278 0.7292153 0.5656073 1.0355684 0.7875585 #>  [8] 1.3893145 1.0095097 1.6956676 1.1719893 1.8725407 1.2314609 sd.air(seq(0, 0.5, length.out = 13), standardize = FALSE) #>  [1]  51.56190  82.87301  60.48498 109.41090  84.86329 155.37589 118.16468 #>  [8] 208.45168 151.46606 254.41666 175.84437 280.95456 184.76745  ## white noise (constant spectral density) sp.wn <- spectrum(ArmaModel(sigma2 = 2)) sp.wn #> standardized spectral density of the following ARMA(0,0) model: #>   ar coef:  #>   ma coef:  #>   sigma2:  2 #>  #> constant, equal to 1 for all frequencies print(sp.wn) #> standardized spectral density of the following ARMA(0,0) model: #>   ar coef:  #>   ma coef:  #>   sigma2:  2 #>  #> constant, equal to 1 for all frequencies  print(sp.wn, standardize=FALSE) #> spectral density of the following ARMA(0,0) model: #>   ar coef:  #>   ma coef:  #>   sigma2:  2 #>  #> constant, equal to 2 for all frequencies show(sp.wn) #> standardized spectral density of the following ARMA(0,0) model: #>   ar coef:  #>   ma coef:  #>   sigma2:  2 #>  #> constant, equal to 1 for all frequencies"},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher information — FisherInformation-methods","title":"Fisher information — FisherInformation-methods","text":"Compute Fisher information parameters model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher information — FisherInformation-methods","text":"","code":"FisherInformation(model, ...)  # S3 method for Arima FisherInformation(model, ...)"},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fisher information — FisherInformation-methods","text":"model fitted theoretical model method available. ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fisher information — FisherInformation-methods","text":"FisherInformation computes information matrix   parameters model. generic function. methods   objects S4 classes listed section ‘Methods’. Currently package sarima defines methods objects   representing fitted theoretical ARMA seasonal ARMA models.   integrated models result interpreted   information matrix differencing. ARMA models implementation based   (Friedlander 1984)  (seasonal   specifics) (Godolphin Godolphin 2007) .","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fisher information — FisherInformation-methods","text":"square matrix attribute \"nseasons\"","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fisher information — FisherInformation-methods","text":"Friedlander B (1984). “computation Cramer-Rao bound ARMA parameter estimation.” IEEE Transactions Acoustics, Speech, Signal Processing, 32(4), 721-727. doi:10.1109/TASSP.1984.1164391 . Godolphin EJ, Godolphin JD (2007). “Note Information Matrix Multiplicative Seasonal Autoregressive Moving-Average Models.” Wiley-Blackwell: Journal Time Series Analysis.","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fisher information — FisherInformation-methods","text":"Georgi Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Fisher information — FisherInformation-methods","text":"section lists FisherInformation methods S4   classes. signature(model = \"\")  signature(model = \"SarimaModel\")  signature(model = \"ArmaModel\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/FisherInformation-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fisher information — FisherInformation-methods","text":"","code":"## a fitted model (over-parameterised) seas_spec <- list(order = c(1,0,1), period = 4) fitted <- arima(rnorm(100), order = c(1,0,1), seasonal = seas_spec) #> Warning: possible convergence problem: optim gave code = 1 (fi <- FisherInformation(fitted)) #>              phi_1      Phi_1    theta_1    Theta_1 #> phi_1    4.4104134 -0.5264312 -4.1001422  0.4850521 #> Phi_1   -0.5264312  1.3122243  0.5018890 -1.4877105 #> theta_1 -4.1001422  0.5018890  3.8362514 -0.4649157 #> Theta_1  0.4850521 -1.4877105 -0.4649157  1.8237452 #> attr(,\"nseasons\") #> [1] 4 ## asymptotic covariance matrix of the ARMA parameters: fitted$sigma2 * solve(fi) / 100 #>                phi_1        Phi_1      theta_1      Theta_1 #> phi_1    0.394638219 -0.001750433  0.422163126  0.001231553 #> Phi_1   -0.001750433  0.117441314 -0.005746288  0.094802822 #> theta_1  0.422163126 -0.005746288  0.454723357 -0.001048330 #> Theta_1  0.001231553  0.094802822 -0.001048330  0.082830694  ## a theoretical seasonal ARMA model: sarima1 <- new(\"SarimaModel\", ar = 0.9, ma = 0.1, sar = 0.5, sma = 0.9, nseasons = 12) FisherInformation(sarima1) #>              phi_1         Phi_1       theta_1       Theta_1 #> phi_1    5.2631579  3.654122e-01 -9.174312e-01 -2.502105e-01 #> Phi_1    0.3654122  1.333333e+00  1.000000e-11 -6.896552e-01 #> theta_1 -0.9174312  1.000000e-11  1.010101e+00 -1.000000e-11 #> Theta_1 -0.2502105 -6.896552e-01 -1.000000e-11  5.263158e+00 #> attr(,\"nseasons\") #> [1] 12  ## a non-seasonal ARMA model: arma2a1 <- ArmaModel(ar = 0.5, ma = c(0.3, 0.7), sigma2 = 1) FisherInformation(arma2a1) #>              phi_1    theta_1    theta_2 #> phi_1    1.3333333 -0.7547170 -0.3773585 #> theta_1 -0.7547170  2.0238095 -0.3571429 #> theta_2 -0.3773585 -0.3571429  2.0238095 #> attr(,\"nseasons\") #> [1] NA ## sigma2 is not needed for the information matrix: arma2a1a <- ArmaModel(ar = 0.5, ma = c(0.3, 0.7)) FisherInformation(arma2a1a) # same as above #>              phi_1    theta_1    theta_2 #> phi_1    1.3333333 -0.7547170 -0.3773585 #> theta_1 -0.7547170  2.0238095 -0.3571429 #> theta_2 -0.3773585 -0.3571429  2.0238095 #> attr(,\"nseasons\") #> [1] NA"},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class InterceptSpec — InterceptSpec-class","title":"Class InterceptSpec — InterceptSpec-class","text":"helper class number models inherit intercept,   centering innovations variance.","code":""},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class InterceptSpec — InterceptSpec-class","text":"Objects can created calls form new(\"InterceptSpec\", ...).","code":""},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class InterceptSpec — InterceptSpec-class","text":"center: Object class \"numeric\",       centering parameter, defaults zero. intercept: Object class \"numeric\",       intercept parameter, defaults zero. sigma2: Object class \"numeric\",       innovations variance, defaults NA.","code":""},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class InterceptSpec — InterceptSpec-class","text":"sigmaSq signature(object = \"InterceptSpec\"): ...","code":""},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class InterceptSpec — InterceptSpec-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/InterceptSpec-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class InterceptSpec — InterceptSpec-class","text":"","code":"showClass(\"InterceptSpec\") #> Class \"InterceptSpec\" [package \"sarima\"] #>  #> Slots: #>                                      #> Name:     center intercept    sigma2 #> Class:   numeric   numeric   numeric #>  #> Known Subclasses:  #> Class \"ArmaSpec\", directly #> Class \"SarimaSpec\", directly #> Class \"ArmaModel\", by class \"ArmaSpec\", distance 2 #> Class \"ArModel\", by class \"ArmaSpec\", distance 3 #> Class \"MaModel\", by class \"ArmaSpec\", distance 3 #> Class \"SarimaModel\", by class \"SarimaSpec\", distance 2"},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class SarimaModel in package sarima — SarimaModel-class","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Class SarimaModel package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Class \"SarimaModel\" represents standard SARIMA models.  Objects   can created calls form   new(\"SarimaModel\", ..., ar, ma, sar, sma),   using named arguments form slotname = value,   slotname one slots, see .  arguments   natural defaults. may somewhat surprising though   default variance innovations (slot \"sigma2\")   NA. rationale choice calculations   innovations' variance needed , importantly,   far easy forget include model (least   author) variance matters. latter may may lead silently   wrong results \"natural\" default value one used   sigma2 matters. models may specified intercept (center = 0)   mean-corrected (intercept = 0) form. Setting non-zero   values accepted rarely needed. waih modify existing object class   \"SarimaModel\", give unnamed argument \"new\"   specify slots changed, see examples. Use .SarimaModel convert model fitted   stats::arima() \"SarimaModel\".","code":""},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"center: Object class \"numeric\",       number, ARIMA equation X(t) - center.  intercept: Object class \"numeric\",       number, intercept ARIMA equation.  sigma2: Object class \"numeric\",       positive number, innovations variance.  nseasons: Object class \"numeric\",       positive integer, number seasons. non-seasonal models       NA.  iorder: Object class \"numeric\",       non-negative integer, integration order.  siorder: Object class \"numeric\",       non-negative integer, seasonal integration order.  ar: Object class \"BJFilter\",       non-seasonal AR part model.  ma: Object class \"SPFilter\",       non-seasonal MA part model.  sar: Object class \"BJFilter\",       seasonal AR part model. sma: Object class \"SPFilter\",       seasonal MA part model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Class \"VirtualFilterModel\", directly. Class \"SarimaSpec\", directly. Class \"SarimaFilter\", class \"SarimaSpec\", distance 2. Class \"VirtualSarimaFilter\", class \"SarimaSpec\", distance 3. Class \"VirtualCascadeFilter\", class \"SarimaSpec\", distance 4. Class \"VirtualMonicFilter\", class \"SarimaSpec\", distance 5.","code":""},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"SARIMA models contain special cases number models.   one-argument method modelCoef essentially   definition model coefficients SARIMA models. two-argument   methods request model coefficients according convention   class second argument. second argument may also   character string naming target class. Essentially, methods modelCoef generalisation   () methods can interpreted (extent,   result necessarilly target class, least   target class may virtual).  modelCoef signature(object = \"SarimaModel\", convention = \"missing\"):       Converts object \"SarimaFilter\".  modelCoef signature(object = \"SarimaModel\", convention = \"SarimaFilter\"):       Converts object \"SarimaFilter\", equivalent       one-argument call modelCoef(object).  modelCoef signature(object = \"SarimaModel\", convention\t= \"ArFilter\"):       Convert object \"ArFilter\". error raised       object non-trivial moving average part.  modelCoef signature(object = \"SarimaModel\", convention\t= \"MaFilter\"):       Convert object \"MaFilter\". error raised       object non-trivial autoregressive part.  modelCoef signature(object = \"SarimaModel\", convention\t= \"ArmaFilter\"):       Convert object \"ArmaFilter\". operation always successeds.  modelCoef signature(object = \"SarimaModel\", convention\t= \"character\"):       second argument gives name target class.       conceptually equivalent modelCoef(object, new(convention)).  modelOrder gives order model according   conventions target class. error raised object   compatible target class.  modelOrder signature(object = \"SarimaModel\", convention = \"ArFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArmaModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"ArModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"MaFilter\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"MaModel\"): ... modelOrder signature(object = \"SarimaModel\", convention = \"missing\"): ... polynomials associated object can obtained   following methods. Note target \"ArmaFilter\" gives fully   expanded products AR MA polynomials, needed, e.g.,   filtering.  modelPoly signature(object = \"SarimaModel\", convention = \"ArmaFilter\"): `      Gives fully expanded polynomials list  modelPoly signature(object = \"SarimaModel\", convention = \"missing\"):       Gives polynomials associated model list.  modelPolyCoef signature(object = \"SarimaModel\", convention = \"ArmaFilter\"):       Give coefficients fully expanded polynomials list. modelPolyCoef signature(object = \"SarimaModel\", convention = \"missing\"):       Gives coefficients polynomials associated model list.","code":""},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/SarimaModel-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class SarimaModel in package sarima — SarimaModel-class","text":"","code":"ar1 <- new(\"SarimaModel\", ar = 0.9) ar1c <- new(\"SarimaModel\", ar = 0.9, intercept = 3) ar1c #> An object of class \"SarimaModel\" #> Model: Phi(B)X(t) = intercept + e(t) #>  #> intercept:  3  #> sigmaSq:  NA  #> Non-seasonal model  #> Order of differencing:  0  #>  #> ar coefficients:   0.9 #> ma coefficients:    <None> ar1m <- new(\"SarimaModel\", ar = 0.9, center = 1) ar1m #> An object of class \"SarimaModel\" #> Model: Phi(B)(X(t) - center) = e(t) #>  #> mean:  1  #> sigmaSq:  NA  #> Non-seasonal model  #> Order of differencing:  0  #>  #> ar coefficients:   0.9 #> ma coefficients:    <None>  sm0 <- new(\"SarimaModel\", nseasons = 12) sm1 <- new(\"SarimaModel\", nseasons = 12, intercept = 3) sm1 #> An object of class \"SarimaModel\" #> Model: X(t) = intercept + e(t) #>  #> intercept:  3  #> sigmaSq:  NA  #> Period:  12  #> Order of differencing:  0  #> Order of seasonal differencing:  0  #>  #> ar coefficients:    <None> #> ma coefficients:    <None> #> seasonal ar coefficients:   <None> #> seasonal ma coefficients:   <None> ## alternatively, pass a model and modify with named arguments sm1b <- new(\"SarimaModel\", sm0, intercept = 3) identical(sm1, sm1b) # TRUE #> [1] TRUE  ## in the above models sigma2 is NA  ## sm2 - from scratch, the rest modefy an existing model sm2  <- new(\"SarimaModel\", ar = 0.9, nseasons = 12, intercept = 3, sigma2 = 1) sm2a <- new(\"SarimaModel\", sm0, ar = 0.9, intercept = 3, sigma2 = 1) sm2b <- new(\"SarimaModel\", sm1, ar = 0.9, sigma2 = 1) sm2c <- new(\"SarimaModel\", ar1c, nseasons =12, sigma2 = 1) identical(sm2, sm2a) # TRUE #> [1] TRUE identical(sm2, sm2b) # TRUE #> [1] TRUE identical(sm2, sm2c) # TRUE #> [1] TRUE  sm3 <- new(\"SarimaModel\", ar = 0.9, sar = 0.8, nseasons = 12, intercept = 3,            sigma2 = 1) sm3b <- new(\"SarimaModel\", sm2, sar = 0.8) identical(sm3, sm3b) # TRUE #> [1] TRUE  ## The classic 'airline model' (from examples for AirPassengers) (fit <- arima(log10(AirPassengers), c(0, 1, 1),               seasonal = list(order = c(0, 1, 1), period = 12))) #>  #> Call: #> arima(x = log10(AirPassengers), order = c(0, 1, 1), seasonal = list(order = c(0,  #>     1, 1), period = 12)) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4018  -0.5569 #> s.e.   0.0896   0.0731 #>  #> sigma^2 estimated as 0.0002543:  log likelihood = 353.96,  aic = -701.92  as.SarimaModel(fit) #> An object of class \"SarimaModel\" #> Model: (1-B)(1-B^s)X(t) = Theta(B)Theta_s(B^s)e(t) #>  #> Intercept:  0  #> SigmaSq:  0.0002542551  #> Period:  12  #> Order of differencing:  1  #> Order of seasonal differencing:  1  #>  #> ar coefficients:    <None> #> ma coefficients:   -0.401827932080369 #> seasonal ar coefficients:   <None> #> seasonal ma coefficients:  -0.556944787504635"},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Objects class \"Spectrum\" spectra computed   spectrum.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class ","text":"","code":"# S3 method for Spectrum print(x, ..., n = 128, standardize = TRUE)  # S3 method for Spectrum plot(x, y, to, from = y, n = 128, standardize = TRUE,     log = NULL, main = \"Spectral density\", xlab = \"Frequency\", ylab = NULL, ...)"},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class ","text":"x \"Spectrum\" object. y used ,interval frequencies plot, defaults \\([0,1/2]\\). n number points plot (plot method), number points     look peaks troughs (print method). standardize TRUE make spectral density integrate one (.e.,     probability density function). log log = \"y\" plot logarithm spectral density, see     ?plot.default. main character string, title plot. xlab character string, label x-axis. ylab character string, label y-axis. NULL,     default, label set \"Spd\" \"log(Spd)\",     depending value argument log.  ... print, arguments print.default(); plot, arguments curve.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Class ","text":"\"Spectrum\" S4 class autoprinting calls   \"Spectrum\" method show(), prints   plots. show single argument, object.    control printing, call print additional   arguments. Similarly, call plot flexible graphics. print(object) (.e., without arguments) equivalent   show(object), except former returns object   latter returns NULL (invisibly), standard   functions.  print called   arguments. spectrum plotted. peaks throughs printed print computed   evaluating spectral density n equially spaced points   recording maxima resulting discrete sequence. Set argument   n get finer/coarser grid force calculations   particular frequencies. example, multiple 12 may suitable   n data monthly. Except x standardize arguments   plot method curve. default   standardize = TRUE spectral density integrates one   one whole period (usually \\((-1/2, 1/2]\\) due symmetry   usually plotted second half interval.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects contain spectra produced sarima::spectrum,   see spectrum details. Objects can also created calling \"new\"   recommended currently considered internal.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":".Data: Object class \"function\" ~~ call: Object class \"call\" ~~ model: Object class \"\",       underlying model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"plot signature(x = \"Spectrum\", y = \"\"):       plots x. show signature(object = \"Spectrum\"): plots object prints succinct information ,       including peaks troughs spectral density.       equivalent calling print plot single       argument, see section ‘Details’.","code":""},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/Spectrum-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"## ARFIMA(0,d,0) with parameters 'freq' and 'd' spARFIMA0d0 <- function(freq){  sigma2 / (2 * sin(2*pi*freq/2)^(2 * d)) } sp <- spectrum(spARFIMA0d0, param = list(sigma2 = 1, d = 0.2)) print(sp, digits = 4) #>  #>  #> Peaks: #>      freq spec period #> [1,]    0  Inf      0 #>  #> Troughs: #>  #>      freq spec period #> [1,]  0.5  0.5      2 #>  #> max peak/min trough: #> \tInf #>  ## evaluate the spd at selected frequencies  sp(c(0:4 / 8)) #> [1]       Inf 0.7342334 0.5743492 0.5160881 0.5000000  ## argument 'freq' doesn't need to be called 'freq' but it needs to be ##   the first one. This is equivalent to above: spARFIMA0d0b <- function(x){  sigma2 / (2 * sin(2*pi*x/2)^(2 * d)) } spb <- spectrum(spARFIMA0d0b, param = list(sigma2 = 1, d = 0.2)) plot(spb)   ## An example without parameters, as above with sigma2 = 1, d = 0.2 hard ##   coded: spARFIMA0d0c <- function(freq){  1 / (2 * sin(2*pi*freq/2)^(2 * 0.2)) } spc <- spectrum(spARFIMA0d0c) print(spc, digits = 4) #>  #>  #> Peaks: #>      freq spec period #> [1,]    0  Inf      0 #>  #> Troughs: #>  #>      freq spec period #> [1,]  0.5  0.5      2 #>  #> max peak/min trough: #> \tInf #>   spc(c(0:4 / 8)) #> [1]       Inf 0.7342334 0.5743492 0.5160881 0.5000000 all.equal(spc(c(0:4 / 8)), sp(c(0:4 / 8))) # TRUE #> [1] TRUE"},{"path":"https://geobosh.github.io/sarima/reference/VirtualMonicFilter-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Undocumented classes in package sarima — VirtualMonicFilter-class","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"page classes without proper documentation.","code":""},{"path":"https://geobosh.github.io/sarima/reference/VirtualMonicFilter-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"virtual Class: objects may   created . page exists remind classes   documentation yet. exists avoid cluttering report 'R   CMD check' early stages development.","code":""},{"path":"https://geobosh.github.io/sarima/reference/VirtualMonicFilter-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"methods defined class \"VirtualMonicFilter\" signature.","code":""},{"path":"https://geobosh.github.io/sarima/reference/VirtualMonicFilter-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Undocumented classes in package sarima — VirtualMonicFilter-class","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Tests for weak white noise — acfGarchTest","title":"Tests for weak white noise — acfGarchTest","text":"Carry tests weak white noise GARCH, GARCH-type,   stochastic volatility null hypotheses.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tests for weak white noise — acfGarchTest","text":"","code":"acfGarchTest(acr, x, nlags, interval = 0.95)  acfWnTest(acr, x, nlags, interval = 0.95, ...)"},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tests for weak white noise — acfGarchTest","text":"acr autocorrelations. x time series. nlags many lags use. interval NULL, compute also confidence intervals     specified coverage probability. ... additional arguments computation variance matrix     null hypothesis, passed nvarOfAcfKP.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tests for weak white noise — acfGarchTest","text":"Unlike autocorrelation IID test, time series needed   estimate covariance matrix autocorrelations null   hypothesis. acfGarchTest performs test uncorrelatedness time   series. null hypothesis time series GARCH,   see Francq Zakoian (2010) . acfWnTest performs test uncorrelatedness time   series weaker null hypothesis.   null hypothesis time series GARCH-type   stochasitc volatily model,   see   Kokoszka Politis (2011) . See references details precise specification   hypotheses. format return value acfIidTest.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tests for weak white noise — acfGarchTest","text":"list components \"test\" \"ci\"","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Tests for weak white noise — acfGarchTest","text":"Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Kokoszka PS, Politis DN (2011). “Nonlinearity ARCH stochastic volatility models Bartlett's formula.” Probability Mathematical Statistics, 31(1), 47--59.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tests for weak white noise — acfGarchTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/acfGarchTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tests for weak white noise — acfGarchTest","text":"","code":"## see also the examples for \\code{\\link{whiteNoiseTest}} set.seed(1234) n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.pacf <- partialAutocorrelations(x)  acfGarchTest(x.acf, x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  2.867048 0.7204741 #> [2,] 10  9.064633 0.5259808 #> [3,] 20 24.420187 0.2245192 #>  #> $ci #>               int            #>  [1,] -0.05923087 0.05923087 #>  [2,] -0.05326386 0.05326386 #>  [3,] -0.05066191 0.05066191 #>  [4,] -0.04522221 0.04522221 #>  [5,] -0.04507543 0.04507543 #>  [6,] -0.04189048 0.04189048 #>  [7,] -0.04210249 0.04210249 #>  [8,] -0.03890700 0.03890700 #>  [9,] -0.03517673 0.03517673 #> [10,] -0.03572033 0.03572033 #> [11,] -0.03155470 0.03155470 #> [12,] -0.03222239 0.03222239 #> [13,] -0.03105026 0.03105026 #> [14,] -0.03010171 0.03010171 #> [15,] -0.02875639 0.02875639 #> [16,] -0.02686352 0.02686352 #> [17,] -0.02775162 0.02775162 #> [18,] -0.02700132 0.02700132 #> [19,] -0.02673210 0.02673210 #> [20,] -0.02709457 0.02709457 #>  acfGarchTest(x.pacf, x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  2.884453 0.7177943 #> [2,] 10  9.183271 0.5148034 #> [3,] 20 27.271537 0.1277959 #>  #> $ci #>               int            #>  [1,] -0.05923087 0.05923087 #>  [2,] -0.05326386 0.05326386 #>  [3,] -0.05066191 0.05066191 #>  [4,] -0.04522221 0.04522221 #>  [5,] -0.04507543 0.04507543 #>  [6,] -0.04189048 0.04189048 #>  [7,] -0.04210249 0.04210249 #>  [8,] -0.03890700 0.03890700 #>  [9,] -0.03517673 0.03517673 #> [10,] -0.03572033 0.03572033 #> [11,] -0.03155470 0.03155470 #> [12,] -0.03222239 0.03222239 #> [13,] -0.03105026 0.03105026 #> [14,] -0.03010171 0.03010171 #> [15,] -0.02875639 0.02875639 #> [16,] -0.02686352 0.02686352 #> [17,] -0.02775162 0.02775162 #> [18,] -0.02700132 0.02700132 #> [19,] -0.02673210 0.02673210 #> [20,] -0.02709457 0.02709457 #>   # do not compute CI's: acfGarchTest(x.pacf, x = x, nlags = c(5,10,20), interval = NULL) #> $test #>       h         Q      pval #> [1,]  5  2.884453 0.7177943 #> [2,] 10  9.183271 0.5148034 #> [3,] 20 27.271537 0.1277959 #>   ## plot methods call acfGarchTest() suitably if 'x' is given: plot(x.acf, data = x)  plot(x.pacf, data = x)   ## use 90% limits: plot(x.acf, data = x, interval = 0.90)   acfWnTest(x.acf, x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  2.695352 0.7468293 #> [2,] 10  8.157398 0.6134657 #> [3,] 20 20.691112 0.4155097 #>  #> $ci #>               int            #>  [1,] -0.05923087 0.05923087 #>  [2,] -0.05326386 0.05326386 #>  [3,] -0.05066191 0.05066191 #>  [4,] -0.04522221 0.04522221 #>  [5,] -0.04507543 0.04507543 #>  [6,] -0.04189048 0.04189048 #>  [7,] -0.04210249 0.04210249 #>  [8,] -0.03890700 0.03890700 #>  [9,] -0.03517673 0.03517673 #> [10,] -0.03572033 0.03572033 #> [11,] -0.03155470 0.03155470 #> [12,] -0.03222239 0.03222239 #> [13,] -0.03105026 0.03105026 #> [14,] -0.03010171 0.03010171 #> [15,] -0.02875639 0.02875639 #> [16,] -0.02686352 0.02686352 #> [17,] -0.02775162 0.02775162 #> [18,] -0.02700132 0.02700132 #> [19,] -0.02673210 0.02673210 #> [20,] -0.02709457 0.02709457 #>  nvarOfAcfKP(x, maxlag = 20) #>  [1] 4.5663595 3.6926586 3.3406961 2.6618118 2.6445613 2.2840442 2.3072224 #>  [8] 1.9702857 1.6105891 1.6607521 1.2959906 1.3514172 1.2548862 1.1793864 #> [15] 1.0763228 0.9392902 1.0024221 0.9489510 0.9301220 0.9555168 whiteNoiseTest(x.acf, h0 = \"arch-type\", x = x, nlags = c(5,10,20)) #> $test #>       h         Q      pval #> [1,]  5  2.695352 0.7468293 #> [2,] 10  8.157398 0.6134657 #> [3,] 20 20.691112 0.4155097 #>  #> $ci #>               int            #>  [1,] -0.05923087 0.05923087 #>  [2,] -0.05326386 0.05326386 #>  [3,] -0.05066191 0.05066191 #>  [4,] -0.04522221 0.04522221 #>  [5,] -0.04507543 0.04507543 #>  [6,] -0.04189048 0.04189048 #>  [7,] -0.04210249 0.04210249 #>  [8,] -0.03890700 0.03890700 #>  [9,] -0.03517673 0.03517673 #> [10,] -0.03572033 0.03572033 #> [11,] -0.03155470 0.03155470 #> [12,] -0.03222239 0.03222239 #> [13,] -0.03105026 0.03105026 #> [14,] -0.03010171 0.03010171 #> [15,] -0.02875639 0.02875639 #> [16,] -0.02686352 0.02686352 #> [17,] -0.02775162 0.02775162 #> [18,] -0.02700132 0.02700132 #> [19,] -0.02673210 0.02673210 #> [20,] -0.02709457 0.02709457 #>"},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Carry out IID tests using sample autocorrelations — acfIidTest","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Carry tests IID sample autocorrelations.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"","code":"acfIidTest(acf, n, npar = 0, nlags = npar + 1,            method = c(\"LiMcLeod\", \"LjungBox\", \"BoxPierce\"),            interval = 0.95, expandCI = TRUE, ...)"},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"acf autocorrelations. n length corresponding time series. npar number df subtract. nlags number autocorrelations use portmonteau     statistic, can vector request several statistics. method character string, one \"LiMcLeod\", \"LjungBox\" \"BoxPierce\". interval number NULL. expandCI logical flag, TRUE return CI lag     max(nlags). Used CI's requested. ... additional arguments passed methods. particular,     methods argument x time series.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Performs one several tests IID based sample   autocorrelations. correction degrees freedom   residuals fitted models can specified argument   npar. nlags specifies number autocorrelations   use test, can vector request several tests. results test gathered matrix one row   element nlags. test statistic column \"ChiSq\",   degrees freedom \"DF\" p-value \"pvalue\". method   attribute \"method\". interval NULL confidence intervals   autocorrelations computed, null hypothesis   independence. coverage probability (probabilities)   speciified interval. argument expandCI TRUE, one row   lag, max(nlags). best use feature   single coverage probability. expandCI FALSE confidence intervals put   matrix one row coverage probability.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"list components \"test\" (requested) \"ci\", described   Details","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"signature(acf = \"\") method acf contains autocorrelations. signature(acf = \"missing\") autocorrelations computed argument x (time series). signature(acf = \"SampleAutocorrelations\") convenience method argument n taken   acf thus need specified user.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/acfIidTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Carry out IID tests using sample autocorrelations — acfIidTest","text":"","code":"set.seed(1234) ts1 <- rnorm(100)  a1 <- drop(acf(ts1)$acf)  acfIidTest(a1, n = 100, nlags = c(5, 10, 20)) #> $test #>         ChiSq DF       pvalue #> [1,] 102.7351  5 1.400761e-20 #> [2,] 115.6877 10 3.785190e-20 #> [3,] 123.1473 20 7.429551e-17 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  acfIidTest(a1, n = 100, nlags = c(5, 10, 20), method = \"LjungBox\") #> $test #>         ChiSq DF       pvalue #> [1,] 105.7423  5 3.249445e-21 #> [2,] 119.6584 10 5.935593e-21 #> [3,] 126.8248 20 1.532370e-17 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  acfIidTest(a1, n = 100, nlags = c(5, 10, 20), interval = NULL) #> $test #>         ChiSq DF       pvalue #> [1,] 102.7351  5 1.400761e-20 #> [2,] 115.6877 10 3.785190e-20 #> [3,] 123.1473 20 7.429551e-17 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  acfIidTest(a1, n = 100, method = \"LjungBox\", interval = c(0.95, 0.90), expandCI = FALSE) #> $test #>         ChiSq DF       pvalue #> [1,] 103.0303  1 3.300609e-24 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>             int           #> [1,] -0.1959964 0.1959964 #> [2,] -0.1644854 0.1644854 #> attr(,\"level\") #> [1] 0.95 0.90 #>    ## acfIidTest() is called behind the scenes by methods for autocorrelation objects ts1_acrf <- autocorrelations(ts1) class(ts1_acrf)  # \"SampleAutocorrelations\" #> [1] \"SampleAutocorrelations\" #> attr(,\"package\") #> [1] \"sarima\" whiteNoiseTest(ts1_acrf, h0 = \"iid\", nlags = c(5,10,20), method = \"LiMcLeod\") #> $test #>          ChiSq DF    pvalue #> [1,]  3.969382  5 0.5538326 #> [2,] 15.709796 10 0.1082467 #> [3,] 24.323983 20 0.2285263 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>              int           #>  [1,] -0.1959964 0.1959964 #>  [2,] -0.1959964 0.1959964 #>  [3,] -0.1959964 0.1959964 #>  [4,] -0.1959964 0.1959964 #>  [5,] -0.1959964 0.1959964 #>  [6,] -0.1959964 0.1959964 #>  [7,] -0.1959964 0.1959964 #>  [8,] -0.1959964 0.1959964 #>  [9,] -0.1959964 0.1959964 #> [10,] -0.1959964 0.1959964 #> [11,] -0.1959964 0.1959964 #> [12,] -0.1959964 0.1959964 #> [13,] -0.1959964 0.1959964 #> [14,] -0.1959964 0.1959964 #> [15,] -0.1959964 0.1959964 #> [16,] -0.1959964 0.1959964 #> [17,] -0.1959964 0.1959964 #> [18,] -0.1959964 0.1959964 #> [19,] -0.1959964 0.1959964 #> [20,] -0.1959964 0.1959964 #> attr(,\"level\") #> [1] 0.95 #>  plot(ts1_acrf)   ## use 10% level of significance in the plot: plot(ts1_acrf, interval = 0.9)"},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Autocorrelation test for MA(q) — acfMaTest","title":"Autocorrelation test for MA(q) — acfMaTest","text":"Carry autocorrelation test MA(q).","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Autocorrelation test for MA(q) — acfMaTest","text":"","code":"acfMaTest(acf, ma, n, nlags, interval = 0.95)"},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Autocorrelation test for MA(q) — acfMaTest","text":"acf autocorrelations. ma positive integer, moving average order. n length corresponding time series. nlags number autocorrelations use portmonteau     statistic, can vector request several statistics. interval number NULL.","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Autocorrelation test for MA(q) — acfMaTest","text":"acfMaTest performs test time series MA(ma),    classical assumptions Bartlett's formulas. intervals requested, confidence intervals lags 1   ma.  lags greater moving average order, ma,   autocorrelations outside suggest reject null hypothesis   process MA(ma).","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Autocorrelation test for MA(q) — acfMaTest","text":"list components \"test\" (requested) \"ci\"","code":""},{"path":"https://geobosh.github.io/sarima/reference/acfMaTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Autocorrelation test for MA(q) — acfMaTest","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/ar2Pacf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert AR parameters to parcor — ar2Pacf","title":"Convert AR parameters to parcor — ar2Pacf","text":"Convert AR parameters parcor.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ar2Pacf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert AR parameters to parcor — ar2Pacf","text":"","code":"ar2Pacf(phi)"},{"path":"https://geobosh.github.io/sarima/reference/ar2Pacf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert AR parameters to parcor — ar2Pacf","text":"phi numeric, AR parameters. numeric(0) stands AR(0).","code":""},{"path":"https://geobosh.github.io/sarima/reference/ar2Pacf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert AR parameters to parcor — ar2Pacf","text":"internal now, exported better name.","code":""},{"path":"https://geobosh.github.io/sarima/reference/ar2Pacf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert AR parameters to parcor — ar2Pacf","text":"numeric, parcor coefficients   (length(phi) <= 1, phi returned )","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"Wrappers internals 'stats' functions used arima()   compute initial state covariance matrix ARMA models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"","code":"<!-- % arma_Q0Gardner(phi, theta, tol = .Machine$double.eps) -->  <!-- % arma_Q0bis(phi, theta, tol = .Machine$double.eps) -->  arma_Q0naive(phi, theta, tol = .Machine$double.eps)  arma_Q0gnbR(phi, theta, tol = .Machine$double.eps)"},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"phi autoregressive coefficients. theta moving average coefficients. tol tollerance.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"arima() uses one two methods compute initial state   covariance matrix stationary ARMA model. methods   implemented internal non-exported C functions.   arma_Q0Gardner() arma_Q0bis simple R wrappers   functions. defined tests (TODO: put   examples?) bit defined namespace package   since use unexported functions. arma_Q0Gardner() implements original method Gardner et   al (1980). arma_Q0bis() recent method deals   better roots close unit circle. functions can useful comparative testing.    put package 'sarima' since use `:::` operator   hence inadmissible CRAN.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"matrix","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"Gardner G, Harvey AC, Phillips GDA (1980). “Algorithm AS154. algorithm exact maximum likelihood estimation autoregressive-moving average models means Kalman filtering.” Applied Statistics, 311--322.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0Gardner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing the initial state covariance matrix of ARMA — arma_Q0Gardner","text":"","code":"## arma_Q0Gardner(phi, theta, tol = .Machine$double.eps) ## arma_Q0bis(phi, theta, tol = .Machine$double.eps)"},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the initial state covariance of ARMA model — arma_Q0gnb","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Compute initial state covariance ARMA model","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"","code":"arma_Q0gnb(phi, theta, tol = 2.220446e-16)"},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"phi autoregression parameters. theta moving average parameters. tol tollerance. (TODO: explain)","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Experimental computation initial state covariance matrix   ARMA models. numerical results comparable   SSinit = \"Rossignol2011\" method arima   related functions.   method seems twice faster \"Rossignol2011\" models   tried done systematic tests. See section ‘examples’ , tests based   tests stats, tests   test/testthat/test-arma-q0.R.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"matrix","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Gardner G, Harvey AC, Phillips GDA (1980). “Algorithm AS154. algorithm exact maximum likelihood estimation autoregressive-moving average models means Kalman filtering.” Applied Statistics, 311--322. R bug report PR#14682 (2011-2013)   <URL: https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=14682>.","code":""},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/arma_Q0gnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the initial state covariance of ARMA model — arma_Q0gnb","text":"","code":"Q0a <- arma_Q0gnb(c(0.2, 0.5), c(0.3))  Q0b <- makeARIMA(c(0.2, 0.5), c(0.3), Delta = numeric(0))$Pn all.equal(Q0a, Q0b) ## TRUE #> [1] TRUE  ## see test/testthat/test-arma-q0.R for more; ## these functions cannot be defined in the package due to their use of ## \\code{:::} on exported base R functions. ## ## \"Gardner1980\" arma_Q0Gardner <- function(phi, theta, tol = .Machine$double.eps){     ## tol is not used here     .Call(stats:::C_getQ0, phi, theta) } ## \"Rossignol2011\" arma_Q0bis <- function(phi, theta, tol = .Machine$double.eps){     .Call(stats:::C_getQ0bis, phi, theta, tol) }  arma_Q0Gardner(c(0.2, 0.5), c(0.3)) #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 arma_Q0bis(c(0.2, 0.5), c(0.3))  #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 Q0a #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778 Q0b #>          [,1]      [,2] #> [1,] 2.111111 1.0222222 #> [2,] 1.022222 0.6177778"},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":null,"dir":"Reference","previous_headings":"","what":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Compute autocovariances ARMA models crosscovariances   ARMA process innovations.","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"","code":"armaccf_xe(model, lag.max = 1) armaacf(model, lag.max, compare)"},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"model model, list components ar, ma     sigma2 (time , sigmasq also accepted,     model$sigma2 NULL). lag.max maximal lag result. compare TRUE compute autocovariances also using     tacvfARMA() return results comparison.","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Given causal ARMA model, armaccf_xe computes theoretical   crosscovariances \\(R_{xe}(0)\\), \\(R_{xe}(1)\\),   \\(R_{xe}(lag.max)\\), \\(R_{xe}(k)=E(X_{t}e_{t-k})\\),   ARMA process innovations. Negative lags considered   since \\(R_{xe}(k)=0\\) \\(k<0\\). moving average polynomial   may roots unit circle. simple illustration equations give time   series courses. armaacf computes ARMA autocovariances. default method   computes computes zero lag autocovariance using   armaccf_xe() multiplies autocorrelations obtained   ARMAacf (computes autocorrelations,   autocovariances). compare = TRUE also uses   tacvfARMA package ltsa returns results   matrix comparison. matrix columns \"native\",   \"tacvfARMA\" \"difference\", last column   contains (zapped) differences autocorrelations   obtained two methods. ARMA parameters argument model follow   Brockwell-Davis convention signs. Since tacvfARMA()   uses Box-Jenkins convention signs, moving average   parameters negated calls tacvfARMA().","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"armaccf_xe, crosscovariances lags 0, ..., maxlag. armaacf, autocovariances, see Details.","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"McLeod AI, Yu H, Krougly Z (2007). “Algorithms Linear Time Series Analysis: R Package.” Journal Statistical Software, 23(5). doi:10.18637/jss.v023.i05 .","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"armaacf useful exploratory computations   autocovariances convenient eliminates   need know function names particular cases.","code":""},{"path":"https://geobosh.github.io/sarima/reference/armaccf_xe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crosscovariances between an ARMA process and its innovations — armaccf_xe","text":"","code":"## Example 1 from ?ltsa::tacvfARMA z <- sqrt(sunspot.year) n <- length(z) p <- 9 q <- 0 ML <- 5 out <- arima(z, order = c(p, 0, q))  phi <- theta <- numeric(0) if (p > 0) phi <- coef(out)[1:p] if (q > 0) theta <- coef(out)[(p+1):(p+q)] zm <- coef(out)[p+q+1] sigma2 <- out$sigma2  armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20) #>          0          1          2          3          4          5          6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>          7          8          9         10         11         12         13  #> -1.5271174  1.2132068  4.1082578  6.0479060  6.3673284  4.9897294  2.5321902  #>         14         15         16         17         18         19         20  #> -0.1699738 -2.2803602 -3.1718781 -2.6404447 -0.9043874  1.4099559  3.5163219  ## this illustrates that the methods ## based on ARMAacf and tacvARMA are equivalent: armaacf(list(ar = phi, ma = theta, sigma2 = sigma2), lag.max = 20, compare = TRUE) #>        native  tacvfARMA difference #> 0   9.0416079  9.0416079          0 #> 1   7.5475908  7.5475908          0 #> 2   4.3845239  4.3845239          0 #> 3   0.8271273  0.8271273          0 #> 4  -1.9801678 -1.9801678          0 #> 5  -3.4909677 -3.4909677          0 #> 6  -3.3114507 -3.3114507          0 #> 7  -1.5271174 -1.5271174          0 #> 8   1.2132068  1.2132068          0 #> 9   4.1082578  4.1082578          0 #> 10  6.0479060  6.0479060          0 #> 11  6.3673284  6.3673284          0 #> 12  4.9897294  4.9897294          0 #> 13  2.5321902  2.5321902          0 #> 14 -0.1699738 -0.1699738          0 #> 15 -2.2803602 -2.2803602          0 #> 16 -3.1718781 -3.1718781          0 #> 17 -2.6404447 -2.6404447          0 #> 18 -0.9043874 -0.9043874          0 #> 19  1.4099559  1.4099559          0 #> 20  3.5163219  3.5163219          0  ## In the original example in ?ltsa::tacvfARMA ## the comparison is with var(z), not with the theoretical variance: rA <- ltsa::tacvfARMA(phi, - theta, maxLag=n+ML-1, sigma2=sigma2) rB <- var(z) * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1) ## so rA and rB are different. ## but the difference is due to the variance: rB2 <- rA[1] * ARMAacf(ar=phi, ma=theta, lag.max=n+ML-1) cbind(rA[1:5], rB[1:5], rB2[1:5]) #>         [,1]       [,2]       [,3] #> 0  9.0416079  8.4034699  9.0416079 #> 1  7.5475908  7.0148975  7.5475908 #> 2  4.3845239  4.0750733  4.3845239 #> 3  0.8271273  0.7687504  0.8271273 #> 4 -1.9801678 -1.8404116 -1.9801678  ## There is no need to use specific functions, ## autocovariances() is most convenient for routine use: armalist <- list(ar = phi, ma = theta, sigma2 = sigma2) autocovariances(armalist, maxlag = 10) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>      Lag_7      Lag_8      Lag_9     Lag_10  #> -1.5271174  1.2132068  4.1082578  6.0479060   ## even better, set up an ARMA model: mo <- new(\"ArmaModel\", ar = phi, ma = theta, sigma2 = sigma2) autocovariances(mo, maxlag = 10) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  9.0416079  7.5475908  4.3845239  0.8271273 -1.9801678 -3.4909677 -3.3114507  #>      Lag_7      Lag_8      Lag_9     Lag_10  #> -1.5271174  1.2132068  4.1082578  6.0479060"},{"path":"https://geobosh.github.io/sarima/reference/as.SarimaModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert S3 model objects to class SarimaModel — as.SarimaModel","title":"Convert S3 model objects to class SarimaModel — as.SarimaModel","text":"Convert S3 model objects class SarimaModel.","code":""},{"path":"https://geobosh.github.io/sarima/reference/as.SarimaModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert S3 model objects to class SarimaModel — as.SarimaModel","text":"","code":"as.SarimaModel(x, ...)  # S3 method for Arima as.SarimaModel(x, ...)"},{"path":"https://geobosh.github.io/sarima/reference/as.SarimaModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert S3 model objects to class SarimaModel — as.SarimaModel","text":"x objects class representing Seasonal ARIMA models. ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/as.SarimaModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert S3 model objects to class SarimaModel — as.SarimaModel","text":"function can useful one needs manipulate   components SARIMA models. method class Arima (objects generated stats::arima())   extracts model information convert \"SarimaModel\". S4 classes, methods (),   suitable. modelCoef provides powerful conversion   mechanism.","code":""},{"path":"https://geobosh.github.io/sarima/reference/as.SarimaModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert S3 model objects to class SarimaModel — as.SarimaModel","text":"object class \"SarimaModel\"","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function autocorrelations() — autocorrelations-methods","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"Methods function autocorrelations().","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"signature(x = \"\", maxlag = \"\", lag_0 = \"\")  signature(x = \"\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"Autocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"Autocorrelations\", maxlag = \"missing\", lag_0 = \"missing\")  signature(x = \"Autocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"SamplePartialAutocorrelations\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"SamplePartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"VirtualArmaModel\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"VirtualSarimaModel\", maxlag = \"\", lag_0 = \"missing\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function autocorrelations() — autocorrelations-methods","text":"","code":"## see the examples for ?autocorrelations"},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute autocorrelations and related quantities — autocorrelations","title":"Compute autocorrelations and related quantities — autocorrelations","text":"Generic functions computation autocorrelations,   autocovariances related quantities. idea free user   need look specific functions compute desired   property object.","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute autocorrelations and related quantities — autocorrelations","text":"","code":"autocovariances(x, maxlag, ...)  autocorrelations(x, maxlag, lag_0, ...)  partialAutocorrelations(x, maxlag, lag_0 = TRUE, ...)  partialAutocovariances(x, maxlag, ...)  partialVariances(x, ...)"},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute autocorrelations and related quantities — autocorrelations","text":"x object requested property makes sense. maxlag maximal lag include result. lag_0 TRUE include lag zero. ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute autocorrelations and related quantities — autocorrelations","text":"autocorrelations generic function computation   autocorrelations.  deduces appropriate type autocorrelation   class object.  example, models computes   theoretical autocorrelations, time series computes sample   autocorrelations. functions described similar second order   properties x. functions return objects suitable classes, inheriting   \"Lagged\". latter means indexing starts zero,   value lag zero accessed r[0]). Subscripting   always returns underlying data unclassed (.e. ordinary vectors   arrays). particular, \"[]\" extracts underlying data. Functions computing autocorrelations partial autocorrelations   argument lag_0 --- set FALSE, value   lag zero dropped result returned object   ordinary vector array, appropriate. See individual methods format result   details. plot methods sample autocorrelations sample partial   autocorrelations overlaid significance limits null   hypotheses independence weak white noise, see   plot-methods examples . details can   found vignettes, see section ‘See also’ .","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute autocorrelations and related quantities — autocorrelations","text":"object class suitable requested property x","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute autocorrelations and related quantities — autocorrelations","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/autocorrelations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute autocorrelations and related quantities — autocorrelations","text":"","code":"set.seed(1234) v1 <- rnorm(100) autocorrelations(v1) #> An object of class \"SampleAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.12957682  0.04402061  0.06106303  0.05826444  0.11109644  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10      Lag_11  #>  0.13135298  0.26913701 -0.08548724  0.12722915 -0.01484862 -0.01438639  #>      Lag_12      Lag_13      Lag_14      Lag_15      Lag_16      Lag_17  #>  0.09282460  0.11136127  0.04431534 -0.14147363 -0.02991080 -0.02545693  #>      Lag_18      Lag_19      Lag_20  #>  0.11824060 -0.01218368 -0.10847365  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x v1.acf <- autocorrelations(v1, maxlag = 10)  v1.acf[1:10] # drop lag zero value (and the class) #>  [1]  0.12957682  0.04402061  0.06106303  0.05826444  0.11109644  0.13135298 #>  [7]  0.26913701 -0.08548724  0.12722915 -0.01484862 autocorrelations(v1, maxlag = 10, lag_0 = FALSE) # same #>  [1]  0.12957682  0.04402061  0.06106303  0.05826444  0.11109644  0.13135298 #>  [7]  0.26913701 -0.08548724  0.12722915 -0.01484862  partialAutocorrelations(v1) #> An object of class \"SamplePartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.12957682  0.02769547  0.05285558  0.04377385  0.09714201  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10      Lag_11  #>  0.10383731  0.24233653 -0.16783708  0.14648145 -0.10189429 -0.02638830  #>      Lag_12      Lag_13      Lag_14      Lag_15      Lag_16      Lag_17  #>  0.04045013  0.07193251 -0.04576705 -0.10297684 -0.09458730  0.04627240  #>      Lag_18      Lag_19      Lag_20  #>  0.09892282 -0.08337618 -0.11082180  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(v1, maxlag = 10) #> An object of class \"SamplePartialAutocorrelations\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  1.00000000  0.12957682  0.02769547  0.05285558  0.04377385  0.09714201  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #>  0.10383731  0.24233653 -0.16783708  0.14648145 -0.10189429  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from raw data autocovariances(v1) #> An object of class \"SampleAutocovariances\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  0.99874171  0.12941377  0.04396522  0.06098619  0.05819112  0.11095664  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10      Lag_11  #>  0.13118770  0.26879836 -0.08537967  0.12706906 -0.01482994 -0.01436829  #>      Lag_12      Lag_13      Lag_14      Lag_15      Lag_16      Lag_17  #>  0.09270780  0.11122115  0.04425957 -0.14129562 -0.02987317 -0.02542490  #>      Lag_18      Lag_19      Lag_20  #>  0.11809182 -0.01216835 -0.10833715  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x autocovariances(v1, maxlag = 10) #> An object of class \"SampleAutocovariances\" #>       Lag_0       Lag_1       Lag_2       Lag_3       Lag_4       Lag_5  #>  0.99874171  0.12941377  0.04396522  0.06098619  0.05819112  0.11095664  #>       Lag_6       Lag_7       Lag_8       Lag_9      Lag_10  #>  0.13118770  0.26879836 -0.08537967  0.12706906 -0.01482994  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(v1, maxlag = 6) #> An object of class \"SamplePartialAutocovariances\" #>          0          1          2          3          4          5          6  #> 0.99874171 0.12724089 0.02717533 0.05171803 0.04274969 0.09397397 0.09936784  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(v1) #> An object of class \"SamplePartialAutocovariances\" #>           0           1           2           3           4           5  #>  0.99874171  0.12724089  0.02717533  0.05171803  0.04274969  0.09397397  #>           6           7           8           9          10          11  #>  0.09936784  0.21828652 -0.14692191  0.12547617 -0.08637655 -0.02235398  #>          12          13          14          15          16          17  #>  0.03420994  0.06052078 -0.03842568 -0.08554178 -0.07786971  0.03801254  #>          18          19          20  #>  0.08046935 -0.06735137 -0.08842251  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(v1, maxlag = 6) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 0.9987417 0.9819727 0.9812195 0.9784782 0.9766033 0.9673875 0.9569570  #> Slot n: #> [1] 100 #> Slot varnames:   <not set> #> Slot objectname:  x pv1 <- partialVariances(v1)  ## compute 2nd order properties from raw data autocovariances(AirPassengers, maxlag = 6) #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 14291.973 13549.467 12513.692 11529.066 10756.502 10201.181  9743.318  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x autocorrelations(AirPassengers, maxlag = 6) #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialAutocovariances\" #>           0           1           2           3           4           5  #> 14291.97333  1371.29064  -314.37784    52.19801   127.19886    99.29006  #>           6  #>    10.42335  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(AirPassengers, maxlag = 6) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 14291.973  1446.437  1370.305  1368.310  1356.275  1348.927  1348.846  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  acv <- autocovariances(AirPassengers, maxlag = 6) autocovariances(acv) # no-op #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 14291.973 13549.467 12513.692 11529.066 10756.502 10201.181  9743.318  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x autocovariances(acv, maxlag = 4) # trim the available lags #> An object of class \"SampleAutocovariances\" #>    Lag_0    Lag_1    Lag_2    Lag_3    Lag_4  #> 14291.97 13549.47 12513.69 11529.07 10756.50  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from sample autocovariances acr <- autocorrelations(acv) acr #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(acv) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocovariances(acv) #> An object of class \"SamplePartialAutocovariances\" #>           0           1           2           3           4           5  #> 14291.97333  1371.29064  -314.37784    52.19801   127.19886    99.29006  #>           6  #>    10.42335  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialVariances(acv) #> An object of class \"SamplePartialVariances\" #>         0         1         2         3         4         5         6  #> 14291.973  1446.437  1370.305  1368.310  1356.275  1348.927  1348.846  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## compute 2nd order properties from sample autocorrelations acr #> An object of class \"SampleAutocorrelations\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x partialAutocorrelations(acr) #> An object of class \"SamplePartialAutocorrelations\" #>        Lag_0        Lag_1        Lag_2        Lag_3        Lag_4        Lag_5  #>  1.000000000  0.948047341 -0.229421874  0.038147781  0.093785438  0.073606698  #>        Lag_6  #>  0.007727603  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  ## These cannot be computed, since the variance is needed but unknown: ##     autocovariances(acr) ##     partialAutocovariances(acr) ##     partialVariances(acr)  ## to treat autocorrelations as autocovariances,  ## convert them to autocovariances explicitly: as(acr, \"Autocovariances\") #> An object of class \"Autocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  as(acr, \"SampleAutocovariances\") #> An object of class \"SampleAutocovariances\" #>     Lag_0     Lag_1     Lag_2     Lag_3     Lag_4     Lag_5     Lag_6  #> 1.0000000 0.9480473 0.8755748 0.8066812 0.7526254 0.7137700 0.6817336  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x  partialVariances(as(acr, \"Autocovariances\")) #> An object of class \"PartialVariances\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.10120624 0.09587931 0.09573978 0.09489768 0.09438353 0.09437790  partialVariances(as(acr, \"SampleAutocovariances\")) #> An object of class \"SamplePartialVariances\" #>          0          1          2          3          4          5          6  #> 1.00000000 0.10120624 0.09587931 0.09573978 0.09489768 0.09438353 0.09437790  #> Slot n: #> [1] 144 #> Slot varnames:   <not set> #> Slot objectname:  x"},{"path":"https://geobosh.github.io/sarima/reference/autocovariances-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function autocovariances() — autocovariances-methods","title":"Methods for function autocovariances() — autocovariances-methods","text":"Methods function autocovariances().","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocovariances-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function autocovariances() — autocovariances-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/autocovariances-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function autocovariances() — autocovariances-methods","text":"signature(x = \"\", maxlag = \"\")  signature(x = \"Autocovariances\", maxlag = \"\")  signature(x = \"Autocovariances\", maxlag = \"missing\")  signature(x = \"VirtualArmaModel\", maxlag = \"\")  signature(x = \"VirtualAutocovariances\", maxlag = \"\")","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/autocovariances-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function autocovariances() — autocovariances-methods","text":"","code":"## see the examples for ?autocorrelations"},{"path":"https://geobosh.github.io/sarima/reference/coerce-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"setAs methods in package sarima — coerce-methods","title":"setAs methods in package sarima — coerce-methods","text":"Methods () package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/coerce-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"setAs methods in package sarima — coerce-methods","text":"section shows methods converting objects one class   another, defined via setAs(). Use (obj, \"classname\")   convert object obj class \"classname\". signature(= \"\", = \"Autocorrelations\")  signature(= \"\", = \"ComboAutocorrelations\")  signature(= \"\", = \"ComboAutocovariances\")  signature(= \"\", = \"PartialAutocorrelations\")  signature(= \"\", = \"PartialAutocovariances\")  signature(= \"\", = \"PartialVariances\")  signature(= \"ArmaSpec\", = \"list\")  signature(= \"Autocorrelations\", = \"ComboAutocorrelations\")  signature(= \"Autocorrelations\", = \"ComboAutocovariances\")  signature(= \"Autocovariances\", = \"ComboAutocorrelations\")  signature(= \"Autocovariances\", = \"ComboAutocovariances\")  signature(= \"BJFilter\", = \"SPFilter\")  signature(= \"numeric\", = \"BJFilter\") Convert numeric vector BJFilter object.   way state coefficients follow Box-Jenkins   convention signs, see examples. signature(= \"numeric\", = \"SPFilter\") Convert numeric vector SPFilter object.  way   state coefficients follow signal processing (SP)   convention signs, see examples. signature(= \"PartialVariances\", = \"Autocorrelations\")  signature(= \"PartialVariances\", = \"Autocovariances\")  signature(= \"PartialVariances\", = \"ComboAutocorrelations\")  signature(= \"PartialVariances\", = \"ComboAutocovariances\")  signature(= \"SarimaFilter\", = \"ArmaFilter\")  signature(= \"SarimaModel\", = \"list\")  signature(= \"SPFilter\", = \"BJFilter\")  signature(= \"vector\", = \"Autocorrelations\")  signature(= \"vector\", = \"Autocovariances\")  signature(= \"vector\", = \"PartialAutocorrelations\")  signature(= \"vector\", = \"PartialAutocovariances\")  signature(= \"VirtualArmaFilter\", = \"list\")  signature(= \"VirtualSarimaModel\", = \"ArmaModel\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/coerce-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"setAs methods in package sarima — coerce-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/coerce-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"setAs methods in package sarima — coerce-methods","text":"","code":"## the default for ARMA model is BJ for ar and SP for ma: mo <- new(\"ArmaModel\", ar = 0.9, ma = 0.4, sigma2 = 1) modelPoly(mo) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>   ## here we declare explicitly that 0.4 uses the SP convention ##    (not necessary, the result is the same, but the intention is clear). mo1 <- new(\"ArmaModel\", ar = 0.9, ma = as(0.4, \"SPFilter\"), sigma2 = 1) modelPoly(mo1) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo1) ## TRUE #> [1] TRUE  ## if the sign of theta follows the BJ convention, this can be stated unambiguously. ##   This creates the same model: mo2 <- new(\"ArmaModel\", ar = 0.9, ma = as(-0.4, \"BJFilter\"), sigma2 = 1) modelPoly(mo2) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo2) ## TRUE #> [1] TRUE  ## And this gives the intended model whatever the default conventions: ar3 <- as(0.9, \"BJFilter\") ma3 <- as(-0.4, \"BJFilter\") mo3 <- new(\"ArmaModel\", ar = ar3, ma = ma3, sigma2 = 1) modelPoly(mo3) #> $ar #> 1 - 0.9*x  #>  #> $ma #> 1 + 0.4*x  #>  identical(mo, mo3) ## TRUE #> [1] TRUE  ## The coefficients can be extracted in any particular form, ## e.g. to pass them to functions with specific requirements: modelCoef(mo3) # coefficients of the model with the default (BD) sign convention #> $ar #> [1] 0.9 #>  #> $ma #> [1] 0.4 #>  modelCoef(mo3, convention = \"BD\") # same result #> $ar #> [1] 0.9 #>  #> $ma #> [1] 0.4 #>  modelCoef(mo3, convention = \"SP\") # signal processing convention #> $ar #> [1] -0.9 #>  #> $ma #> [1] 0.4 #>    ## for ltsa::tacvfARMA() the convention is BJ, so: co <- modelCoef(mo3, convention = \"BJ\") # Box-Jenkins convention  ltsa::tacvfARMA(co$ar, co$ma, maxLag = 6, sigma2 = 1) #> [1] 9.894737 9.305263 8.374737 7.537263 6.783537 6.105183 5.494665 autocovariances(mo3, maxlag = 6) ## same #> An object of class \"Autocovariances\" #>    Lag_0    Lag_1    Lag_2    Lag_3    Lag_4    Lag_5    Lag_6  #> 9.894737 9.305263 8.374737 7.537263 6.783537 6.105183 5.494665"},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence and acceptance intervals in package sarima — confint","title":"Confidence and acceptance intervals in package sarima — confint","text":"Compute confidence acceptance intervals sample   autocorrelations assumptions chosen user.","code":""},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence and acceptance intervals in package sarima — confint","text":"","code":"# S4 method for SampleAutocorrelations confint(object, parm, level = 0.95, se = FALSE, maxlag, ..., assuming)"},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence and acceptance intervals in package sarima — confint","text":"object object containing sample autocorrelations (sacfs). parm parameters include, stats::confint. level coverage level, 0.95. se TRUE return also standard errors. assuming assumptions computations?     Currently can \"iid\", \"garch\", fitted model,     theoretical model, see Details.  maxlag maximal lag include ... arguments se.","code":""},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Confidence and acceptance intervals in package sarima — confint","text":"lags fixed assumed model computed intervals   confidence intervals. autocorrelations postulated null model (argument   assuming) usually fixed lags. lags   make sense talk confidence intervals.  use   term acceptance interval case since sacfs   lags fall corresponding intervals high probability   null model correct. assuming \"iid\" (strong white noise),   autocorrelations null model fixed (zero) limits   resulting acceptance intervals ethose familiar   plots produced base-R's function acf. assuming fitted MA(q) model, e.g. obtained   arima(), lags \\(1,\\ldots,q\\) get   confidence intervals, lags greater \\(q\\)   intervals acceptance intervals. autocorrelations ARMA models non-trivial autoregressive   part may also structural patterns zeroes (example   seasonal models), leading acceptance intervals lags. assuming specifies theoretical (non-fitted) model,   autocorrelation function null model completely fixed   get acceptance intervals lags. return value matrix one row requested lag,   containg lag, lower bound, upper bound, estimate acf(lag)   value acf(lag) H0 (fixed) NA fixed   H0. null model stored attribute \"assuming\". Note: assuming = \"garch\" currently   necessary submit time series autocorrelations   computed argument x.","code":""},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence and acceptance intervals in package sarima — confint","text":"matrix described section ‘Details’; se = TRUE, column giving standard errors sample   autocorrelations appended.","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/confint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence and acceptance intervals in package sarima — confint","text":"","code":"set.seed(1234) v1 <- arima.sim(n = 100, list(ma = c(0.8, 0.1), sd = 1)) v1.acf <- autocorrelations(v1, maxlag = 10)  confint(v1.acf, parm = 1:4, assuming = \"iid\") #>       Lag      2.5 %    97.5 %  Estimate H0_fixed #> Lag_1   1 -0.1959964 0.1959964 0.6194318        0 #> Lag_2   2 -0.1959964 0.1959964 0.1960955        0 #> Lag_3   3 -0.1959964 0.1959964 0.1071118        0 #> Lag_4   4 -0.1959964 0.1959964 0.1348527        0 #> attr(,\"assuming\") #> [1] \"iid\" confint(v1.acf,  assuming = \"iid\", maxlag = 4) # same #>       Lag      2.5 %    97.5 %  Estimate H0_fixed #> Lag_1   1 -0.1959964 0.1959964 0.6194318        0 #> Lag_2   2 -0.1959964 0.1959964 0.1960955        0 #> Lag_3   3 -0.1959964 0.1959964 0.1071118        0 #> Lag_4   4 -0.1959964 0.1959964 0.1348527        0 #> attr(,\"assuming\") #> [1] \"iid\"  ## a fitted MA(2) - rho_1, rho_2 not fixed, the rest fixed ma2fitted <- arima(v1, order = c(0,0,2), include.mean=FALSE) confint(v1.acf, assuming = ma2fitted, maxlag = 4) #>       Lag       2.5 %    97.5 %  Estimate H0_fixed #> Lag_1   1  0.48912998 0.7497336 0.6194318       NA #> Lag_2   2 -0.04684288 0.4390339 0.1960955       NA #> Lag_3   3 -0.24926724 0.2492672 0.1071118        0 #> Lag_4   4 -0.24926724 0.2492672 0.1348527        0 #> attr(,\"assuming\") #>  #> Call: #> arima(x = v1, order = c(0, 0, 2), include.mean = FALSE) #>  #> Coefficients: #>          ma1     ma2 #>       0.9902  0.1126 #> s.e.  0.0884  0.0910 #>  #> sigma^2 estimated as 0.9474:  log likelihood = -139.99,  aic = 285.99  ## a theoretical MA(2) model, all acfs fixed under H0 ma2 <- MaModel(ma = c(0.8, 0.1), sigma2 = 1) confint(v1.acf, assuming = ma2, maxlag = 4) #>       Lag      2.5 %    97.5 %  Estimate H0_fixed #> Lag_1   1  0.7463301 1.0136699 0.6194318     0.88 #> Lag_2   2 -0.1394966 0.3394966 0.1960955     0.10 #> Lag_3   3 -0.2460700 0.2460700 0.1071118     0.00 #> Lag_4   4 -0.2460700 0.2460700 0.1348527     0.00 #> attr(,\"assuming\") #> An object of class \"MaModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  0  #> Coefficients:  #> numeric(0) #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  2  #> Coefficients:  #> [1] 0.8 0.1  # a weak white noise null confint(v1.acf, assuming = \"garch\", maxlag = 4, x = v1) #>       Lag      2.5 %    97.5 %  Estimate H0_fixed #> Lag_1   1 -0.2414976 0.2414976 0.6194318        0 #> Lag_2   2 -0.1919697 0.1919697 0.1960955        0 #> Lag_3   3 -0.1882971 0.1882971 0.1071118        0 #> Lag_4   4 -0.1626543 0.1626543 0.1348527        0 #> attr(,\"assuming\") #> [1] \"garch\""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterCoef() — filterCoef-methods","title":"Methods for filterCoef() — filterCoef-methods","text":"Methods filterCoef package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterCoef() — filterCoef-methods","text":"filterCoef() returns coefficients object.   format result depends type filter, see   descriptions individual methods . argument convention omitted, sign convention   coefficients one used object. convention can   set \"BJ\" \"SP\" request, respectively, Box-Jenkins   signal processing convention. Also, \"-\" equivalent \"BJ\" \"+\"   \"SP\". ARMA filters, \"BJ\" \"SP\" request corresponding convention   parts (AR MA). widely used convention, e.g., base R   (Brockwell Davis 1991) , \"BJ\" AR part   \"SP\" MA part.  can requested convention =   \"BD\".  convenience, \"--\" equivalent \"BJ\", \"++\" \"SP\",   \"-+\" \"BD\". completeness, \"+-\" can used request \"SP\"   AR part \"BJ\" MA part. Invalid values convention throw error. particular, low   level filters, \"BJFilter\" know AR MA,   throw error convention \"BD\" \"+-\" (\"++\"   \"--\" ok, since unambiguous). Similarly avoid   subtle errors, ARMA filters accept \"+\" \"-\".  signature(object = \"VirtualMonicFilterSpec\", convention = \"missing\") returns  object@coef. signature(object = \"VirtualBJFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"VirtualSPFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"BJFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"SPFilter\", convention = \"character\") returns filter coefficients requested convention. signature(object = \"VirtualArmaFilter\", convention = \"missing\")  signature(object = \"VirtualArmaFilter\", convention = \"character\") Conceptually, calls filterCoef(), one argument,       AR MA parts model. convention present,       converts result specified convention.  Returns list       following components: ar AR coefficients. ma MA coefficients.  signature(object = \"SarimaFilter\", convention = \"missing\")  signature(object = \"SarimaFilter\", convention = \"character\") convention present, converts coefficients       specified convention. AR-like coefficients get convention       AR part, Ma-like coefficients get convention MA       part. Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) \t  differences. siorder seasonal integration order, number seasonal \t  differences. ar ar coefficients. ma ma coefficients. sar seasonal ar coefficients. sma seasonal ma coefficients.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterCoef() — filterCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef-methods.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Methods for filterCoef() — filterCoef-methods","text":"Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag..","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/filterCoef-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterCoef() — filterCoef-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients and other basic properties of filters — filterCoef","title":"Coefficients and other basic properties of filters — filterCoef","text":"Coefficients basic properties filters.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients and other basic properties of filters — filterCoef","text":"","code":"filterCoef(object, convention, ...)  filterOrder(object, ...)  filterPoly(object, ...)  filterPolyCoef(object, lag_0 = TRUE, ...)"},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients and other basic properties of filters — filterCoef","text":"object object. convention convention sign. lag_0 FALSE, drop coefficient order zero. ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coefficients and other basic properties of filters — filterCoef","text":"Generic functions extract basic properties filters:   filterCoef returns coefficients,   filterOrder returns order,   filterPoly, returns characteristic polynomial,   filterPolyCoef gives coefficients characteristic   polynomial. details argument convention see    filterCoef-methods. exactly returned depends specific filter classes, see   description corresponding methods. core filters,   values can expected. \"ArmaFilter\", value   list components \"ar\" \"ma\" giving requested property   corresponding part filter. Similarly, \"SarimaFilter\"   values lists, maybe additional quantities.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients and other basic properties of filters — filterCoef","text":"requested property described Details.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Coefficients and other basic properties of filters — filterCoef","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Coefficients and other basic properties of filters — filterCoef","text":"filterXXX() functions somewhat low level   technical. rarely needed routine work.   corresponding modelXXX flexible.","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/filterCoef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients and other basic properties of filters — filterCoef","text":"","code":"filterPoly(as(c(0.3, 0.5), \"BJFilter\"))   # 1 - 0.3*x - 0.5*x^2 #> 1 - 0.3*x - 0.5*x^2  filterPoly(as(c(0.3, 0.5), \"SPFilter\"))   # 1 + 0.3*x + 0.5*x^2 #> 1 + 0.3*x + 0.5*x^2   ## now two representations of the same filter: fi1 <- as(c(0.3, 0.5), \"BJFilter\") fi2 <- as(c(-0.3, -0.5), \"SPFilter\") identical(fi2, fi1) # FALSE, but #> [1] FALSE ## fi1 and fi2 represent the same filter, eg. same ch. polynomials: filterPoly(fi1) #> 1 - 0.3*x - 0.5*x^2  filterPoly(fi2) #> 1 - 0.3*x - 0.5*x^2  identical(filterPolyCoef(fi2), filterPolyCoef(fi1)) #> [1] TRUE  # same as above, using new() fi1a <- new(\"BJFilter\", coef = c(0.3, 0.5)) identical(fi1a, fi1) # TRUE #> [1] TRUE  fi2a <- new(\"SPFilter\", coef = c(-0.3, -0.5)) identical(fi2a, fi2) # TRUE #> [1] TRUE  ## conversion by as() changes the internal representation ## but represents the same filter: identical(as(fi1, \"SPFilter\"), fi2) # TRUE #> [1] TRUE  c(filterOrder(fi1), filterOrder(fi2)) #> [1] 2 2  ## these give the internally stored coefficients: filterCoef(fi1) #> [1] 0.3 0.5 filterCoef(fi2) #> [1] -0.3 -0.5  ## with argument 'convention' the result doesn't depend ## on the internal representation: co1 <- filterCoef(fi1, convention = \"SP\") co2 <- filterCoef(fi2, convention = \"SP\") identical(co1, co2) # TRUE #> [1] TRUE"},{"path":"https://geobosh.github.io/sarima/reference/filterOrder-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function filterOrder in package sarima — filterOrder-methods","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"Methods function filterOrder package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterOrder-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"following methods ensure  filters package sarima   method filterOrder. signature(object = \"VirtualMonicFilterSpec\") Returns object@order. signature(object = \"SarimaFilter\") Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) differences. siorder seasonal integration order, number seasonal \tdifferences. ar autoregression order ma moving average order sar seasonal autoregression order sma seasonal moving average order  signature(object = \"VirtualArmaFilter\") Returns list following components: ar autoregression order. ma moving average order.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterOrder-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/filterOrder-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for function filterOrder in package sarima — filterOrder-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"https://geobosh.github.io/sarima/reference/filterPoly-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterPoly in package sarima — filterPoly-methods","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"Methods filterPoly package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterPoly-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"methods filterPoly take care implicitly sign   convention used store coefficients object.  signature(object = \"BJFilter\") polynomial whose coefficients negated filter       coefficients. signature(object = \"SPFilter\") polynomial whose coefficients stored object. signature(object = \"SarimaFilter\") Returns list following components: nseasons number seasons. iorder integration order, number (non-seasonal) \t  differences. siorder seasonal integration order, number seasonal \t  differences. arpoly autoregression polynomial mapoly moving average polynomial sarpoly seasonal autoregression polynomial smapoly seasonal moving average polynomial fullarpoly polynomial obtained multiplying \t  AR-like terms, including differences. fullmapoly polynomial obtained multiplying \t  MA terms core_sarpoly core seasonal autoregression polynomial. \t  sarpoly(\\(z\\)) = core_sarpoly(\\(z^{nseasons}\\)) core_smapoly core seasonal moving average polynomial. \t  smapoly(\\(z\\)) = core_smapoly(\\(z^{nseasons}\\))  signature(object = \"VirtualArmaFilter\") Returns list following components: ar autoregression polynomial. ma moving average polynomial.  signature(object = \"VirtualMonicFilterSpec\") Calls filterPolyCoef(object) converts result       polynomial. Thus, sufficient method       filterPolyCoef().","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterPoly-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/filterPoly-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterPoly in package sarima — filterPoly-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"https://geobosh.github.io/sarima/reference/filterPolyCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for filterPolyCoef — filterPolyCoef-methods","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"Methods filterPolyCoef package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterPolyCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"filterPolyCoef methods return results   structure corresponding methods filterPoly   polynomials replaced coefficients. lag_0   FALSE order 0 coefficients dropped. signature(object = \"VirtualBJFilter\") Calls filterCoef(object), negates result prepends 1     lag_0 TRUE. signature(object = \"VirtualSPFilter\") Calls filterCoef(object) prepends 1 result     lag_0 TRUE. signature(object = \"VirtualArmaFilter\") Returns list following components: ar coefficients autoregression polynomial. ma coefficients moving average polynomial.  signature(object = \"BJFilter\") coefficients polynomial whose coefficients negated     filter coefficients. equivalent method     \"VirtualBJFilter\" somewhat efficient. signature(object = \"SPFilter\") coefficients polynomial whose coefficients stored     object. equivalent method \"VirtualSPFilter\"     somewhat efficient. signature(object = \"SarimaFilter\") Returns list components \"SarimaFilter\" method     filterPoly, polynomials replaced     coefficients.","code":""},{"path":"https://geobosh.github.io/sarima/reference/filterPolyCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/filterPolyCoef-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for filterPolyCoef — filterPolyCoef-methods","text":"","code":"## see the examples for ?filterCoef"},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":null,"dir":"Reference","previous_headings":"","what":"Forecasting functions for seasonal ARIMA models — fun.forecast","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"Forecasting functions seasonal ARIMA models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"","code":"fun.forecast(past, n = max(2 * length(past), 12), eps = numeric(n), pasteps, ...)"},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"past past values time series, default zeroes. n number forecasts compute. eps values white noise sequence (simulation      future). Currently used! pasteps past values white noise sequence models     MA terms, 0 default. ... specification model, passed new()     create \"SarimaModel\" object, see Details.","code":""},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"fun.forecast computes predictions SARIMA model.    model specified using \"...\" arguments passed   new(\"SarimaModel\", ...), see description class   \"SarimaModel\" details. Argument past, provided, contain least many values   needed prediction equation. harmless provide   values necessary, even whole time series. fun.forecast can used illustrate, example,   inherent difference prediction integrated seasonally   integrated models corresponding models roots close unit   circle.","code":""},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"forecasts object class \"ts\"","code":""},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/fun.forecast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forecasting functions for seasonal ARIMA models — fun.forecast","text":"","code":"f1 <- fun.forecast(past = 1, n = 100, ar = c(0.85), center = 5) plot(f1)   f2 <- fun.forecast(past = 8, n = 100, ar = c(0.85), center = 5) plot(f2)   f3 <- fun.forecast(past = 10, n = 100, ar = c(-0.85), center = 5) plot(f3)   frw1 <- fun.forecast(past = 1, n = 100, iorder = 1) plot(frw1)   frw2 <- fun.forecast(past = 3, n = 100, iorder = 1) plot(frw2)   frwa1 <- fun.forecast(past = c(1, 2), n = 100, ar = c(0.85), iorder = 1) plot(frwa1)   fi2a <- fun.forecast(past = c(3, 1), n = 100, iorder = 2) plot(fi2a)   fi2b <- fun.forecast(past = c(1, 3), n = 100, iorder = 2) plot(fi2b)   fari1p2 <- fun.forecast(past = c(0, 1, 3), ar = c(0.9), n = 20, iorder = 2) plot(fari1p2)   fsi1 <- fun.forecast(past = rnorm(4), n = 100, siorder = 1, nseasons = 4) plot(fsi1)   fexa <- fun.forecast(past = rnorm(5), n = 100, ar = c(0.85), siorder = 1,                      nseasons = 4) plot(fexa)   fi2a <- fun.forecast(past = rnorm(24, sd = 5), n = 120, siorder = 2,                      nseasons = 12) plot(fi2a)   fi1si1a <- fun.forecast(past = rnorm(24, sd = 5), n = 120, iorder = 1,                         siorder = 1, nseasons = 12) plot(fi1si1a)   fi1si1a <- fun.forecast(past = AirPassengers[120:144], n = 120, iorder = 1,                         siorder = 1, nseasons = 12) plot(fi1si1a)   m1 <- list(iorder = 1, siorder = 1, ma = 0.8, nseasons = 12, sigma2 = 1) m1 #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ma #> [1] 0.8 #>  #> $nseasons #> [1] 12 #>  #> $sigma2 #> [1] 1 #>  x <- sim_sarima(model = m1, n = 500) acf(diff(diff(x), lag = 12), lag.max = 96)  pacf(diff(diff(x), lag = 12), lag.max = 96)   m2 <- list(iorder = 1, siorder = 1, ma = 0.8, sma = 0.5, nseasons = 12,            sigma2 = 1) m2 #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ma #> [1] 0.8 #>  #> $sma #> [1] 0.5 #>  #> $nseasons #> [1] 12 #>  #> $sigma2 #> [1] 1 #>  x2 <- sim_sarima(model = m2, n = 500) acf(diff(diff(x2), lag = 12), lag.max = 96)  pacf(diff(diff(x2), lag = 12), lag.max = 96)  fit2 <- arima(x2, order = c(0, 1, 1),               seasonal = list(order = c(0, 1, 0), nseasons = 12)) fit2 #>  #> Call: #> arima(x = x2, order = c(0, 1, 1), seasonal = list(order = c(0, 1, 0), nseasons = 12)) #>  #> Coefficients: #>           ma1 #>       -0.9844 #> s.e.   0.0058 #>  #> sigma^2 estimated as 38.83:  log likelihood = -1619.52,  aic = 3243.05 tsdiag(fit2)  tsdiag(fit2, gof.lag = 96)   x2past <- rnorm(13, sd = 10) x2 <- sim_sarima(model = m2, n = 500, x = list(init = x2past)) plot(x2)   fun.forecast(ar = 0.5, n = 100) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(ar = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 5.000000e-01 2.500000e-01 1.250000e-01 6.250000e-02 3.125000e-02 #>   [6] 1.562500e-02 7.812500e-03 3.906250e-03 1.953125e-03 9.765625e-04 #>  [11] 4.882812e-04 2.441406e-04 1.220703e-04 6.103516e-05 3.051758e-05 #>  [16] 1.525879e-05 7.629395e-06 3.814697e-06 1.907349e-06 9.536743e-07 #>  [21] 4.768372e-07 2.384186e-07 1.192093e-07 5.960464e-08 2.980232e-08 #>  [26] 1.490116e-08 7.450581e-09 3.725290e-09 1.862645e-09 9.313226e-10 #>  [31] 4.656613e-10 2.328306e-10 1.164153e-10 5.820766e-11 2.910383e-11 #>  [36] 1.455192e-11 7.275958e-12 3.637979e-12 1.818989e-12 9.094947e-13 #>  [41] 4.547474e-13 2.273737e-13 1.136868e-13 5.684342e-14 2.842171e-14 #>  [46] 1.421085e-14 7.105427e-15 3.552714e-15 1.776357e-15 8.881784e-16 #>  [51] 4.440892e-16 2.220446e-16 1.110223e-16 5.551115e-17 2.775558e-17 #>  [56] 1.387779e-17 6.938894e-18 3.469447e-18 1.734723e-18 8.673617e-19 #>  [61] 4.336809e-19 2.168404e-19 1.084202e-19 5.421011e-20 2.710505e-20 #>  [66] 1.355253e-20 6.776264e-21 3.388132e-21 1.694066e-21 8.470329e-22 #>  [71] 4.235165e-22 2.117582e-22 1.058791e-22 5.293956e-23 2.646978e-23 #>  [76] 1.323489e-23 6.617445e-24 3.308722e-24 1.654361e-24 8.271806e-25 #>  [81] 4.135903e-25 2.067952e-25 1.033976e-25 5.169879e-26 2.584939e-26 #>  [86] 1.292470e-26 6.462349e-27 3.231174e-27 1.615587e-27 8.077936e-28 #>  [91] 4.038968e-28 2.019484e-28 1.009742e-28 5.048710e-29 2.524355e-29 #>  [96] 1.262177e-29 6.310887e-30 3.155444e-30 1.577722e-30 7.888609e-31 fun.forecast(ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(iorder = 1, ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 fun.forecast(iorder = 1, ma = 0.5, ar = 0.8, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 8.000000e-01 6.400000e-01 5.120000e-01 4.096000e-01 3.276800e-01 #>   [6] 2.621440e-01 2.097152e-01 1.677722e-01 1.342177e-01 1.073742e-01 #>  [11] 8.589935e-02 6.871948e-02 5.497558e-02 4.398047e-02 3.518437e-02 #>  [16] 2.814750e-02 2.251800e-02 1.801440e-02 1.441152e-02 1.152922e-02 #>  [21] 9.223372e-03 7.378698e-03 5.902958e-03 4.722366e-03 3.777893e-03 #>  [26] 3.022315e-03 2.417852e-03 1.934281e-03 1.547425e-03 1.237940e-03 #>  [31] 9.903520e-04 7.922816e-04 6.338253e-04 5.070602e-04 4.056482e-04 #>  [36] 3.245186e-04 2.596148e-04 2.076919e-04 1.661535e-04 1.329228e-04 #>  [41] 1.063382e-04 8.507059e-05 6.805647e-05 5.444518e-05 4.355614e-05 #>  [46] 3.484491e-05 2.787593e-05 2.230075e-05 1.784060e-05 1.427248e-05 #>  [51] 1.141798e-05 9.134385e-06 7.307508e-06 5.846007e-06 4.676805e-06 #>  [56] 3.741444e-06 2.993155e-06 2.394524e-06 1.915619e-06 1.532496e-06 #>  [61] 1.225996e-06 9.807971e-07 7.846377e-07 6.277102e-07 5.021681e-07 #>  [66] 4.017345e-07 3.213876e-07 2.571101e-07 2.056881e-07 1.645505e-07 #>  [71] 1.316404e-07 1.053123e-07 8.424983e-08 6.739987e-08 5.391989e-08 #>  [76] 4.313591e-08 3.450873e-08 2.760699e-08 2.208559e-08 1.766847e-08 #>  [81] 1.413478e-08 1.130782e-08 9.046257e-09 7.237006e-09 5.789604e-09 #>  [86] 4.631684e-09 3.705347e-09 2.964277e-09 2.371422e-09 1.897138e-09 #>  [91] 1.517710e-09 1.214168e-09 9.713344e-10 7.770676e-10 6.216540e-10 #>  [96] 4.973232e-10 3.978586e-10 3.182869e-10 2.546295e-10 2.037036e-10  fun.forecast(m1, n = 100) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #> $sigma2 #> [1] 0 #>  #> [[2]] #> [1] 0 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 0 #>  #> [[5]] #> [1] 0 #>  #> [[6]] #> [1] 0 #>  #> [[7]] #> [1] 0 #>  #> [[8]] #> [1] 0 #>  #> [[9]] #> [1] 0 #>  #> [[10]] #> [1] 0 #>  #> [[11]] #> [1] 0 #>  #> [[12]] #> [1] 0 #>  #> [[13]] #> [1] 0 #>  #> [[14]] #> [1] 0 #>  #> [[15]] #> [1] 0 #>  #> [[16]] #> [1] 0 #>  #> [[17]] #> [1] 0 #>  #> [[18]] #> [1] 0 #>  #> [[19]] #> [1] 0 #>  #> [[20]] #> [1] 0 #>  #> [[21]] #> [1] 0 #>  #> [[22]] #> [1] 0 #>  #> [[23]] #> [1] 0 #>  #> [[24]] #> [1] 0 #>  #> [[25]] #> [1] 0 #>  #> [[26]] #> [1] 0 #>  #> [[27]] #> [1] 0 #>  #> [[28]] #> [1] 0 #>  #> [[29]] #> [1] 0 #>  #> [[30]] #> [1] 0 #>  #> [[31]] #> [1] 0 #>  #> [[32]] #> [1] 0 #>  #> [[33]] #> [1] 0 #>  #> [[34]] #> [1] 0 #>  #> [[35]] #> [1] 0 #>  #> [[36]] #> [1] 0 #>  #> [[37]] #> [1] 0 #>  #> [[38]] #> [1] 0 #>  #> [[39]] #> [1] 0 #>  #> [[40]] #> [1] 0 #>  #> [[41]] #> [1] 0 #>  #> [[42]] #> [1] 0 #>  #> [[43]] #> [1] 0 #>  #> [[44]] #> [1] 0 #>  #> [[45]] #> [1] 0 #>  #> [[46]] #> [1] 0 #>  #> [[47]] #> [1] 0 #>  #> [[48]] #> [1] 0 #>  #> [[49]] #> [1] 0 #>  #> [[50]] #> [1] 0 #>  #> [[51]] #> [1] 0 #>  #> [[52]] #> [1] 0 #>  #> [[53]] #> [1] 0 #>  #> [[54]] #> [1] 0 #>  #> [[55]] #> [1] 0 #>  #> [[56]] #> [1] 0 #>  #> [[57]] #> [1] 0 #>  #> [[58]] #> [1] 0 #>  #> [[59]] #> [1] 0 #>  #> [[60]] #> [1] 0 #>  #> [[61]] #> [1] 0 #>  #> [[62]] #> [1] 0 #>  #> [[63]] #> [1] 0 #>  #> [[64]] #> [1] 0 #>  #> [[65]] #> [1] 0 #>  #> [[66]] #> [1] 0 #>  #> [[67]] #> [1] 0 #>  #> [[68]] #> [1] 0 #>  #> [[69]] #> [1] 0 #>  #> [[70]] #> [1] 0 #>  #> [[71]] #> [1] 0 #>  #> [[72]] #> [1] 0 #>  #> [[73]] #> [1] 0 #>  #> [[74]] #> [1] 0 #>  #> [[75]] #> [1] 0 #>  #> [[76]] #> [1] 0 #>  #> [[77]] #> [1] 0 #>  #> [[78]] #> [1] 0 #>  #> [[79]] #> [1] 0 #>  #> [[80]] #> [1] 0 #>  #> [[81]] #> [1] 0 #>  #> [[82]] #> [1] 0 #>  #> [[83]] #> [1] 0 #>  #> [[84]] #> [1] 0 #>  #> [[85]] #> [1] 0 #>  #> [[86]] #> [1] 0 #>  #> [[87]] #> [1] 0 #>  #> [[88]] #> [1] 0 #>  #> [[89]] #> [1] 0 #>  #> [[90]] #> [1] 0 #>  #> [[91]] #> [1] 0 #>  #> [[92]] #> [1] 0 #>  #> [[93]] #> [1] 0 #>  #> [[94]] #> [1] 0 #>  #> [[95]] #> [1] 0 #>  #> [[96]] #> [1] 0 #>  #> [[97]] #> [1] 0 #>  #> [[98]] #> [1] 0 #>  #> [[99]] #> [1] 0 #>  #> [[100]] #> [1] 0 #>  #> [[101]] #> [1] 0 #>  fun.forecast(m2, n = 100) #> Time Series: #> Start = 1  #> End = 101  #> Frequency = 1  #> $sigma2 #> [1] 0 #>  #> [[2]] #> [1] 0 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 0 #>  #> [[5]] #> [1] 0 #>  #> [[6]] #> [1] 0 #>  #> [[7]] #> [1] 0 #>  #> [[8]] #> [1] 0 #>  #> [[9]] #> [1] 0 #>  #> [[10]] #> [1] 0 #>  #> [[11]] #> [1] 0 #>  #> [[12]] #> [1] 0 #>  #> [[13]] #> [1] 0 #>  #> [[14]] #> [1] 0 #>  #> [[15]] #> [1] 0 #>  #> [[16]] #> [1] 0 #>  #> [[17]] #> [1] 0 #>  #> [[18]] #> [1] 0 #>  #> [[19]] #> [1] 0 #>  #> [[20]] #> [1] 0 #>  #> [[21]] #> [1] 0 #>  #> [[22]] #> [1] 0 #>  #> [[23]] #> [1] 0 #>  #> [[24]] #> [1] 0 #>  #> [[25]] #> [1] 0 #>  #> [[26]] #> [1] 0 #>  #> [[27]] #> [1] 0 #>  #> [[28]] #> [1] 0 #>  #> [[29]] #> [1] 0 #>  #> [[30]] #> [1] 0 #>  #> [[31]] #> [1] 0 #>  #> [[32]] #> [1] 0 #>  #> [[33]] #> [1] 0 #>  #> [[34]] #> [1] 0 #>  #> [[35]] #> [1] 0 #>  #> [[36]] #> [1] 0 #>  #> [[37]] #> [1] 0 #>  #> [[38]] #> [1] 0 #>  #> [[39]] #> [1] 0 #>  #> [[40]] #> [1] 0 #>  #> [[41]] #> [1] 0 #>  #> [[42]] #> [1] 0 #>  #> [[43]] #> [1] 0 #>  #> [[44]] #> [1] 0 #>  #> [[45]] #> [1] 0 #>  #> [[46]] #> [1] 0 #>  #> [[47]] #> [1] 0 #>  #> [[48]] #> [1] 0 #>  #> [[49]] #> [1] 0 #>  #> [[50]] #> [1] 0 #>  #> [[51]] #> [1] 0 #>  #> [[52]] #> [1] 0 #>  #> [[53]] #> [1] 0 #>  #> [[54]] #> [1] 0 #>  #> [[55]] #> [1] 0 #>  #> [[56]] #> [1] 0 #>  #> [[57]] #> [1] 0 #>  #> [[58]] #> [1] 0 #>  #> [[59]] #> [1] 0 #>  #> [[60]] #> [1] 0 #>  #> [[61]] #> [1] 0 #>  #> [[62]] #> [1] 0 #>  #> [[63]] #> [1] 0 #>  #> [[64]] #> [1] 0 #>  #> [[65]] #> [1] 0 #>  #> [[66]] #> [1] 0 #>  #> [[67]] #> [1] 0 #>  #> [[68]] #> [1] 0 #>  #> [[69]] #> [1] 0 #>  #> [[70]] #> [1] 0 #>  #> [[71]] #> [1] 0 #>  #> [[72]] #> [1] 0 #>  #> [[73]] #> [1] 0 #>  #> [[74]] #> [1] 0 #>  #> [[75]] #> [1] 0 #>  #> [[76]] #> [1] 0 #>  #> [[77]] #> [1] 0 #>  #> [[78]] #> [1] 0 #>  #> [[79]] #> [1] 0 #>  #> [[80]] #> [1] 0 #>  #> [[81]] #> [1] 0 #>  #> [[82]] #> [1] 0 #>  #> [[83]] #> [1] 0 #>  #> [[84]] #> [1] 0 #>  #> [[85]] #> [1] 0 #>  #> [[86]] #> [1] 0 #>  #> [[87]] #> [1] 0 #>  #> [[88]] #> [1] 0 #>  #> [[89]] #> [1] 0 #>  #> [[90]] #> [1] 0 #>  #> [[91]] #> [1] 0 #>  #> [[92]] #> [1] 0 #>  #> [[93]] #> [1] 0 #>  #> [[94]] #> [1] 0 #>  #> [[95]] #> [1] 0 #>  #> [[96]] #> [1] 0 #>  #> [[97]] #> [1] 0 #>  #> [[98]] #> [1] 0 #>  #> [[99]] #> [1] 0 #>  #> [[100]] #> [1] 0 #>  #> [[101]] #> [1] 0 #>  fun.forecast(iorder = 1, ar = 0.8, ma = 0.5, n = 100, past = 1) #> Time Series: #> Start = 1  #> End = 100  #> Frequency = 1  #>   [1] 8.000000e-01 6.400000e-01 5.120000e-01 4.096000e-01 3.276800e-01 #>   [6] 2.621440e-01 2.097152e-01 1.677722e-01 1.342177e-01 1.073742e-01 #>  [11] 8.589935e-02 6.871948e-02 5.497558e-02 4.398047e-02 3.518437e-02 #>  [16] 2.814750e-02 2.251800e-02 1.801440e-02 1.441152e-02 1.152922e-02 #>  [21] 9.223372e-03 7.378698e-03 5.902958e-03 4.722366e-03 3.777893e-03 #>  [26] 3.022315e-03 2.417852e-03 1.934281e-03 1.547425e-03 1.237940e-03 #>  [31] 9.903520e-04 7.922816e-04 6.338253e-04 5.070602e-04 4.056482e-04 #>  [36] 3.245186e-04 2.596148e-04 2.076919e-04 1.661535e-04 1.329228e-04 #>  [41] 1.063382e-04 8.507059e-05 6.805647e-05 5.444518e-05 4.355614e-05 #>  [46] 3.484491e-05 2.787593e-05 2.230075e-05 1.784060e-05 1.427248e-05 #>  [51] 1.141798e-05 9.134385e-06 7.307508e-06 5.846007e-06 4.676805e-06 #>  [56] 3.741444e-06 2.993155e-06 2.394524e-06 1.915619e-06 1.532496e-06 #>  [61] 1.225996e-06 9.807971e-07 7.846377e-07 6.277102e-07 5.021681e-07 #>  [66] 4.017345e-07 3.213876e-07 2.571101e-07 2.056881e-07 1.645505e-07 #>  [71] 1.316404e-07 1.053123e-07 8.424983e-08 6.739987e-08 5.391989e-08 #>  [76] 4.313591e-08 3.450873e-08 2.760699e-08 2.208559e-08 1.766847e-08 #>  [81] 1.413478e-08 1.130782e-08 9.046257e-09 7.237006e-09 5.789604e-09 #>  [86] 4.631684e-09 3.705347e-09 2.964277e-09 2.371422e-09 1.897138e-09 #>  [91] 1.517710e-09 1.214168e-09 9.713344e-10 7.770676e-10 6.216540e-10 #>  [96] 4.973232e-10 3.978586e-10 3.182869e-10 2.546295e-10 2.037036e-10"},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a model is stationary — isStationaryModel","title":"Check if a model is stationary — isStationaryModel","text":"Check model stationary.","code":""},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a model is stationary — isStationaryModel","text":"","code":"isStationaryModel(object)"},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a model is stationary — isStationaryModel","text":"object object","code":""},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if a model is stationary — isStationaryModel","text":"generic function.   returns TRUE object represents stationary model   FALSE otherwise.","code":""},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a model is stationary — isStationaryModel","text":"TRUE FALSE","code":""},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if a model is stationary — isStationaryModel","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/isStationaryModel.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Check if a model is stationary — isStationaryModel","text":"signature(object = \"SarimaSpec\")  signature(object = \"VirtualIntegratedModel\")  signature(object = \"VirtualStationaryModel\")","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/modelCenter.html","id":null,"dir":"Reference","previous_headings":"","what":"model center — modelCenter","title":"model center — modelCenter","text":"model center","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCenter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model center — modelCenter","text":"","code":"modelCenter(object)"},{"path":"https://geobosh.github.io/sarima/reference/modelCenter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model center — modelCenter","text":"object object","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCenter.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"model center — modelCenter","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCenter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"model center — modelCenter","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for generic function modelCoef — modelCoef-methods","title":"Methods for generic function modelCoef — modelCoef-methods","text":"Methods generic function modelCoef.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for generic function modelCoef — modelCoef-methods","text":"signature(object = \"Autocorrelations\", convention = \"ComboAutocorrelations\", component = \"missing\")  signature(object = \"Autocorrelations\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"ComboAutocorrelations\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"ComboAutocovariances\", component = \"missing\")  signature(object = \"Autocovariances\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"ComboAutocorrelations\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"ComboAutocorrelations\", convention = \"PartialAutocorrelations\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"Autocovariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"PartialAutocovariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"PartialVariances\", component = \"missing\")  signature(object = \"ComboAutocovariances\", convention = \"VirtualAutocovariances\", component = \"missing\")  signature(object = \"PartialAutocorrelations\", convention = \"Autocorrelations\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArmaFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"MaFilter\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"SarimaFilter\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"character\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"missing\", component = \"missing\")  signature(object = \"VirtualAutocovariances\", convention = \"VirtualAutocovariances\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"ArModel\", component = \"missing\")  signature(object = \"SarimaModel\", convention = \"MaModel\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"BD\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"BJ\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"missing\", component = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"SP\", component = \"missing\")  signature(object = \"ArmaModel\", convention = \"ArmaFilter\",            component = \"missing\")  signature(object = \"VirtualAutocovariances\",            convention = \"Autocovariances\", component = \"missing\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for generic function modelCoef — modelCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the coefficients of models — modelCoef","title":"Get the coefficients of models — modelCoef","text":"Get coefficients object, optionally specifying   expected format.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the coefficients of models — modelCoef","text":"","code":"modelCoef(object, convention, component, ...)"},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the coefficients of models — modelCoef","text":"object object. convention convention use return value, character string     object supported class, see Details. component missing, specifies component extract, see Details. ... used, arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the coefficients of models — modelCoef","text":"modelCoef generic function extraction coefficients   model objects. `coeffcients' means depends class   object can changed optional argument   convention. effect, modelCoef provides   flexible descriptive way extracting coefficients models   various forms. one-argument form, modelCoef(object), gives   coefficients object. effect defines, purposes   modelCoef, meaning `coefficients' class   class(modelCoef). Argument convention can used specify kind value   return. convention character string, class   used. Conceptually, value format meaning   value returned call modelCoef(obj)   obj class class(convention). convention character string, typically name   class. case modelCoef(object, \"someclass\")   equivalent modelCoef(object, new(\"someclass\")).  Note   conceptual - argument convention can name   virtual class, example.  Also, classes object   character values names classes may supported. example, obj class \"ArmaModel\",   modelCoef(obj) returns list components \"ar\" \"ma\",   follow \"BD\" convention. , get list   coefficients object class capable   representing ARMA models, set convention = \"ArmaModel\"   call modelCoef{}. modelCoef() signal error object   compatible target (e.g. contains unit roots).   (see filterCoef need expand multiplicative   filters).   TODO: rethink , reflect current behaviour! class returns exactly needed   additional computation may necessary.   \"ArmaModel\" example might need coefficients \"BJ\"   convention, need change signs MA   coefficients achieve . Since common operation,   convenience feature available. Setting convention = \"BJ\"   requests ARMA coefficients \"BJ\" convention. completeness,   settings \"SP\" (signal processing) \"BD\" (Brockwell-Davis)   also available. methods modelCoef() package \"sarima\" return list   components depending argument \"convention\", outlined   .","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the coefficients of models — modelCoef","text":"list, components depending target class, described   Details","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the coefficients of models — modelCoef","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/modelCoef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the coefficients of models — modelCoef","text":"","code":"## define a seasonal ARIMA model, it has a number of components m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12) m1 #> An object of class \"SarimaModel\" #> Model: (1-B)(1-B^s)X(t) = Theta(B)Theta_s(B^s)e(t) #>  #> Intercept:  0  #> SigmaSq:  NA  #> Period:  12  #> Order of differencing:  1  #> Order of seasonal differencing:  1  #>  #> ar coefficients:    <None> #> ma coefficients:   -0.3 #> seasonal ar coefficients:   <None> #> seasonal ma coefficients:  -0.1 ## Get the coefficients corresponding to a 'flat' ARMA model, ## obtained by multiplying out AR-like and MA-like terms.  ## A simple way is to use modelCoef() with a suitable convention: modelCoef(m1, \"ArmaModel\") #> $ar #>  [1]  1  0  0  0  0  0  0  0  0  0  0  1 -1 #>  #> $ma #>  [1] -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 -0.10 #> [13]  0.03 #>  modelCoef(m1, \"ArmaFilter\") ## same #> $ar #>  [1]  1  0  0  0  0  0  0  0  0  0  0  1 -1 #>  #> $ma #>  [1] -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 -0.10 #> [13]  0.03 #>   ## Here is another model m1a <- new(\"SarimaModel\", iorder = 1, siorder = 1,  ar = 0.6, nseasons = 12) modelCoef(m1a, \"ArmaModel\") #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  modelCoef(m1a, \"ArmaFilter\") ## same #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>   ## if only AR-like terms are allowed in a computation, ## use convention = \"ArModel\" to state it explicitly. ## ## this works, since m1a contains only AR-like terms: modelCoef(m1a, \"ArModel\") #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  modelCoef(m1a, \"ArFilter\") ## same #> $ar #>  [1]  1.6 -0.6  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 -1.6  0.6 #>  #> $ma #> numeric(0) #>  ## ... but these would throw errors if evaluated, ## since model m1a contains both AR-like and MA-like terms, if (FALSE) { modelCoef(m1, \"ArModel\") modelCoef(m1, \"ArFilter\") modelCoef(m1, \"MaModel\") modelCoef(m1, \"MaFilter\") }"},{"path":"https://geobosh.github.io/sarima/reference/modelIntercept.html","id":null,"dir":"Reference","previous_headings":"","what":"Give the intercept parameter of a model — modelIntercept","title":"Give the intercept parameter of a model — modelIntercept","text":"Give intercept parameter model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelIntercept.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give the intercept parameter of a model — modelIntercept","text":"","code":"modelIntercept(object)"},{"path":"https://geobosh.github.io/sarima/reference/modelIntercept.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give the intercept parameter of a model — modelIntercept","text":"object object class intercept defined.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelIntercept.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Give the intercept parameter of a model — modelIntercept","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelIntercept.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Give the intercept parameter of a model — modelIntercept","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the order of a model — modelOrder-methods","title":"Get the order of a model — modelOrder-methods","text":"Get order model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get the order of a model — modelOrder-methods","text":"signature(object = \"ArmaModel\", convention = \"ArFilter\")  signature(object = \"ArmaModel\", convention = \"MaFilter\")  signature(object = \"SarimaModel\", convention = \"ArFilter\")  signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"SarimaModel\", convention = \"ArmaModel\")  signature(object = \"SarimaModel\", convention = \"ArModel\")  signature(object = \"SarimaModel\", convention = \"MaFilter\")  signature(object = \"SarimaModel\", convention = \"MaModel\")  signature(object = \"VirtualFilterModel\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the order of a model — modelOrder-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the model order and other properties of models — modelOrder","title":"Get the model order and other properties of models — modelOrder","text":"Get model order properties models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the model order and other properties of models — modelOrder","text":"","code":"modelOrder(object, convention, ...)  modelPoly(object, convention, ...)  modelPolyCoef(object, convention, lag_0 = TRUE, ...)"},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the model order and other properties of models — modelOrder","text":"object model object. convention convention. lag_0 TRUE include lag_0 coef, otherwise drop . ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the model order and other properties of models — modelOrder","text":"functions return requested quantity, optionally requesting   returned value follow specific convention, see also   modelCoef. called one argument, functions return corresponding   property native format object's class. Argument convention requests result   format. mental model returned value   object first converted class specified convention   property extracted computed. Normally, object   actually converted class. one obvious reason efficiency   may also possible, example argument   convention name virtual class. example, order seasonal SARIMA model specified   several numbers. call modelOrder(object) returns   list components ar, ma, sar, sma, iorder, siorder nseasons.   computations needed overall AR MA   orders obtained multiplying AR-like MA-like terms   model.   result ARMA filter requested    modelOrder(object, \"ArmaFilter\"). operation valid ARIMA model, always   succeed.  hand, computation work   moving average terms model one use   modelOrder(object, \"ArFilter\"). , object contains   MA terms error raised. concept powerful helps writing expressive code.   example simple check returned value even   , check may require additional care.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the model order and other properties of models — modelOrder","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/modelOrder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the model order and other properties of models — modelOrder","text":"","code":"m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12) modelOrder(m1) #> $nseasons #> [1] 12 #>  #> $iorder #> [1] 1 #>  #> $siorder #> [1] 1 #>  #> $ar #> [1] 0 #>  #> $ma #> [1] 1 #>  #> $sar #> [1] 0 #>  #> $sma #> [1] 1 #>  modelOrder(m1, \"ArmaFilter\") #> $ar #> [1] 13 #>  #> $ma #> [1] 13 #>  modelOrder(m1, new(\"ArmaFilter\")) #> $ar #> [1] 13 #>  #> $ma #> [1] 13 #>   modelPoly(m1, \"ArmaModel\") #> $ar #> 1 - x - x^12 + x^13  #>  #> $ma #> 1 - 0.3*x - 0.1*x^12 + 0.03*x^13  #>  modelPolyCoef(m1, \"ArmaModel\") #> $ar #>  [1]  1 -1  0  0  0  0  0  0  0  0  0  0 -1  1 #>  #> $ma #>  [1]  1.00 -0.30  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00  0.00 #> [13] -0.10  0.03 #>"},{"path":"https://geobosh.github.io/sarima/reference/modelPoly-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Get polynomials associated with SARIMA models — modelPoly-methods","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"Get polynomials associated SARIMA models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelPoly-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"VirtualMonicFilter\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelPoly-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get polynomials associated with SARIMA models — modelPoly-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelPolyCoef-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for modelPolyCoef — modelPolyCoef-methods","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"Methods modelPolyCoef, e generic function getting   coefficients polynomials associated SARIMA models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelPolyCoef-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"signature(object = \"SarimaModel\", convention = \"ArmaFilter\")  signature(object = \"VirtualMonicFilter\", convention = \"missing\")  signature(object = \"VirtualFilterModel\", convention = \"character\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/modelPolyCoef-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for modelPolyCoef — modelPolyCoef-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of seasons — nSeasons","title":"Number of seasons — nSeasons","text":"Number seasons.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of seasons — nSeasons","text":"","code":"nSeasons(object)"},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of seasons — nSeasons","text":"object object notion number seasons makes sense.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of seasons — nSeasons","text":"generic function.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of seasons — nSeasons","text":"integer number","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of seasons — nSeasons","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/nSeasons.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Number of seasons — nSeasons","text":"signature(object = \"SarimaFilter\")  signature(object = \"VirtualArmaFilter\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of unit roots in a model — nUnitRoots","title":"Number of unit roots in a model — nUnitRoots","text":"Gives number roots modulus one model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of unit roots in a model — nUnitRoots","text":"","code":"nUnitRoots(object)"},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of unit roots in a model — nUnitRoots","text":"object object.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of unit roots in a model — nUnitRoots","text":"nUnitRoots() gives number roots modulus one   model. number zero stationary models, see also   isStationaryModel().","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of unit roots in a model — nUnitRoots","text":"non-negative integer number","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Number of unit roots in a model — nUnitRoots","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/nUnitRoots.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Number of unit roots in a model — nUnitRoots","text":"signature(object = \"SarimaSpec\")  signature(object = \"VirtualStationaryModel\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Compute variances autocorrelations ARCH-type hypothesis.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"","code":"nvarOfAcfKP(x, maxlag, center = FALSE, acfscale = c(\"one\", \"mom\"))"},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"x time series. maxlag positive integer, maximal lag. center logical flag, FALSE, default, center time series     squaring, see Details. acfscale character string, specifying factor use     autocovariances. \"one\" stands \\(1/n\\), \"mom\"     \\(1/(n-k)\\), \\(n\\) length x \\(k\\)     lag.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"nvarOfAcfKP computes estimates \\(n\\) times variances   sample autocorrelations white noise time series. implements   result (Kokoszka Politis 2011)    holds weak assumptions. particular, can used test   true autocorrelations time series equal zero GARCH   modelling.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"numeric vector","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Kokoszka PS, Politis DN (2011). “Nonlinearity ARCH stochastic volatility models Bartlett's formula.” Probability Mathematical Statistics, 31(1), 47--59.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/nvarOfAcfKP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute variances of autocorrelations under ARCH-type hypothesis — nvarOfAcfKP","text":"","code":"## see examples for whiteNoisTest()"},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariances of sample autocorrelations — nvcovOfAcf","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Compute covariances autocorrelations.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"","code":"nvcovOfAcf(model, maxlag)  nvcovOfAcfBD(acf, ma, maxlag)  acfOfSquaredArmaModel(model, maxlag)"},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"model model, see Details. maxlag positive integer number, maximal lag. acf autocorrelations. ma positive integer number, order MA(q) model. default     maximal lag available acf.","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"nvcovOfAcf computes unscaled asymptotic autocovariances   sample autocorrelations ARMA models, classical   assumptions Bartlett's formulas valid.  works directly   parameters model uses Boshnakov (1996).  Argument   model can specification ARMA models   autocorrelations() work, e.g. list components \"ar\",   \"ma\", \"sigma2\". nvcovOfAcfBD computes quantities uses formula   given Brockwell & Davis (1991) (eq. (7.2.6.), p. 222),   based autocorrelations model. Argument   acf contains autocorrelations. nvcovOfAcfBD, argument ma asks treat provided   acf MA(ma). values lags   ma used rest set zero, since   autocorrelations MA(ma) models zero lags greater   ma.   force use autocorrelations provided acf, set   ma maximal lag available acf omit   ma, since default. acfOfSquaredArmaModel(model, maxlag) convenience function   computes autocovariances \"squared\" model, see   Boshnakov (1996).","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"(maxlag,maxlag)-matrix","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Boshnakov GN (1996). “Bartlett's formulae---closed forms recurrent equations.” Ann. Inst. Statist. Math., 48(1), 49--59. ISSN 0020-3157, doi:10.1007/BF00049288 . Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag..","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"name nvcovOfAcf stands “n times   variance-covariance matrix”, needs divided n   get asymptotic variances covariances.","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/nvcovOfAcf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Covariances of sample autocorrelations — nvcovOfAcf","text":"","code":"## MA(2) ma2 <- list(ma = c(0.8, 0.1), sigma2 = 1) nv <- nvcovOfAcf(ma2, maxlag = 4) d <- diag(nvcovOfAcf(ma2, maxlag = 7)) cbind(ma2 = 1.96 * sqrt(d) / sqrt(200), iid = 1.96/sqrt(200)) #>             ma2       iid #> [1,] 0.09452061 0.1385929 #> [2,] 0.16935276 0.1385929 #> [3,] 0.17400093 0.1385929 #> [4,] 0.17400093 0.1385929 #> [5,] 0.17400093 0.1385929 #> [6,] 0.17400093 0.1385929 #> [7,] 0.17400093 0.1385929  acr <- autocorrelations(list(ma = c(0.8, 0.1)), maxlag = 7) nvBD <- nvcovOfAcfBD(acr, 2, maxlag = 4) all.equal(nv, nvBD) # TRUE #> [1] TRUE"},{"path":"https://geobosh.github.io/sarima/reference/partialAutocorrelations-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"Methods function partialAutocorrelations.","code":""},{"path":"https://geobosh.github.io/sarima/reference/partialAutocorrelations-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"signature(x = \"\", maxlag = \"\", lag_0 = \"\")  signature(x = \"mts\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"PartialAutocovariances\", maxlag = \"\", lag_0 = \"missing\")  signature(x = \"ts\", maxlag = \"\", lag_0 = \"missing\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/partialAutocorrelations-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for function partialAutocorrelations — partialAutocorrelations-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/periodogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"Obtain important period lags time series according      periodogram.","code":""},{"path":"https://geobosh.github.io/sarima/reference/periodogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"","code":"periodogram(x, ..., no.results = 20)"},{"path":"https://geobosh.github.io/sarima/reference/periodogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"x vector containing time series values ... Arguments passed spectrum .results number results printed end. Defaults  20 important frequencies.","code":""},{"path":"https://geobosh.github.io/sarima/reference/periodogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"data.frame containing following columns: rank numeric vector containing ranked importance          frequency. spectrum estimates spectral density frequencies          corresponding freq. frequency vector spectral density estimated. period vector corresponding periods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/periodogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Obtain the most important period lags of a time series according to \n    a periodogram. — periodogram","text":"Using spectral function, obtain spectral density estimates      number frequencies rather plotting, obtain rank      period values. Return given number results based level     interest user.","code":""},{"path":"https://geobosh.github.io/sarima/reference/plot-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot methods in package sarima — plot-methods","title":"Plot methods in package sarima — plot-methods","text":"Plot methods package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/plot-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Plot methods in package sarima — plot-methods","text":"signature(x = \"SampleAutocorrelations\", y = \"matrix\")  signature(x = \"SampleAutocorrelations\", y = \"missing\") plots sample autocorrelations (individual) rejection limits   computed null hypothesis ..d. (strong white noise)   argument data provided, time series   autocorrelations computed. case rejection   limits null hypothesis time series (garch) weak white   noise provided, well. Additional arguments can supplied, see whiteNoiseTest   examples, vignettes. signature(x = \"SamplePartialAutocorrelations\", y =     \"missing\") plots sample partial autocorrelations rejection limits     hypotheses controlling arguments \"SampleAutocorrelations\".","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/plot-methods.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot methods in package sarima — plot-methods","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/plot-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot methods in package sarima — plot-methods","text":"","code":"set.seed(1234) n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.acf #> An object of class \"SampleAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00  8.582362e-03 -2.018313e-02 -2.132628e-03 -3.961602e-03  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -3.274167e-02 -4.079434e-02  1.854328e-02  4.641011e-03 -1.357080e-02  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -1.219076e-02  2.136221e-03 -1.492981e-02 -1.219485e-02 -4.381421e-02  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -2.281830e-03 -1.766486e-02 -5.846757e-03  1.037726e-02 -9.286768e-05  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #> -1.013180e-02 -1.038853e-02  1.402807e-02  2.423647e-02  1.047997e-02  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #>  7.201460e-03  8.488189e-03 -9.712715e-03  1.784192e-02 -1.952790e-02  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  3.907283e-03 -3.013057e-03 -2.266969e-02 -8.177097e-03  5.453303e-03  #>        Lag_35        Lag_36  #>  7.377188e-03  1.883301e-03  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x x.pacf <- partialAutocorrelations(x) x.pacf #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000  0.0085823617 -0.0202582774 -0.0017828992 -0.0043383782  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.0327650792 -0.0404641407  0.0178960591  0.0025478441 -0.0134144032  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #> -0.0132073022 -0.0006562451 -0.0160165907 -0.0104612044 -0.0454777643  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -0.0042317566 -0.0202992932 -0.0065655314  0.0070365865 -0.0043112264  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #> -0.0136537970 -0.0107137774  0.0114656459  0.0228629885  0.0098952431  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #>  0.0058602874  0.0053481194 -0.0098438262  0.0191055268 -0.0192762938  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #>  0.0032466133 -0.0038284295 -0.0219232817 -0.0081774145  0.0051229039  #>        Lag_35        Lag_36  #>  0.0052288057  0.0036772670  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x  plot(x.acf)  ## add limits for a weak white noise test: plot(x.acf, data = x)   ## similarly for pacf plot(x.pacf)  plot(x.pacf, data = x)   plot(x.acf, data = x, main = \"Autocorrelation test\")  plot(x.pacf, data = x, main = \"Partial autocorrelation test\")   plot(x.acf, ylim = c(NA,1))  plot(x.acf, ylim.fac = 1.5)  plot(x.acf, data = x, ylim.fac = 1.5)  plot(x.acf, data = x, ylim = c(NA, 1))"},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare SARIMA simulations — prepareSimSarima","title":"Prepare SARIMA simulations — prepareSimSarima","text":"Prepare SARIMA simulations.","code":""},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare SARIMA simulations — prepareSimSarima","text":"","code":"prepareSimSarima(model, x = NULL, eps = NULL, n, n.start = NA,                  xintercept = NULL, rand.gen = rnorm)  # S3 method for simSarimaFun print(x, ...)"},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare SARIMA simulations — prepareSimSarima","text":"model object suitable class list, see Details. x initial/values time series, list, numeric     vector time series, see Details.  eps initial/values innovations, list numeric     vector, see Details.  n number observations generate, missing attempt made     infer x eps.  n.start number burn-observations. xintercept non-constant intercept may represent trend covariate     effects.  rand.gen random number generator, defaults N(0,1). ... ignored.","code":""},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare SARIMA simulations — prepareSimSarima","text":"prepareSimSarima preparatory work simulation   Sarima model, given specifications returns function,   can called many times needed. variance innovations specified model   simulated innovations multiplied corresponding standard   deviation. , expected random number generator   simulates standardised distribution. Argument model can class representing models   SARIMA family, \"SarimaModel\", list components   suitable passed =new()= models. canonical form argument x list components   , init main. components   missing NULL, filled suitably.  components   x ignored. x list, put   component main. Conceptually, three components   concatenated given order, simulated values put   main (init changed),   part dropped rest returned. effect,   init can viewed initial values   init considered part generated series. format eps x. lengths   missing components x inferred corresponding   components eps, vice versa. format xintercept x   eps. print.simSarimaFun print method objects generated   prepareSimSarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare SARIMA simulations — prepareSimSarima","text":"prepareSimSarima, function simulate time series, see   Details.  typically called multiple times without arguments.   arguments defaults set prepareSimSarima. n length simulated time series, rand.gen random number generator, ... arguments random number generator, passed     arima.sim.","code":""},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prepare SARIMA simulations — prepareSimSarima","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/prepareSimSarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare SARIMA simulations — prepareSimSarima","text":"","code":"mo1 <- list(ar = 0.9, iorder = 1, siorder = 1, nseasons = 4, sigma2 = 2) fs1 <- prepareSimSarima(mo1, x = list(before = rep(0,6)),  n = 100) tmp1 <- fs1() tmp1 #>   [1]    4.000695    8.148254   11.931620   15.471456   20.004553   23.448029 #>   [7]   24.347732   26.253385   29.371441   29.941756   30.436985   33.363669 #>  [13]   38.078999   40.992003   41.993131   44.850613   50.134660   52.006500 #>  [19]   55.904676   63.243979   74.153931   81.165543   87.685195   98.961783 #>  [25]  115.433202  127.899568  138.626662  154.538047  175.850308  191.557155 #>  [31]  204.338144  222.408688  247.067724  268.983388  285.775668  306.646990 #>  [37]  335.739735  361.798287  383.214974  407.003968  438.251845  466.709624 #>  [43]  488.958496  515.212112  546.883767  576.911106  600.806116  626.681618 #>  [49]  660.425674  692.569202  717.812462  745.719237  781.020246  814.165907 #>  [55]  839.344385  868.013375  902.487260  935.096568  959.542346  987.068564 #>  [61] 1021.472125 1054.613291 1079.181617 1107.560857 1140.394797 1170.761884 #>  [67] 1192.953780 1221.342489 1252.542812 1279.162846 1298.104434 1323.583115 #>  [73] 1350.158073 1372.615300 1387.415328 1409.411949 1431.338943 1448.788218 #>  [79] 1458.122156 1476.819967 1495.050607 1508.649832 1511.918802 1525.219544 #>  [85] 1537.710868 1547.394119 1548.545615 1559.401198 1567.573950 1572.868786 #>  [91] 1570.066187 1576.044438 1578.880902 1580.033961 1575.545291 1578.212966 #>  [97] 1577.288130 1571.870694 1562.584598 1561.826681 plot(ts(tmp1))   fs2 <- prepareSimSarima(mo1, x = list(before = rep(1,6)),  n = 100) tmp2 <- fs2() plot(ts(tmp2))   mo3 <- mo1 mo3[[\"ar\"]] <- 0.5 fs3 <- prepareSimSarima(mo3, x = list(before = rep(0,6)),  n = 100) tmp3 <- fs3() plot(ts(tmp3))"},{"path":"https://geobosh.github.io/sarima/reference/rgarch1p1.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate GARCH(1,1) models — rgarch1p1","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"Simulate GARCH(1,1) models. function internal purposes   generate data examples testing.","code":""},{"path":"https://geobosh.github.io/sarima/reference/rgarch1p1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"","code":"rgarch1p1(n, alpha, beta, omega, n.skip = 100)"},{"path":"https://geobosh.github.io/sarima/reference/rgarch1p1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"n length generated time series. alpha alpha parameters volatility equation. beta beta parameters volatility equation. omega constant term volatility equation. n.skip number additional observation generate     beginning time series.","code":""},{"path":"https://geobosh.github.io/sarima/reference/rgarch1p1.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/rgarch1p1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate GARCH(1,1) models — rgarch1p1","text":"","code":"x <- rgarch1p1(100, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) ## autocorrelations(x) ## partialAutocorrelations(x)"},{"path":"https://geobosh.github.io/sarima/reference/sarima-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Functions, classes methods time series modelling ARIMA     related models. aim package provide consistent     interface user. example, single function autocorrelations()     computes various kinds theoretical sample autocorrelations.     work progress, see documentation vignettes current     functionality.  Function sarima() fits extended multiplicative seasonal     ARIMA models trends, exogenous variables arbitrary roots     unit circle, can fixed estimated.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"large number packages time series modelling. provide huge number functions, often similar overlapping functionality different argument conventions. One aims package sarima provide consistent interface frequently used functionality. package sarima consistent naming scheme used much possible. Names functions start lowercase letter consist whole words, acronyms commonly used abbreviations. multiword names, second subsequent words start capital letters (camelCase).  first letter acronyms capitalised, e.g. Arma stands ARMA.  Formal (S4) classes follow rules first letter first word capitalised, well. example, functions compute autocorrelations, autocovariances, partial autocorrelations called autocorrelations, autocovariances, partialAutocorrelations, respectively. Moreover, recognise argument(s) exactly needed. given times series, compute sample autocorrelations, etc; given model specifications, compute corresponding theoretical properties. work progress, see also vignette(s).","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Georgi N. Boshnakov [aut, cre],   Jamie Halliday [aut] Maintainer: Georgi N. Boshnakov <georgi.boshnakov@manchester.ac.uk>","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"Boshnakov GN (1996). “Bartlett's formulae---closed forms recurrent equations.” Ann. Inst. Statist. Math., 48(1), 49--59. ISSN 0020-3157, doi:10.1007/BF00049288 . Brockwell PJ, Davis RA (1991). Time series: theory methods. 2nd ed.. Springer Series Statistics. Berlin etc.: Springer-Verlag.. Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press. McLeod AI, Yu H, Krougly Z (2007). “Algorithms Linear Time Series Analysis: R Package.” Journal Statistical Software, 23(5). doi:10.18637/jss.v023.i05 .","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/sarima-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Package sarima\n  \n  \n  Simulation and Prediction with Seasonal ARIMA Models — sarima-package","text":"","code":"## simulate a white noise ts (model from Francq & Zakoian) n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100)  ## acf and pacf ( x.acf <- autocorrelations(x) ) #> An object of class \"SampleAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.0000000000 -0.0328968366  0.0404686214 -0.0280091109 -0.0140648056  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -0.0011682836 -0.0270627319 -0.0129497797  0.0187398947 -0.0051402076  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #>  0.0407329366 -0.0039834520  0.0041946133 -0.0261820256 -0.0339899078  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -0.0069372701 -0.0095070191 -0.0273699085 -0.0038505927  0.0137267489  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #>  0.0150920891  0.0170354950 -0.0107532038 -0.0056515480  0.0125558356  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #> -0.0016884423 -0.0114251957  0.0006966703 -0.0027162658  0.0025002938  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #> -0.0044136980 -0.0053541785  0.0079752641 -0.0140166271 -0.0015153068  #>        Lag_35        Lag_36  #>  0.0173244245 -0.0067480160  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x ( x.pacf <- partialAutocorrelations(x) ) #> An object of class \"SamplePartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00 -3.289684e-02  3.942909e-02 -2.550042e-02 -1.738071e-02  #>         Lag_5         Lag_6         Lag_7         Lag_8         Lag_9  #> -2.257911e-05 -2.666839e-02 -1.548717e-02  1.978796e-02 -4.342861e-03  #>        Lag_10        Lag_11        Lag_12        Lag_13        Lag_14  #>  3.748330e-02 -5.799137e-04  5.326288e-04 -2.471690e-02 -3.411923e-02  #>        Lag_15        Lag_16        Lag_17        Lag_18        Lag_19  #> -6.778488e-03 -6.982875e-03 -2.905399e-02 -7.754974e-03  1.408658e-02  #>        Lag_20        Lag_21        Lag_22        Lag_23        Lag_24  #>  1.061696e-02  1.568584e-02 -9.981396e-03 -6.378303e-03  1.604568e-02  #>        Lag_25        Lag_26        Lag_27        Lag_28        Lag_29  #>  1.548825e-03 -1.218114e-02  1.609845e-03 -3.060986e-03 -1.290919e-03  #>        Lag_30        Lag_31        Lag_32        Lag_33        Lag_34  #> -6.292693e-03 -9.091505e-03  7.522659e-03 -1.205336e-02 -3.298488e-03  #>        Lag_35        Lag_36  #>  1.924078e-02 -5.168478e-03  #> Slot n: #> [1] 5000 #> Slot varnames:   <not set> #> Slot objectname:  x  ## portmanteau test for iid, by default gives also ci's for the acf under H0 x.iid <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LiMcLeod\") x.iid #> $test #>         ChiSq DF       pvalue #> [1,] 18.52103  5 0.0023595472 #> [2,] 33.21335 10 0.0002507838 #> [3,] 49.20894 20 0.0002871614 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.iid2 <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LjungBox\") x.iid2 #> $test #>         ChiSq DF       pvalue #> [1,] 18.53295  5 0.0023475578 #> [2,] 33.24841 10 0.0002473984 #> [3,] 49.26834 20 0.0002816355 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   ## portmanteau test for garch H0 x.garch <- whiteNoiseTest(x.acf, h0 = \"garch\", nlags = c(5,10,20), x = x) x.garch #> $test #>       h         Q       pval #> [1,]  5  6.454586 0.26446280 #> [2,] 10 17.319319 0.06759019 #> [3,] 20 30.689383 0.05942694 #>  #> $ci #>               int            #>  [1,] -0.04711984 0.04711984 #>  [2,] -0.04811414 0.04811414 #>  [3,] -0.04752476 0.04752476 #>  [4,] -0.04021118 0.04021118 #>  [5,] -0.03914635 0.03914635 #>  [6,] -0.03506707 0.03506707 #>  [7,] -0.03486665 0.03486665 #>  [8,] -0.03256475 0.03256475 #>  [9,] -0.03174065 0.03174065 #> [10,] -0.03108133 0.03108133 #> [11,] -0.03147183 0.03147183 #> [12,] -0.03050650 0.03050650 #> [13,] -0.03168418 0.03168418 #> [14,] -0.03164023 0.03164023 #> [15,] -0.03226080 0.03226080 #> [16,] -0.02995512 0.02995512 #> [17,] -0.03195747 0.03195747 #> [18,] -0.03187449 0.03187449 #> [19,] -0.02891890 0.02891890 #> [20,] -0.03169497 0.03169497 #>   ## plot methods give the CI's under H0 plot(x.acf)   ## if the data are given, the CI's under garch H0 are also given. plot(x.acf, data = x)   ## Tests based on partial autocorrelations are also available: plot(x.pacf)  plot(x.pacf, data = x)   ## Models ## AR ( ar2a1 <- ArModel(ar = c(-0.3, -0.7), sigma2 = 1) ) #> An object of class \"ArModel\" #> mean:  0  #> sigmaSq:  1  #>  #> slot \"ar\": #> An object of class \"BJFilter\" #> order:  2  #> Coefficients:  #> [1] -0.3 -0.7 #>  #> slot \"ma\": #> An object of class \"SPFilter\" #> order:  0  #> Coefficients:  #> numeric(0) autocorrelations(ar2a1, maxlag = 6) #> An object of class \"Autocorrelations\" #>          0          1          2          3          4          5          6  #>  1.0000000 -0.1764706 -0.6470588  0.3176471  0.3576471 -0.3296471 -0.1514588  partialAutocorrelations(ar2a1, maxlag = 6) #> An object of class \"PartialAutocorrelations\" #>         Lag_0         Lag_1         Lag_2         Lag_3         Lag_4  #>  1.000000e+00 -1.764706e-01 -7.000000e-01 -1.123440e-16  0.000000e+00  #>         Lag_5         Lag_6  #>  0.000000e+00 -5.617200e-17  autocovariances(ar2a1, maxlag = 6) #> An object of class \"Autocovariances\" #>      Lag_0      Lag_1      Lag_2      Lag_3      Lag_4      Lag_5      Lag_6  #>  2.0238095 -0.3571429 -1.3095238  0.6428571  0.7238095 -0.6671429 -0.3065238  partialVariances(ar2a1, maxlag = 6) #> An object of class \"PartialVariances\" #>        0        1        2        3        4        5        6  #> 2.023810 1.960784 1.000000 1.000000 1.000000 1.000000 1.000000   ## see examples for ArmaModel()"},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":null,"dir":"Reference","previous_headings":"","what":"Function used internally to compute forecasts — sarima.f","title":"Function used internally to compute forecasts — sarima.f","text":"Function used internally compute forecasts.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function used internally to compute forecasts — sarima.f","text":"","code":"sarima.f(past = numeric(length(ar)), n = max(2 * length(past), 12),          ar = numeric(0), ma = numeric(0), intercept = 0,          pasteps = numeric(length(ma)), trend = numeric(n))"},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function used internally to compute forecasts — sarima.f","text":"past past values time series. n number forecasts generate. ar ar coefficients. ma ma coefficients. intercept intercept. pasteps past values innovations. trend trend.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function used internally to compute forecasts — sarima.f","text":"Computes predictions using specified parameters past values.   ar ma coefficients fully expanded   polynomials SARIMA mmodel.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function used internally to compute forecasts — sarima.f","text":"numeric vector","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.f.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function used internally to compute forecasts — sarima.f","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit extended SARIMA models — sarima","title":"Fit extended SARIMA models — sarima","text":"Fit extended SARIMA models, can include lagged exogeneous   variables, general unit root non-stationary factors, multiple   periodicities, multiplicative terms SARIMA   specification. models specified flexible formula syntax   contain special cases many models specialised names,   ARMAX reg-ARIMA.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit extended SARIMA models — sarima","text":"","code":"sarima(model, data = NULL, ss.method = \"sarima\", use.symmetry = FALSE,         SSinit = \"Rossignol2011\")"},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit extended SARIMA models — sarima","text":"model model formula specifying model. data list data frame, usually can omitted. ss.method state space engine use, defaults     \"sarima\". (Note: argument     probably renamed.) use.symmetry logical argument indicating whether      symmetry used estimate unit polynomial. SSinit method use computation stationary part     initial covariance matrix, one \"Rossignol2011\", \"gnb\",     \"Gardner1980\".","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit extended SARIMA models — sarima","text":"sarima fits extended SARIMA models, can include   exogeneous variables, general unit root non-stationary factors   multiplicative terms SARIMA specification. Let \\(\\{Y_t\\}\\) time series \\(f(t)\\) \\(g(t)\\)   functions time /(possibly lagged) exogeneous variables. extended pure SARIMA model \\(Y_t\\) can written   help backward shift operator   $$U(B)\\Phi(B)Y_t = \\Theta(B)\\varepsilon_t,$$   \\(\\{\\varepsilon_t\\}\\) white noise,    \\(U(z)\\), \\(\\Phi(z)\\), \\(\\Theta(z)\\) polynomials,   roots \\(U(z)\\) unit circle,   roots \\(\\Phi(z)\\) \\(\\Theta(z)\\) outside unit   circle. unit roots missing, ie \\(U(z)\\equiv 1\\),   model stationary mean zero. reg-SARIMA X-SARIMA model can defined regression   SARIMA residuals:    $$Y_t = f(t) + Y^c_t$$   $$U(B)\\Phi(B)Y^c_t = \\Theta(B)\\varepsilon_t,$$   \\(Y^c_t = Y_t - f(t)\\) centred \\(Y_t\\).   can written equivalently single equation:   $$U(B)\\Phi(B)(Y_t - f(t)) = \\Theta(B)\\varepsilon_t.$$   regression function \\(f(t)\\) can depend   time /(possibly lagged) exogeneous variables.  call   centering function. \\(Y^c_t\\) stationary mean zero,   f(t) mean \\(Y_t\\). f(t) constant, say   mu, \\(Y_t\\) stationary mean mu. Note   two-equation form shows case mu   intercept first equation, perfectly reasonable   refer also intercept avoid confusion reserve   term intercept  g(t) . SARIMA part stationary, \\(EY_t = f(t)\\),   \\(f(t)\\) can interpreted trend. case   specification often referred mean corrected form   model. alternative way specify regression part add   regression function, say \\(\\{g(t)\\}\\), right-hand side SARIMA   equation:   $$U(B)\\Phi(B)Y_t = g(t) + \\Theta(B)\\varepsilon_t.$$   stationary case classical ARMAX specification.    can written two-stage form various ways, eg   $$U(B)\\Phi(B)Y_t = (1 - \\Theta(B))\\varepsilon_t + u_t,$$   $$u_t = g(t) + \\varepsilon_t .$$   , sense, g(t) trend associated residuals   SARIMA modelling. refer form intercept form   model (opposed mean-corrected form discussed previously). general, exogeneous variables mean-corrected   model equivalent intercept model, gives   justification terminology, well. exogeneous   variables equivalence may achievable expense   introducing lags model, whish desirable general. examples equivalence. Let Y stationary SARIMA   process (\\(U(z)=1\\)) mean \\(\\mu\\).   mean-corrected form SARIMA model    $$\\Phi(B)(Y_t - \\mu) = \\Theta(B)\\varepsilon_t,$$   intercept form   $$\\Phi(B)Y_t = c + \\Theta(B)\\varepsilon_t,$$   \\(c = \\Phi(B)\\mu\\). , case mean-corrected model   X-SARIMA model \\(f(t) = \\mu\\) equivalent   intercept model \\(g(t) = \\Phi(B)\\mu\\). another example, \\(f(t) = bt\\), mean-corrected model   \\((1-B)(Y_t - bt) = \\varepsilon_t\\). Expanding left-hand side   obtain intercept form  \\((1-B)Y_t = b + \\varepsilon_t\\),   demonstrates \\(Y_t\\) random walk drift \\(g(t) = b\\). Model specification Argument model specifies model syntax similar   model fitting functions R.  formula can given   components discussed y ~ f | SARIMA | g,   f, SARIMA g model formulas giving   specifications centering function f, SARIMA   specification, intercept function g.  normal use   one f g different zero. f   always given (use 0 specify identical   zero), g can omitted altogether.  Sometimes refer   terms specified f g xreg   regx, respectively. Model formulas trends exogeneous regressions formulas centering intercept (ie f   g) use syntax linear models additional   functions trigonometric trends, polynomial trends lagged   variables. available specialised terms:  .p(d) Orthogonal polynomials 1:length(y) degree d       (starting degree 1, constant). t Stands 1:length(y). Note powers need       protected (), e.g. y ~ 1 + .t + (.t^2). .cs(s, k) cos/sin pair k-th harmonic 2pi/s. Use vector k       specify several harmonics.  .B(x, lags) Include lagged terms x, \\(B^{lags}(x[t]) = x[t - lags]\\).       lags can vector.       x matrix, specified lags taken       column.  Model formulas SARIMA models flexible syntax provided specification SARIMA part   model.  formed using number primitives   stationary unit root components,    non-seasonal seasonal variants. Arbitrary number multiplicative   factors multiple seasonalities can specified. SARIMA part model can contain following   terms. can repeated needed. first argument   seasonal operators number seasons.  ar(p) autoregression term order p ma(q) moving average term order q sar(s,p) seasonal autoregression term (s seasons, order p) sma(s,q) seasonal moving average term (s seasons, order q) (d) \\((1-B)^d\\) s(seas) summation operator,       \\((1 + B + \\cdots + B^{seas -1})\\) u(x) quadratic unit root term, corresponding complex pair       unit circle. \\(x\\) real, specifies argument one       roots fraction \\(2\\pi\\). \\(z\\)       complex, root . real roots modulus one (1 \\(-1\\)) specified       using (1) s(2), correspond \\(1-B\\)       \\(1+B\\), respectively. su(s, h) quadratic unit root terms corresponding seasonal       differencing factors. h specifies desired harmonic       one 1,2, ..., [s/2]. Several harmonics can       specified setting h vector. ss(s, p) seasonal summation operator,       \\((1 + B^s + \\cdots + B^{(s-1)p})\\)  Terms parameters can contain additional arguments specifying   initial values, fixed parameters, transforms. ar,   ma, sar, sma, values coefficients can   specified unnamed argument parameters given   descriptions . estimation values taken   initial values optimisation.  default, coefficients   taken non-fixed. Argument fixed can used fix .    logical vector length one length   coefficients. fixed length one TRUE,   coefficients fixed. FALSE, non-fixed. Otherwise,   TRUE/FALSE values fixed determine fixedness   corresponding coefficients. fixed can also vector positive integer numbers   specifying indices fixed coefficients, rest non-fixed. Sometimes may easier declare (e.g. ) coefficients   fixed `unfix' selectively. Argument nonfixed can   used mark coefficients non-fixed   declared fixed. syntax fixed. TODO: streamline \"atanh.tr\" TODO: describe SSinit","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit extended SARIMA models — sarima","text":"object S3 class Sarima (Note: format object still development   may change; use accessor functions, coef(), provided.)","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit extended SARIMA models — sarima","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fit extended SARIMA models — sarima","text":"Currently implementation intercept form (ie third     part model formula) incomplete.","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit extended SARIMA models — sarima","text":"","code":"## AirPassengers example ## fit the classic airline model using arima() ap.arima <- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1))  ## same model using two equivalent ways to specify it ap.baseA <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1),                     ss.method = \"base\") ap.baseB <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(12),                     ss.method = \"base\")  ap.baseA #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(1) + si(12, 1), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)(1 - B^12) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61 summary(ap.baseA) #>  #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12,  #>     1, c(-0.1)) + i(1) + si(12, 1), ss.method = \"base\") #>  #> Model:  Y_t - xreg_t is SarimaX #>   xreg:    log(AirPassengers) ~ 0  #>   sarima:  ~ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) + i(1) + si(12, 1)  #>   regx:    0  #>  #> Unit root terms: #>      (1 - B)(1 - B^12) #>  #> Coefficients: #>      Estimate Std. Error Z value  Pr(>|z|)     #> ma1  -0.40153    0.10716 -3.7472 0.0001788 *** #> sma1 -0.56154    0.10680 -5.2581 1.456e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> estimated sigma^2 = 0.00135,  log-likelihood = 169.3,  aic = -332.61 ap.baseB #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(12), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B + ... + B^11) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61 summary(ap.baseB) #>  #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12,  #>     1, c(-0.1)) + i(2) + s(12), ss.method = \"base\") #>  #> Model:  Y_t - xreg_t is SarimaX #>   xreg:    log(AirPassengers) ~ 0  #>   sarima:  ~ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) + i(2) + s(12)  #>   regx:    0  #>  #> Unit root terms: #>      (1 - B)^2(1 + B + ... + B^11) #>  #> Coefficients: #>      Estimate Std. Error Z value  Pr(>|z|)     #> ma1  -0.40153    0.10716 -3.7472 0.0001788 *** #> sma1 -0.56154    0.10680 -5.2581 1.456e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> estimated sigma^2 = 0.00135,  log-likelihood = 169.3,  aic = -332.61  ## as above, but drop 1-B from the model: ap2.arima <- arima(log(AirPassengers), order = c(0,0,1), seasonal = c(0,1,1)) ap2.baseA <- sarima(log(AirPassengers) ~                      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) +     si(12,1),                      ss.method = \"base\") ap2.baseB <- sarima(log(AirPassengers) ~                      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + s(12),                      ss.method = \"base\")  ## for illustration, here the non-stationary part is  ##     (1-B)^2(1+B+...+B^5) = (1-B)(1-B^6) ##     (  compare to (1-B)(1-B^{12}) = (1-B)(1-B^6)(1+B^6) )  ap3.base <- sarima(log(AirPassengers) ~                     0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(6),                     ss.method = \"base\")  ## further unit roots, equivalent specifications for the airline model tmp.su <- sarima(log(AirPassengers) ~                   0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + su(12,1:5),                   ss.method = \"base\") tmp.su$interna$delta_poly #> List of polynomials: #> [[1]] #> 1 - x  #>  #> [[2]] #> 1 + x  #>  #> [[3]] #> 1 - 1.732051*x + x^2  #>  #> [[4]] #> 1 - x + x^2  #>  #> [[5]] #> 1 + x^2  #>  #> [[6]] #> 1 + x + x^2  #>  #> [[7]] #> 1 + 1.732051*x + x^2  #>  prod(tmp.su$interna$delta_poly) #> 1 + 8.881784e-16*x^3 - 1.332268e-15*x^4 + 1.776357e-15*x^5 - 1.776357e-15*x^7 +   #> 1.332268e-15*x^8 - 8.881784e-16*x^9 - x^12  zapsmall(coef(prod(tmp.su$interna$delta_poly))) #>  [1]  1  0  0  0  0  0  0  0  0  0  0  0 -1 tmp.su #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(2) + su(12, 1:5), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B)(1 - 1.73205080756888*B + B^2)(1 - B + B^2)(1 + B^2)(1 + B + B^2)(1 + 1.73205080756888*B + B^2) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61  tmp.u <- sarima(log(AirPassengers) ~                  0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(2) + s(2) + u((1:5)/12),                  ss.method = \"base\") tmp.u #> *Sarima model* #> Call: #> sarima(model = log(AirPassengers) ~ 0 | ma(1, c(-0.3)) + sma(12, 1, c(-0.1)) +  #>     i(2) + s(2) + u((1:5)/12), ss.method = \"base\") #>  #> Unit root terms: #>      (1 - B)^2(1 + B)(1 - 1.73205080756888*B + B^2)(1 - B + B^2)(1 + B^2)(1 + B + B^2)(1 + 1.73205080756888*B + B^2) #>  #> Coefficients: #>           ma1     sma1 #>       -0.4015  -0.5615 #> s.e.   0.1072   0.1068 #>  #> sigma^2 estimated as 0.001347:  log likelihood = 169.3,  aic = -332.61"},{"path":"https://geobosh.github.io/sarima/reference/se.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute standard errors — se","title":"Compute standard errors — se","text":"Compute standard errors.","code":""},{"path":"https://geobosh.github.io/sarima/reference/se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute standard errors — se","text":"","code":"se(object, ...)  # S4 method for SampleAutocorrelations vcov(object, assuming = \"iid\", maxlag = maxLag(object), ...)"},{"path":"https://geobosh.github.io/sarima/reference/se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute standard errors — se","text":"object object containing estimates, fitted model. ... arguments vcov. assuming assumptions computations?     Currently can \"iid\", \"garch\", fitted model,     theoretical model, see Details.  maxlag maximal lag include","code":""},{"path":"https://geobosh.github.io/sarima/reference/se.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute standard errors — se","text":"se convenience function typical case   square root diagonal variance-covariance matrix   needed. method vcov gives variance-covariance matrix   first maxlag autocorrelation coefficients object.   result depends underlying assumptions method   calculation. can specifyed additional arguments. Argument \"assuming\" can though also specifying null   hypothesis. Setting \"iid\" \"garch\" corresponds   strong white noise (iid) weak white noise, respectively. Setting \"assuming\" ARMA model (theoretical fitted)   specifies null model. Note: method vcov finalised yet.   used method confint.  Bug   reports requests github repo may bring closer   top task list.","code":""},{"path":"https://geobosh.github.io/sarima/reference/se.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute standard errors — se","text":"se, numeric vector giving standard errors; vcov method, square matrix","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/show-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for show in package sarima — show-methods","title":"Methods for show in package sarima — show-methods","text":"Methods show package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/show-methods.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for show in package sarima — show-methods","text":"signature(object = \"ArmaFilter\")  signature(object = \"ArmaModel\")  signature(object = \"ArModel\")  signature(object = \"Autocorrelations\")  signature(object = \"Autocovariances\")  signature(object = \"BJFilter\")  signature(object = \"InterceptSpec\")  signature(object = \"MaModel\")  signature(object = \"MonicFilterSpec\")  signature(object = \"PartialAutocorrelations\")  signature(object = \"PartialAutocovariances\")  signature(object = \"PartialVariances\")  signature(object = \"SampleAutocorrelations\")  signature(object = \"SampleAutocovariances\")  signature(object = \"SamplePartialAutocorrelations\")  signature(object = \"SamplePartialAutocovariances\")  signature(object = \"SamplePartialVariances\")  signature(object = \"SarimaFilter\")  signature(object = \"SarimaModel\")  signature(object = \"Spectrum\")  signature(object = \"SPFilter\")  signature(object = \"VirtualArmaFilter\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the innovation variance of models — sigmaSq","title":"Get the innovation variance of models — sigmaSq","text":"Get innovation variance models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the innovation variance of models — sigmaSq","text":"","code":"sigmaSq(object)"},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the innovation variance of models — sigmaSq","text":"object object suitable class.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the innovation variance of models — sigmaSq","text":"sigmaSq() gives innovation variance objects classes   makes sense, ARMA models. value depends class object, e.g. ARMA models   scalar univariate case matrix multivariate one.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get the innovation variance of models — sigmaSq","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/sigmaSq.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Get the innovation variance of models — sigmaSq","text":"signature(object = \"InterceptSpec\")","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate trajectories of seasonal arima models — sim_sarima","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"Simulate trajectories seasonal arima models.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"","code":"sim_sarima(model, n = NA, rand.gen = rnorm, n.start = NA, x, eps,            xcenter = NULL, xintercept = NULL, ...)"},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"model specification model, list model object, see `Details'.  rand.gen random number generator innovations. n length time series. n.start number burn-observations. x initial/values time series, list, numeric     vector time series, see Details. eps initial/values innovations, list numeric     vector, see Details. xintercept non-constant intercept may represent trend covariate     effects. xcenter currently ignored. ... additional arguments arima.sim     rand.gen, see `Details'.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"model can specified model object, e.g., class   SarimaModel. can also list elements   suitable passed new(\"SarimaModel\", ...), see   description class \"SarimaModel\".   possible components:  nseasons number seasons year (whatever larger       time unit) iorder order differencing, specifies factor       \\((1-B)^{d1}\\) model. siorder order seasonal differencing, specifies factor       \\((1-B^{period})^{ds}\\)  model. ar ar parameters (non-seasonal) ma ma parameters (non-seasonal) sar seasonal ar parameters sma seasonal ma parameters Additional arguments rand.gen may specified via   \"...\" argument.  particular, length generated series   specified argument n. Arguments rand.gen can   also passed via \"...\" argument. model stationary generated time series stationary   starting first value. particular, need   ‘warm-’ period. Information model printed screen   info = \"print\". suppress , set info   value. multple simulations (almost ) setup,   better execute prepareSimSarima call   function returned many times needed.","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"object class \"ts\", simulated time series given model","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/sim_sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate trajectories of seasonal arima models — sim_sarima","text":"","code":"require(\"PolynomF\") # guaranteed to be available since package \"sarima\" imports it. #> Loading required package: PolynomF  x <- sim_sarima(n=144, model = list(ma=0.8))               # MA(1) x <- sim_sarima(n=144, model = list(ar=0.8))               # AR(1)  x <- sim_sarima(n=144, model = list(ar=c(rep(0,11),0.8)))  # SAR(1), 12  seasons x <- sim_sarima(n=144, model = list(ma=c(rep(0,11),0.8)))  # SMA(1)                                    # more enlightened SAR(1) and SMA(1) x <- sim_sarima(n=144,model=list(sar=0.8, nseasons=12, sigma2 = 1))  # SAR(1), 12 seasons x <- sim_sarima(n=144,model=list(sma=0.8, nseasons=12, sigma2 = 1))  # SMA(1)  x <- sim_sarima(n=144, model = list(iorder=1, sigma2 = 1)) # (1-B)X_t = e_t (random walk) acf(x)  acf(diff(x))   x <- sim_sarima(n=144, model = list(iorder=2, sigma2 = 1))  # (1-B)^2 X_t = e_t x <- sim_sarima(n=144, model = list(siorder=1,                                     nseasons=12, sigma2 = 1)) # (1-B)^{12} X_t = e_t  x <- sim_sarima(n=144, model = list(iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1)) x <- sim_sarima(n=144, model = list(ma=0.4, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1)) x <- sim_sarima(n=144, model = list(ma=0.4, sma=0.7, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1))  x <- sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4,                                     sar=0.3, sma=0.7, iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1))  x <- sim_sarima(n=144, model = list(iorder=1, siorder=1,                                     nseasons=12, sigma2 = 1),                 x = list(init=AirPassengers[1:13]))  p <- polynom(c(1,-1.2,0.8)) solve(p) #> [1] 0.75-0.8291562i 0.75+0.8291562i abs(solve(p)) #> [1] 1.118034 1.118034  sim_sarima(n=144, model = list(ar=c(1.2,-0.8), ma=0.4, sar=0.3, sma=0.7,                                iorder=1, siorder=1, nseasons=12)) #>   [1]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>   [6]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [11]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [16]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [21]    0.0000000    0.0000000    0.0000000    0.0000000    0.0000000 #>  [26]    0.0000000    0.0000000    0.1724162    1.8191105    4.4951421 #>  [31]    7.7565445   11.4980009   12.6423926    9.8891186    6.9972791 #>  [36]    4.8772707    3.5041348    3.9426081    7.5538477   12.0052028 #>  [41]   16.0912819   18.4013656   21.8425941   27.3745515   27.1230466 #>  [46]   19.2559338   13.2075814   11.0343077   11.7294921   15.1923258 #>  [51]   23.6960551   33.4628693   40.7847508   43.0180781   46.1361142 #>  [56]   51.1640328   47.3970227   34.0316649   25.1417253   23.0349050 #>  [61]   27.6035443   35.9087677   48.8440147   60.5553281   66.7411521 #>  [66]   65.1774147   64.4136176   65.6475543   58.9513993   42.9666951 #>  [71]   33.3288394   32.4003219   39.9719180   52.7790921   70.9891916 #>  [76]   84.1398829   87.5740936   79.7507837   70.4716697   63.4703631 #>  [81]   52.8261267   37.1946893   30.3301536   33.7707998   44.0232098 #>  [86]   56.9964641   72.6333310   81.0005855   80.0381422   69.4874834 #>  [91]   56.1410554   42.5697739   25.6724533    7.4528564    1.2950855 #>  [96]   10.8833122   28.4799076   44.6569911   57.1675387   59.0741944 #> [101]   51.3925223   35.5015748   16.9311209   -1.3164451  -20.8773496 #> [106]  -36.9635997  -38.1281286  -21.1657024    2.8171803   21.0717162 #> [111]   31.1198506   27.7276406   16.2040795   -2.5995738  -23.9848763 #> [116]  -45.4596366  -66.4651792  -80.3087614  -75.9940561  -51.7663846 #> [121]  -23.9730144   -7.8511855   -3.8292833  -15.2040259  -29.5410071 #> [126]  -45.7776925  -62.3336774  -81.4535313 -102.9191513 -119.3549942 #> [131] -116.3438834  -89.8340741  -59.3806523  -41.3307688  -36.4498937 #> [136]  -51.2301545  -69.7100193  -88.3789172 -103.2578737 -117.5078036 #> [141] -132.6115490 -144.8983306 -140.0161477 -113.7587376  x <- sim_sarima(n=144, model=list(ma=0.4, iorder=1, siorder=1, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sma=0.4, iorder=1, siorder=1, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sma=0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sar=0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)  x <- sim_sarima(n=144, model=list(sar=-0.4, iorder=0, siorder=0, nseasons=12)) acf(x, lag.max=48)   x <- sim_sarima(n=144, model=list(ar=c(1.2, -0.8), ma=0.4, sar=0.3, sma=0.7,                                   iorder=1, siorder=1, nseasons=12)) ## use xintercept to include arbitrary trend/covariates sim_sarima(n = 144, model = list(sma = 0.4, ma = 0.4, sar = 0.8, ar = 0.5,      nseasons = 12, sigma2 = 1), xintercept = 1:144) #>   [1]  -2.1461016  -1.4891387  -0.4078933   2.2886570   0.6755563  -0.3102220 #>   [7]  -0.8142428  -0.9689355  -3.5960172  -3.1248383  -2.6062497  -2.8400135 #>  [13]  -2.1256047  11.9094415  19.7567539  28.5178831  30.0438121  33.5759352 #>  [19]  35.4122264  36.8401710  36.5895983  38.2088620  39.7584226  43.0043981 #>  [25]  45.8327279  58.2397101  65.7340500  74.9334957  76.8157773  82.4298005 #>  [31]  87.5226703  91.6669206  94.2428586  97.2973871  99.5370678 105.3780248 #>  [37] 109.5190590 120.7336107 128.8949223 137.1487882 138.6252715 145.5954941 #>  [43] 152.6091945 158.9040716 165.7149108 171.0091528 173.3630452 181.7217368 #>  [49] 187.9540497 197.4574229 204.4537625 212.0634804 214.1714191 220.8593514 #>  [55] 226.9397476 234.7625188 242.7476025 250.8789981 253.6823932 264.4878770 #>  [61] 271.7631993 278.9931238 286.1764589 293.7123641 298.2367433 308.2717398 #>  [67] 314.1801728 322.0563573 330.6252158 339.9172093 343.7181023 355.4614569 #>  [73] 362.4713701 371.0649804 379.0994767 386.6083913 393.6681186 403.5215265 #>  [79] 408.7359517 416.7860551 425.5312845 434.5839601 438.0941003 448.6127197 #>  [85] 458.0702276 469.2617365 478.4345738 486.8826292 493.4465134 501.3432968 #>  [91] 506.8039153 516.0017700 525.2290142 534.9759370 538.8131544 550.3558302 #>  [97] 559.7974928 568.8627353 577.1182670 586.1986237 593.2753396 601.3631821 #> [103] 610.1223290 622.4949412 632.4467767 641.4825570 644.8896431 656.6533666 #> [109] 667.2467434 673.9915671 682.4763849 689.6972364 697.3010446 708.1278366 #> [115] 717.8402720 730.7457609 739.9243523 748.8903377 752.3582050 762.3901845 #> [121] 773.4121774 780.4905820 790.3725771 798.4905145 809.7143811 821.0743213 #> [127] 829.3444613 839.5700103 847.1976702 855.9355059 862.3534774 872.3205948 #> [133] 881.9431626 887.5647498 898.9524857 908.2990875 920.6832114 932.9809209 #> [139] 941.6063657 950.3792157 959.2521852 969.0425863 975.4049226 984.2753883"},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Density — spectrum","title":"Spectral Density — spectrum","text":"Estimate spectral density time series compute spectral   density associated time series model.","code":""},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Density — spectrum","text":"","code":"spectrum(x, standardize = TRUE, ...)  # S3 method for default spectrum(x, standardize = TRUE, raw = TRUE, taper = 0.1,           demean = FALSE, detrend = TRUE, ...)  # S3 method for genspec print(x, n.head = min(length(x$spec), 6), sort = TRUE, ...)  # S3 method for Arima spectrum(x, standardize = TRUE, ...)  # S3 method for ArmaModel spectrum(x, standardize = TRUE, ...)  # S3 method for SarimaModel spectrum(x, standardize = TRUE, ...)  # S3 method for function spectrum(x, standardize = TRUE, param = list(), ...)"},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Density — spectrum","text":"x model univariate multivariate time series. standardize TRUE, default method standardises time series     computing periodogram, methods models scale     spectral density probability density function. raw TRUE, default, compute completely raw periodogram,     unless arguments request otherwise, see section Details.  taper,demean,detrend see spec.pgram section ‘Details’.  ... arguments default method. Currently used     methods. n.head many rows print? sort TRUE, FALSE \"max\", see section ‘Details'’. param named list, specying model parameters \"function\"     method, see section ‘Details’.","code":""},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spectral Density — spectrum","text":"spectrum package sarima generic function   default method namesake package stats, see   spectrum full description   functionality. Autoprinting objects returned spectrum prints concise   information plots spectrum. means plot   produced, example, result call spectrum()   assigned variable command containing just name   object executed. want graph, just assign   result variable. control printing (  example, number digits) use print(object, ...)   explicitly. case plot produced. additional graphical   parameters desired, call plot, .... methods print basic information object table   giving influential frequencies contributions   spectrum. Methods objects representing ARIMA SARIMA models (fitted   theoretical) compute corresponding spectral densities.   non-stationary models, spectral density stationary part.   methods spectrum return objects class   \"Spectrum\".  standardize = TRUE spectral density   scaled, integrates one (probability   density function).  fitted models confidence bands   computed currently. method class \"function\" can used create objects   class \"Spectrum\" using user specified function.   first argument function needs vector frequencies   calculate spectrum. conventionally called   freq required.  parameters   part signature function need   listed given values named list via argument param, see   examples class \"Spectrum\". method   somewhat experimental restrictions might relaxed   future release. rest section describes default method. futher   details methods see \"Spectrum\".","code":""},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"the-default-method-for-spectrum","dir":"Reference","previous_headings":"","what":"The default method for spectrum","title":"Spectral Density — spectrum","text":"default method wrapper stats::spectrum(). default method returns object class \"genspec\".     inherits \"spec\", class returned     stats::spectrum, adds additional components.     main difference though print method, plots     object discussed .  raw = FALSE     arguments equivalent stats::spectrum(object)     computes raw periodogram (standardised time series     standardize = TRUE). still detrends tapers     series though.  raw = TRUE sets detrend     FALSE, taper zero, demean     TRUE, compute ‘completely raw’ periodogram.     cases, arguments respected. Argument sort print method \"genspec\"     controls sorting order columns printed table.     FALSE, sorting done.  TRUE, spectrum     sorted decreasing order, first row contains frequency     highest value spectrum. \"max\", local     maxima found sorted decreasing order, followed     rest, also sorted decreasing order. Note due aliasing     local maxima may shifted “true” frequency     (e.g. exactly harmonics number     seasons). Tapering smoothing parameters may help. plot method class \"genspec\" inherited     \"spec\", see ?plot.spec.","code":""},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Density — spectrum","text":"default method, object class \"genspec\",   inherits \"spec\", contains following additional   components: standardized TRUE FALSE, nseasons number seasons, freq.range numeric(2), frequency range - (-m/2, m/2],     m = floor(frequency(x)); remaining methods, object class \"Spectrum\".","code":""},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spectral Density — spectrum","text":"Georgi N. Boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/spectrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Density — spectrum","text":"","code":"## spectral density of the stationary part of a fitted 'airline model' fit0 <- arima(AirPassengers, order = c(0,1,1),               seasonal = list(order = c(0,1,1), period = 12)) spectrum(fit0) #> standardized spectral density of the following ARMA(0,13) model: #>   ar coef:  #>   ma coef: -0.3087 0 0 0 0 0 0 0 0 0 0 -0.1074 0.03317 #>   sigma2:  135.4237 #>  #>  #>  #> Peaks: #>            freq      spec    period #> [1,] 0.04330709 0.5534585 23.090909 #> [2,] 0.12992126 0.7355095  7.696970 #> [3,] 0.21259843 1.0438583  4.703704 #> [4,] 0.29527559 1.3951830  3.386667 #> [5,] 0.37795276 1.6971778  2.645833 #> [6,] 0.46062992 1.8701110  2.170940 #>  #> Troughs: #>  #>            freq      spec    period #> [1,] 0.00000000 0.3436561  0.000000 #> [2,] 0.08267717 0.4023487 12.095238 #> [3,] 0.16535433 0.5631871  6.047619 #> [4,] 0.24803150 0.7843876  4.031746 #> [5,] 0.33070866 1.0084214  3.023810 #> [6,] 0.41732283 1.1732882  2.396226 #> [7,] 0.50000000 1.2314609  2.000000 #>  #> max peak/min trough: #> \t5.441809 #>    ## spectral densities of some ARMA models models from Chan and Gray (). ##   (TODO: complete the reference) spectrum(ArmaModel(ma = c(-1, 0.6), sigma2 = 1)) #> standardized spectral density of the following ARMA(0,2) model: #>   ar coef:  #>   ma coef: -1 0.6 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>      freq      spec period #> [1,]  0.0 0.1525424      0 #> [2,]  0.5 2.8644068      2 #>  #> Troughs: #>  #>           freq       spec   period #> [1,] 0.1338583 0.03954802 7.470588 #>  #> max peak/min trough: #> \t72.42857 #>   spectrum(ArmaModel(ar = 0.5, sigma2 = 1)) #> standardized spectral density of the following ARMA(1,0) model: #>   ar coef: 0.5 #>   ma coef:  #>   sigma2:  1 #>  #>  #>  #> Peaks: #>      freq spec period #> [1,]    0    3      0 #>  #> Troughs: #>  #>      freq      spec period #> [1,]  0.5 0.3333333      2 #>  #> max peak/min trough: #> \t9 #>   spectrum(ArmaModel(ar = 0.5, ma = -0.8, sigma2 = 1)) #> standardized spectral density of the following ARMA(1,1) model: #>   ar coef: 0.5 #>   ma coef: -0.8 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>      freq     spec period #> [1,]  0.5 1.285714      2 #>  #> Troughs: #>  #>      freq      spec period #> [1,]    0 0.1428571      0 #>  #> max peak/min trough: #> \t9 #>   spectrum(new(\"SarimaModel\", ar = 0.5, sar = 0.9, nseasons = 12, sigma2 = 1)) #> standardized spectral density of the following ARMA(13,0) model: #>   ar coef: 0.5 0 0 0 0 0 0 0 0 0 0 0.9 -0.45 #>   ma coef:  #>   sigma2:  1 #>  #>  #>  #> Peaks: #>            freq      spec    period #> [1,] 0.00000000 56.974957  0.000000 #> [2,] 0.08267717 30.563559 12.095238 #> [3,] 0.16535433 10.196422  6.047619 #> [4,] 0.24803150  3.863367  4.031746 #> [5,] 0.33464567  4.310839  2.988235 #> [6,] 0.41732283  5.511054  2.396226 #> [7,] 0.50000000  6.330551  2.000000 #>  #> Troughs: #>  #>            freq       spec    period #> [1,] 0.04330709 0.13810376 23.090909 #> [2,] 0.12598425 0.07219447  7.937500 #> [3,] 0.20866142 0.03973364  4.792453 #> [4,] 0.29133858 0.02618904  3.432432 #> [5,] 0.37401575 0.02023360  2.673684 #> [6,] 0.45669291 0.01789584  2.189655 #>  #> max peak/min trough: #> \t3183.698 #>    mo <- new(\"SarimaModel\", ma = -0.4, sma = -0.9, nseasons = 12, sigma2 = 1) sp1.mo <- spectrum(mo) ## this also plots the object.  (if you are reading the web version, generated ##     by pkgdown, it may not be showing some of the graphs, ##     I haven't figured out why.) show(sp1.mo)  # equivalently, just sp1.mo #> standardized spectral density of the following ARMA(0,13) model: #>   ar coef:  #>   ma coef: -0.4 0 0 0 0 0 0 0 0 0 0 -0.9 0.36 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>            freq      spec    period #> [1,] 0.04330709 0.6670335 23.090909 #> [2,] 0.12598425 1.0264726  7.937500 #> [3,] 0.20866142 1.6409588  4.792453 #> [4,] 0.29133858 2.3473830  3.432432 #> [5,] 0.37401575 2.9570034  2.673684 #> [6,] 0.45669291 3.3067228  2.189655 #>  #> Troughs: #>  #>            freq        spec    period #> [1,] 0.00000000 0.001714612  0.000000 #> [2,] 0.08267717 0.002705604 12.095238 #> [3,] 0.16535433 0.006755661  6.047619 #> [4,] 0.24803150 0.016318029  4.031746 #> [5,] 0.33464567 0.014022696  2.988235 #> [6,] 0.41732283 0.010777767  2.396226 #> [7,] 0.50000000 0.009335111  2.000000 #>  #> max peak/min trough: #> \t1928.554 #>   print(sp1.mo) #> standardized spectral density of the following ARMA(0,13) model: #>   ar coef:  #>   ma coef: -0.4 0 0 0 0 0 0 0 0 0 0 -0.9 0.36 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>            freq      spec    period #> [1,] 0.04330709 0.6670335 23.090909 #> [2,] 0.12598425 1.0264726  7.937500 #> [3,] 0.20866142 1.6409588  4.792453 #> [4,] 0.29133858 2.3473830  3.432432 #> [5,] 0.37401575 2.9570034  2.673684 #> [6,] 0.45669291 3.3067228  2.189655 #>  #> Troughs: #>  #>            freq        spec    period #> [1,] 0.00000000 0.001714612  0.000000 #> [2,] 0.08267717 0.002705604 12.095238 #> [3,] 0.16535433 0.006755661  6.047619 #> [4,] 0.24803150 0.016318029  4.031746 #> [5,] 0.33464567 0.014022696  2.988235 #> [6,] 0.41732283 0.010777767  2.396226 #> [7,] 0.50000000 0.009335111  2.000000 #>  #> max peak/min trough: #> \t1928.554 #>   print(sp1.mo, digits = 4) #> standardized spectral density of the following ARMA(0,13) model: #>   ar coef:  #>   ma coef:  -0.4 0 0 0 0 0 0 0 0 0 0  -0.9  0.36 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>         freq  spec period #> [1,] 0.04331 0.667 23.091 #> [2,] 0.12598 1.026  7.938 #> [3,] 0.20866 1.641  4.792 #> [4,] 0.29134 2.347  3.432 #> [5,] 0.37402 2.957  2.674 #> [6,] 0.45669 3.307  2.190 #>  #> Troughs: #>  #>         freq     spec period #> [1,] 0.00000 0.001715  0.000 #> [2,] 0.08268 0.002706 12.095 #> [3,] 0.16535 0.006756  6.048 #> [4,] 0.24803 0.016318  4.032 #> [5,] 0.33465 0.014023  2.988 #> [6,] 0.41732 0.010778  2.396 #> [7,] 0.50000 0.009335  2.000 #>  #> max peak/min trough: #> \t1929 #>  plot(sp1.mo) plot(sp1.mo, standardize = FALSE)   ## the object can be used as a function: head(sp1.mo()) #> [1] 0.001714612 0.002554241 0.005068983 0.009246422 0.015065928 0.022498754 sp1.mo(seq(0, 0.5, length.out = 12)) #>  [1] 0.001714612 0.661065422 0.068597027 0.905495120 0.418742992 1.029489635 #>  [7] 1.253567502 0.755017203 2.396990318 0.258191527 3.247318393 0.009335111 sp1.mo(seq(0, 0.5, length.out = 12), standardize = FALSE) #>  [1] 0.0036000 1.3879730 0.1440263 1.9011776 0.8791928 2.1615164 2.6319903 #>  [8] 1.5852341 5.0327209 0.5420989 6.8180697 0.0196000  sarima1b <- new(\"SarimaModel\", ar = 0.9, ma = 0.1, sar = 0.5, sma = 0.9,                 nseasons = 12, sigma2 = 1) spectrum(sarima1b) #> standardized spectral density of the following ARMA(13,13) model: #>   ar coef: 0.9 0 0 0 0 0 0 0 0 0 0 0.5 -0.45 #>   ma coef: 0.1 0 0 0 0 0 0 0 0 0 0 0.9 0.09 #>   sigma2:  1 #>  #>  #>  #> Peaks: #>            freq        spec    period #> [1,] 0.00000000 51.42130332  0.000000 #> [2,] 0.08267717  2.02154462 12.095238 #> [3,] 0.16535433  0.51509112  6.047619 #> [4,] 0.24803150  0.22927643  4.031746 #> [5,] 0.33464567  0.13874701  2.988235 #> [6,] 0.41732283  0.10481430  2.396226 #> [7,] 0.50000000  0.09535326  2.000000 #>  #> Troughs: #>  #>            freq         spec    period #> [1,] 0.04330709 4.917941e-03 23.090909 #> [2,] 0.12598425 4.133602e-04  7.937500 #> [3,] 0.20866142 1.086967e-04  4.792453 #> [4,] 0.29133858 5.822878e-05  3.432432 #> [5,] 0.37401575 5.537596e-05  2.673684 #> [6,] 0.45669291 7.189623e-05  2.189655 #>  #> max peak/min trough: #> \t928585.3 #>    ## default method for spectrum()  ## frequency range is c(-1/2, 1/2] since frequency(x) = 1 frequency(lh) #> [1] 1 spectrum(lh) #> Estimated spectral density #>     series: lh #>     method: Raw Periodogram #>     nseasons: 1 #>     frequency range: (0,0] #>  #>     sort method for the table: decreasing magnitudes #>  #>                freq     spec    % Total    Cum. % #>     [1,] 0.12500000 4.965426 0.21098733 0.2109873 #>     [2,] 0.06250000 4.130890 0.17552683 0.3865142 #>     [3,] 0.04166667 2.624937 0.11153696 0.4980511 #>     [4,] 0.16666667 2.186349 0.09290079 0.5909519 #>     [5,] 0.08333333 2.178577 0.09257054 0.6835224 #>     [6,] 0.02083333 1.073144 0.04559926 0.7291217   ## frequency range is c(-12/2, 12/2] since frequency(x) = 12 frequency(ldeaths) #> [1] 12 ( sp <- spectrum(ldeaths) ) #> Estimated spectral density #>     series: ldeaths #>     method: Raw Periodogram #>     nseasons: 12 #>     frequency range: (-6,6] #>  #>     sort method for the table: decreasing magnitudes #>  #>               freq       spec     % Total    Cum. % #>     [1,] 1.0000000 2.38062771 0.804713030 0.8047130 #>     [2,] 2.0000000 0.11677995 0.039474610 0.8441876 #>     [3,] 0.1666667 0.07652480 0.025867339 0.8700550 #>     [4,] 3.5000000 0.02873917 0.009714574 0.8797696 #>     [5,] 2.5000000 0.02469094 0.008346168 0.8881157 #>     [6,] 2.3333333 0.02371560 0.008016480 0.8961322 print(sp) # equivalently: print(sp, sort = TRUE) #> Estimated spectral density #>     series: ldeaths #>     method: Raw Periodogram #>     nseasons: 12 #>     frequency range: (-6,6] #>  #>     sort method for the table: decreasing magnitudes #>  #>               freq       spec     % Total    Cum. % #>     [1,] 1.0000000 2.38062771 0.804713030 0.8047130 #>     [2,] 2.0000000 0.11677995 0.039474610 0.8441876 #>     [3,] 0.1666667 0.07652480 0.025867339 0.8700550 #>     [4,] 3.5000000 0.02873917 0.009714574 0.8797696 #>     [5,] 2.5000000 0.02469094 0.008346168 0.8881157 #>     [6,] 2.3333333 0.02371560 0.008016480 0.8961322  print(sp, sort = FALSE, n.head = 3) #> Estimated spectral density #>     series: ldeaths #>     method: Raw Periodogram #>     nseasons: 12 #>     frequency range: (-6,6] #>  #>     sort method for the table: none #>  #>               freq        spec    % Total     Cum. % #>     [1,] 0.1666667 0.076524801 0.02586734 0.02586734 #>     [2,] 0.3333333 0.014714243 0.00497379 0.03084113 #>     [3,] 0.5000000 0.008322536 0.00281323 0.03365436 print(sp, sort = \"max\") #> Estimated spectral density #>     series: ldeaths #>     method: Raw Periodogram #>     nseasons: 12 #>     frequency range: (-6,6] #>  #>     sort method for the table: local maxima first #>  #>               freq       spec     % Total    Cum. % ranks #>     [1,] 1.0000000 2.38062771 0.804713030 0.8047130     1 #>     [2,] 2.0000000 0.11677995 0.039474610 0.8441876     2 #>     [3,] 0.1666667 0.07652480 0.025867339 0.8700550     3 #>     [4,] 3.5000000 0.02873917 0.009714574 0.8797696     4 #>     [5,] 2.5000000 0.02469094 0.008346168 0.8881157     5 #>     [6,] 1.5000000 0.02150740 0.007270051 0.8953858     6 plot(sp) plot(sp, log = \"dB\")  # see ?plot.spec for further arguments"},{"path":"https://geobosh.github.io/sarima/reference/summary.SarimaModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for summary in package sarima — summary.SarimaModel","title":"Methods for summary in package sarima — summary.SarimaModel","text":"Methods summary package sarima.","code":""},{"path":"https://geobosh.github.io/sarima/reference/summary.SarimaModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for summary in package sarima — summary.SarimaModel","text":"","code":"# S3 method for SarimaModel summary(object, ...) # S3 method for SarimaFilter summary(object, ...) # S3 method for SarimaSpec summary(object, ...)"},{"path":"https://geobosh.github.io/sarima/reference/summary.SarimaModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for summary in package sarima — summary.SarimaModel","text":"object object corresponding class. ... arguments methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/summary.SarimaModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Methods for summary in package sarima — summary.SarimaModel","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Produce diagnostics fitted seasonal ARIMA models. method   offers several portmanteau tests (including Ljung-Box, Li-McLeod   Box-Pierce), plots autocorrelations partial autocorrelations   residuals, ability control graphs produced (including   interactively), well layout.","code":""},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"","code":"# S3 method for Sarima tsdiag(object, gof.lag = NULL, ask = FALSE, ..., plot = 1:3, layout = NULL)  # if 'object' is not produced by sarima(), use the full name, # 'tsdiag.Sarima()', in the call. The arguments are the same."},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"object fitted (seasonal) ARIMA model. currently output     sarima, stats::arima compatible (e.g.,     forecast::Arima forecast::auto.arima).      object sarima, use full name,     tsdiag.Sarima, method calling , see     examples.  gof.lag maximal lag portmanteau tests. ask TRUE present menu available plots, see Details. ... used. plot TRUE available plots; vector positive integers     specifies subset available plots. layout list arguments graphics::layout plots.     default ARIMA method stats::tsdiag.","code":""},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Compute graph diagnostics seasonal ARIMA models. objects   class \"Sarima\" (produced sarima) just call   generic, tsdiag. method can called also directly output   base R's arima() tsdiag.Sarima()   sarima::tsdiag.Sarima(). method offers several portmanteau tests (including Ljung-Box,   Li-McLeod Box-Pierce), plots autocorrelations partial   autocorrelations residuals, ability control graphs   produced (including interactively), well layout. method always makes correction degrees freedom   portmanteau tests (roughly, subtracting number estimated ARMA   parameters). Note stats::tsdiag . plot can TRUE ask plots vector   positive integers specifying plots consider. Currently   following options available: argument plot length two graphics window split   2 equal subwindows. Argument layout can still used   change .  argument plot length one graphics   window split . interactive sessions, number requested graphs (  specified argument plot) larger number graphs   specified layout (default 3), function makes first   graph presents menu requested plots. Argument layout can used change layout plot,   example put two graphs per plot, see examples. Currently   list arguments layout, see ?layout.   call layout youself, change graphics   device prematurely. computed results returned (invisibly). another   difference stats::tsdiag return .","code":""},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"list components: residuals residuals LjungBox Ljung box test LiMcLeod LiMcLeod test BoxPierce BoxPierce test components actually computed included, rest   NULL absent.","code":""},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"Georgi N. boshnakov","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/tsdiag.Sarima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostic Plots for fitted seasonal ARIMA models — tsdiag.Sarima","text":"","code":"ap.baseA <- sarima(log(AirPassengers) ~      0 | ma(1, c(-0.3)) + sma(12,1, c(-0.1)) + i(1) + si(12,1),      ss.method = \"base\") tsdiag(ap.baseA)   ## apply the method on objects from arima() ap.arima <- arima(log(AirPassengers), order = c(0,1,1), seasonal = c(0,1,1)) tsdiag.Sarima(ap.arima)  ## use Li-McLeod test instead of Ljung-Box tsdiag.Sarima(ap.arima, plot = c(1:2,4))  ## call R's tsdiag method, for comparison: tsdiag(ap.arima, plot = c(1:2,4))   ## plot only acf an p-values tsdiag.Sarima(ap.arima, plot = c(2:3), layout = list(matrix(1:2, nrow = 2)))  ## plot only acf an p-values tsd <- tsdiag.Sarima(ap.arima, plot = c(2:3), layout = list(matrix(1:2, nrow = 2)))  ## the results can be used for further calculations: head(tsd$LjungBox$test, 4) #>           ChiSq DF    pvalue #> [1,] 0.03065128  1 0.8610207 #> [2,] 0.11260997  1 0.7371921 #> [3,] 2.45802081  1 0.1169260 #> [4,] 4.30491459  2 0.1161983  ## plot resid, acf, and p-values, leaving half the space for residuals # tsdiag.Sarima(ap.arima, plot = c(1:3), layout = list(matrix(1:3, nrow = 3), #                                                      heights = c(1,2,2)))"},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":null,"dir":"Reference","previous_headings":"","what":"White noise tests — whiteNoiseTest","title":"White noise tests — whiteNoiseTest","text":"White noise tests.","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"White noise tests — whiteNoiseTest","text":"","code":"whiteNoiseTest(object, h0, ...)"},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"White noise tests — whiteNoiseTest","text":"object object, sample autocorrelations partial autocorrelations. h0 null hypothesis, currently \"iid\" \"garch\". ... additional arguments passed methods.","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"White noise tests — whiteNoiseTest","text":"whiteNoiseTest carries tests white noise.  null   hypothesis identified argument h0, based   whiteNoiseTest chooses suitable function call.    functions implementing tests also available called   directly documentation consulted   arguments available. h0 = \"iid\", test statistics rejection regions can   use test underlying time series iid. Argument   method specifies method portmanteau tests: one   \"LiMcLeod\" (default), \"LjungBox\", \"BoxPierce\". h0 = \"garch\", null hypothesis time series   GARCH, see Francq & Zakoian (2010).   tests case based non-parametric estimate   asymptotic covariance matrix. Portmonteau statistics p-values computed lags   specified argument nlags. missing, suitable lags   chosen automatically. argument interval TRUE, confidence intervals   individual autocorrelations partial autocorrelations computed.","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"White noise tests — whiteNoiseTest","text":"list component test , ci=TRUE, component  ci.","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"White noise tests — whiteNoiseTest","text":"Francq C, Zakoian J (2010). GARCH models: structure, statistical inference financial applications. John Wiley & Sons. ISBN 978-0-470-68391-0. Li WK (2004). Diagnostic checks time series. Chapman & Hall/CRC Press.","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"White noise tests — whiteNoiseTest","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"White noise tests — whiteNoiseTest","text":"methods added future.","code":""},{"path":[]},{"path":"https://geobosh.github.io/sarima/reference/whiteNoiseTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"White noise tests — whiteNoiseTest","text":"","code":"n <- 5000 x <- sarima:::rgarch1p1(n, alpha = 0.3, beta = 0.55, omega = 1, n.skip = 100) x.acf <- autocorrelations(x) x.pacf <- partialAutocorrelations(x)  x.iid <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LiMcLeod\") x.iid #> $test #>          ChiSq DF    pvalue #> [1,]  1.142892  5 0.9502373 #> [2,]  6.425240 10 0.7783615 #> [3,] 19.813720 20 0.4696354 #> attr(,\"method\") #> [1] \"LiMcLeod\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.iid2 <- whiteNoiseTest(x.acf, h0 = \"iid\", nlags = c(5,10,20), x = x, method = \"LjungBox\") x.iid2 #> $test #>          ChiSq DF    pvalue #> [1,]  1.140803  5 0.9504289 #> [2,]  6.424512 10 0.7784265 #> [3,] 19.832409 20 0.4684563 #> attr(,\"method\") #> [1] \"LjungBox\" #>  #> $ci #>               int            #>  [1,] -0.02771808 0.02771808 #>  [2,] -0.02771808 0.02771808 #>  [3,] -0.02771808 0.02771808 #>  [4,] -0.02771808 0.02771808 #>  [5,] -0.02771808 0.02771808 #>  [6,] -0.02771808 0.02771808 #>  [7,] -0.02771808 0.02771808 #>  [8,] -0.02771808 0.02771808 #>  [9,] -0.02771808 0.02771808 #> [10,] -0.02771808 0.02771808 #> [11,] -0.02771808 0.02771808 #> [12,] -0.02771808 0.02771808 #> [13,] -0.02771808 0.02771808 #> [14,] -0.02771808 0.02771808 #> [15,] -0.02771808 0.02771808 #> [16,] -0.02771808 0.02771808 #> [17,] -0.02771808 0.02771808 #> [18,] -0.02771808 0.02771808 #> [19,] -0.02771808 0.02771808 #> [20,] -0.02771808 0.02771808 #> attr(,\"level\") #> [1] 0.95 #>   x.garch <- whiteNoiseTest(x.acf, h0 = \"garch\", nlags = c(5,10,20), x = x) x.garch #> $test #>       h          Q      pval #> [1,]  5  0.5452572 0.9903723 #> [2,] 10  4.7304542 0.9084415 #> [3,] 20 17.2858687 0.6343406 #>  #> $ci #>               int            #>  [1,] -0.04316442 0.04316442 #>  [2,] -0.04180554 0.04180554 #>  [3,] -0.03876060 0.03876060 #>  [4,] -0.03604820 0.03604820 #>  [5,] -0.03508113 0.03508113 #>  [6,] -0.03319458 0.03319458 #>  [7,] -0.03167507 0.03167507 #>  [8,] -0.03151315 0.03151315 #>  [9,] -0.03082342 0.03082342 #> [10,] -0.03031157 0.03031157 #> [11,] -0.03010730 0.03010730 #> [12,] -0.02881384 0.02881384 #> [13,] -0.02767999 0.02767999 #> [14,] -0.02809412 0.02809412 #> [15,] -0.02776439 0.02776439 #> [16,] -0.02827813 0.02827813 #> [17,] -0.02735102 0.02735102 #> [18,] -0.02801310 0.02801310 #> [19,] -0.02805033 0.02805033 #> [20,] -0.02855553 0.02855553 #>"},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies an extended ARMA filter to a time series — xarmaFilter","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"Filter time series extended arma filter.   whiten FALSE (default) function applies   given ARMA filter eps (eps often   white noise).  whiten TRUE function applies   “inverse filter” \\(x\\), effectively computing   residuals.","code":""},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"","code":"xarmaFilter(model, x = NULL, eps = NULL, from = NULL, whiten = FALSE,             xcenter = NULL, xintercept = NULL)"},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"x time series filtered, vector. eps residuals, vector NULL. model model parameters, list components \"ar\",     \"ma\", \"center\" \"intercept\", see Details. index start filtering. whiten TRUE use x input apply inverse filter     produce eps (\"whiten\" x), FALSE use eps     input generate x (\"colour\" eps). xcenter vector means length time series, see Details. xintercept vector intercepts length series, see Details.","code":""},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"model specified argument model, list   following components: ar autoregression parameters, ma moving average parameters, center center value, intercept intercept. model$center model$intercept scalars usually   one nonzero. can considered part   model specification. contrast, arguments xcenter   xintercept vectors length x. can   represent contributions covariate variables. Usually one   xcenter xintercept used. description uses \\(\\mu_t\\) \\(c_t\\)   contributions model$center plus xcenter   model$intercept plus xintercept, respectively.   time series \\(\\{x_t\\}\\) \\(\\{\\varepsilon_t\\}\\)   represented x eps R code.   Let       $$y_t = x_t - \\mu_t$$   centered series.  centering term \\(\\mu_t\\)   essentially sum center xcenter   necessarilly mean.  equation relating centered series,   \\(y_t=x_t - \\mu_t\\), eps   following:     $$ y_t     =   c_t       + \\sum_{=1}^{p} \\phi()y            _{t-}       + \\sum_{=1}^{q} \\theta()\\varepsilon_{t-}       + \\varepsilon_t     $$   \\(c_t\\) intercept (basically sum   intercept xintercept). whiten = FALSE, \\(y_t\\) computed   t=,...,n using formula, .e. filter   applied get y eps (initial values).   eps white noise, can said y obtained   ``colouring'' white noise eps. can used,   example, simulate ARIMA time series.  Finally, centering term   added back, \\(x_t=y_t+\\mu_t\\) t=,...,n,   modified x returned.  first - 1 elements   x left unchanged. inverse filter obtained rewriting equation equation   expressing \\(\\varepsilon_t\\) terms remaining quantities:   $$ \\varepsilon_t     = - c_t       - \\sum_{=1}^{q} \\theta()\\varepsilon_{t-}       - \\sum_{=1}^{p} \\phi  ()y          _{t-}       + y_t     $$ whiten = TRUE, xarmaFilter uses formula   t=,...,n compute eps y (  initial values). eps white noise, can said   time series y whitened. cases first values x /  eps used initial values. centering formed model$center argument   xcenter.  model$center supplied recycled   length series, x, subtracted   x. argument xcenter supplied, subtracted   x. model$center xcenter   supplied sum subtracted x. xarmaFilter can used simulate ARMA series   default value whiten = FALSE. case eps   input series y output:   model$center /xcenter added y   form output vector x. Residuals corresponding series x can obtained   setting whiten = TRUE. case x input series.   elements output vector eps calculated   formula \\(\\varepsilon_{t}\\) given .   need case restore x since eps   returned. cases necessary initial values assumed already   vectors provide first - 1 values   returned vectors.  Argument smaller   default value max(p,q)+1. xarmaFilter calls lower level function coreXarmaFilter   computation.","code":""},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"result applying filter inverse, descibed Details:     whiten = FALSE, modified x;     whiten = TRUE, modified eps.","code":""},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/sarima/reference/xarmaFilter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies an extended ARMA filter to a time series — xarmaFilter","text":"","code":"## define a seasonal ARIMA model m1 <- new(\"SarimaModel\", iorder = 1, siorder = 1, ma = -0.3, sma = -0.1, nseasons = 12)  model0 <- modelCoef(m1, \"ArmaModel\") model1 <- as(model0, \"list\")  ap.1 <- xarmaFilter(model1, x = AirPassengers, whiten = TRUE) ap.2 <- xarmaFilter(model1, x = AirPassengers, eps = ap.1, whiten = FALSE) ap <- AirPassengers ap[-(1:13)] <- 0 # check that the filter doesn't use x, except for initial values. ap.2a <- xarmaFilter(model1, x = ap, eps = ap.1, whiten = FALSE) ap.2a - ap.2 ## indeed = 0 #>      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #> 1949   0   0   0   0   0   0   0   0   0   0   0   0 #> 1950   0   0   0   0   0   0   0   0   0   0   0   0 #> 1951   0   0   0   0   0   0   0   0   0   0   0   0 #> 1952   0   0   0   0   0   0   0   0   0   0   0   0 #> 1953   0   0   0   0   0   0   0   0   0   0   0   0 #> 1954   0   0   0   0   0   0   0   0   0   0   0   0 #> 1955   0   0   0   0   0   0   0   0   0   0   0   0 #> 1956   0   0   0   0   0   0   0   0   0   0   0   0 #> 1957   0   0   0   0   0   0   0   0   0   0   0   0 #> 1958   0   0   0   0   0   0   0   0   0   0   0   0 #> 1959   0   0   0   0   0   0   0   0   0   0   0   0 #> 1960   0   0   0   0   0   0   0   0   0   0   0   0 ##ap.3 <- xarmaFilter(model1, x = list(init = AirPassengers[1:13]), eps = ap.1, whiten = TRUE)  ## now set some non-zero initial values for eps eps1 <- numeric(length(AirPassengers)) eps1[1:13] <- rnorm(13) ap.A <- xarmaFilter(model1, x = AirPassengers, eps = eps1, whiten = TRUE) ap.Ainv <- xarmaFilter(model1, x = ap, eps = ap.A, whiten = FALSE) AirPassengers - ap.Ainv # = 0 #>      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec #> 1949   0   0   0   0   0   0   0   0   0   0   0   0 #> 1950   0   0   0   0   0   0   0   0   0   0   0   0 #> 1951   0   0   0   0   0   0   0   0   0   0   0   0 #> 1952   0   0   0   0   0   0   0   0   0   0   0   0 #> 1953   0   0   0   0   0   0   0   0   0   0   0   0 #> 1954   0   0   0   0   0   0   0   0   0   0   0   0 #> 1955   0   0   0   0   0   0   0   0   0   0   0   0 #> 1956   0   0   0   0   0   0   0   0   0   0   0   0 #> 1957   0   0   0   0   0   0   0   0   0   0   0   0 #> 1958   0   0   0   0   0   0   0   0   0   0   0   0 #> 1959   0   0   0   0   0   0   0   0   0   0   0   0 #> 1960   0   0   0   0   0   0   0   0   0   0   0   0  ## compare with sarima.f (an old function) ## compute predictions starting at from = 14 pred1 <- sarima.f(past = AirPassengers[1:13], n = 131, ar = model1$ar, ma = model1$ma) pred2 <- xarmaFilter(model1, x = ap, whiten = FALSE) pred2 <- pred2[-(1:13)] all(pred1 == pred2) ##TRUE #> [1] TRUE"}]
